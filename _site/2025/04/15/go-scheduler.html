<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Go Scheduler | Melatoni</title>
<meta name="generator" content="Jekyll v3.10.0" />
<meta property="og:title" content="Go Scheduler" />
<meta name="author" content="nghiant3223@gmail.com" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="‚Üë ‚Üì" />
<meta property="og:description" content="‚Üë ‚Üì" />
<link rel="canonical" href="http://localhost:4000/2025/04/15/go-scheduler.html" />
<meta property="og:url" content="http://localhost:4000/2025/04/15/go-scheduler.html" />
<meta property="og:site_name" content="Melatoni" />
<meta property="og:image" content="https://raw.githubusercontent.com/nghiant3223/nghiant3223.github.io/refs/heads/main/assets/2025-03-11-go-scheduling/primitive_scheduler.png" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2025-04-15T00:00:00+07:00" />
<meta name="twitter:card" content="summary_large_image" />
<meta property="twitter:image" content="https://raw.githubusercontent.com/nghiant3223/nghiant3223.github.io/refs/heads/main/assets/2025-03-11-go-scheduling/primitive_scheduler.png" />
<meta property="twitter:title" content="Go Scheduler" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"nghiant3223@gmail.com"},"dateModified":"2025-04-15T00:00:00+07:00","datePublished":"2025-04-15T00:00:00+07:00","description":"‚Üë ‚Üì","headline":"Go Scheduler","image":"https://raw.githubusercontent.com/nghiant3223/nghiant3223.github.io/refs/heads/main/assets/2025-03-11-go-scheduling/primitive_scheduler.png","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/2025/04/15/go-scheduler.html"},"url":"http://localhost:4000/2025/04/15/go-scheduler.html"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="Melatoni" /></head>
<body><style>
    .blog-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
    }

    .header-left h1 {
        margin: 0;
        font-size: 24px;
    }

    .header-right a {
        margin-left: 15px;
        color: #333;
    }

    .blog-header a:hover {
        color: #0077cc;
    }
</style>

<header class="site-header" role="banner">

  <div class="wrapper"><div class="blog-header">
        <div class="header-left">
            <h1>
                <a class="site-title" rel="author" href="/">Melatoni</a>
            </h1>
        </div>
        <div class="header-right">
            <a href="https://github.com/nghiant3223" target="_blank">GitHub</a>
            <a href="https://www.linkedin.com/in/nghiant3223" target="_blank">LinkedIn</a>
        </div>
    </div><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <link rel="stylesheet" href="/assets/fonts/style.css">

<style>
    body {
        font-family: 'Minion 3', serif;
    }

    th {
        padding: unset !important;
    }

    table {
        margin-bottom: 15px;
    }

    code {
        font-family: 'Source Code Pro', monospace;
    }

    blockquote {
        font-style: normal;
        letter-spacing: normal;
    }

    path {
        stroke-width: 1px !important;
    }

    #scrollTop {
        display: none;
        position: fixed;
        bottom: 90px;
        right: 30px;
        z-index: 100;
        font-size: 18px;
        border: none;
        outline: none;
        background-color: #333;
        color: white;
        cursor: pointer;
        padding: 8px 14px;
        border-radius: 50%;
        transition: background-color 0.3s;
    }

    #scrollTop:hover {
        background-color: #555;
    }

    #scrollBottom {
        display: none;
        position: fixed;
        bottom: 40px;
        right: 30px;
        z-index: 100;
        font-size: 18px;
        border: none;
        outline: none;
        background-color: #333;
        color: white;
        cursor: pointer;
        padding: 8px 14px;
        border-radius: 50%;
        transition: background-color 0.3s;
    }

    #scrollBottom:hover {
        background-color: #555;
    }

    .footer-col-3 {
        text-align: right !important;
    }

    .giscus {
        margin-top: 30px;
        padding-top: 30px;
        border-top: 1px solid #e8e8e8;
    }
</style>

<script>
    document.addEventListener("DOMContentLoaded", function () {
        document.querySelectorAll("a[href^='http']").forEach(function (link) {
            link.setAttribute("target", "_blank");
            link.setAttribute("rel", "noopener noreferrer");
        });
    });
</script>

<script type="module">
    import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11/dist/mermaid.esm.min.mjs';

    mermaid.initialize({
        startOnLoad: true,
        theme: 'base',
        themeVariables: {
            fontSize: '32px',
            fontFamily: 'Source Code Pro',
        }
    });
</script>

<p><button id="scrollTop" title="Go to top">‚Üë</button>
<button id="scrollBottom" title="Go to bottom">‚Üì</button></p>

<h1 id="go-scheduler">Go Scheduler</h1>

<ul>
  <li><a href="#introduction">Introduction</a></li>
  <li><a href="#compilation-and-go-runtime">Compilation and Go Runtime</a></li>
  <li><a href="#primitive-scheduler">Primitive Scheduler</a></li>
  <li><a href="#scheduler-enhancement">Scheduler Enhancement</a></li>
  <li><a href="#gmp-model">GMP Model</a></li>
  <li><a href="#program-bootstrap">Program Bootstrap</a></li>
  <li><a href="#creating-goroutine">Creating Goroutine</a></li>
  <li><a href="#schedule-loop">Schedule Loop</a></li>
  <li><a href="#finding-a-runnable-goroutine">Finding a Runnable Goroutine</a></li>
  <li><a href="#goroutine-preemption">Goroutine Preemption</a></li>
  <li><a href="#handling-system-calls">Handling System Calls</a></li>
  <li><a href="#network-io-and-file-io">Network I/O and File I/O</a></li>
  <li><a href="#how-netpoll-works">How netpoll Works</a></li>
  <li><a href="#garbage-collector">Garbage Collector</a></li>
  <li><a href="#common-functions">Common Functions</a></li>
  <li><a href="#runtime-apis">Runtime APIs</a></li>
</ul>

<h2 id="disclaimer">Disclaimer</h2>

<p>This blog post primarily focuses on <a href="https://tip.golang.org/doc/go1.24">Go 1.24</a> programming language for <a href="https://en.wikipedia.org/wiki/Linux">Linux</a> on <a href="https://en.wikipedia.org/wiki/ARM_architecture_family">ARM</a> architecture.
It may not cover platform-specific details for other operating systems or architectures.</p>

<p>The content is based on other sources and my own understanding of Go, so it might not be entirely accurate.
Feel free to correct me or give suggestions in the comment section üòÑ.</p>

<h2 id="introduction">Introduction</h2>

<blockquote>
  <p>‚ö†Ô∏è This post assumes that you already have a basic understanding of Go concurrency (goroutines, channels, etc.).
If you‚Äôre new to these concepts, consider reviewing them before continuing.</p>
</blockquote>

<p>Go, introduced in 2009, has steadily grown in popularity as a programming language for building concurrent applications.
It is designed to be simple, efficient, and easy to use, with a focus on concurrency programming.</p>

<p>Go‚Äôs concurrency model is built around the concept of goroutines, which are lightweight user threads managed by the Go runtime on user space.
Go offers useful primitives for synchronization, such as channels, to help developers write concurrent code easily.
It also uses non-trivial techniques to make I/O bound programs efficient.</p>

<p>Understanding the Go scheduler is crucial for Go programmer to write efficient concurrent programs.
It also helps us become better at troubleshooting performance issues or tuning the performance of our Go programs.
In this post, we will explore how Go scheduler evolved over time, and how the Go code we write happens under the hood.</p>

<h2 id="compilation-and-go-runtime">Compilation and Go Runtime</h2>

<p>This post covers a lot of source code walkthrough, so it is better to have a basic understanding of how Go code is compiled and executed first.
When a Go program is built, there are three stages:</p>
<ul>
  <li><strong>Compilation</strong>: Go source files (<code class="language-plaintext highlighter-rouge">*.go</code>) are compiled into assembly files (<code class="language-plaintext highlighter-rouge">*.s</code>).</li>
  <li><strong>Assembling</strong>: The assembly files (<code class="language-plaintext highlighter-rouge">*.s</code>) are then assembled into object files (<code class="language-plaintext highlighter-rouge">*.o</code>).</li>
  <li><strong>Linking</strong>: The object files (<code class="language-plaintext highlighter-rouge">*.o</code>) are linked together to produce a single executable binary file.</li>
</ul>

<table>
    <thead>
        <tr>
            <td>
                <pre class="mermaid" style="margin: unset">

flowchart LR
start((Start)) ==&gt; |*.go files|compiler[Compiler]
compiler ==&gt; |*.s files|assembler[Assembler]
assembler ==&gt; |*.o files|linker[Linker]
linker ==&gt; |Executable binary file|_end(((End)))

                </pre>
            </td>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td style="text-align: center">
                How Go code is transformed into an executable binary file
            </td>
        </tr>
    </tbody>
</table>

<p>To understand Go scheduler, you have to understand Go runtime first.
Go runtime is the core of the programming language, providing essential functionalities such as scheduling, memory managements, and data structures.
It‚Äôs nothing but a collection of functions and data structures that makes Go programs work.
The implementation of Go runtime can be found in <a href="https://github.com/golang/go/tree/go1.24.0/src/runtime">runtime</a> package.
Go runtime is written in a combination of Go and assembly code, with the assembly code primarily used for low-level operations such as dealing with registers.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center"><img src="/assets/2025-03-11-go-scheduling/go_runtime_relationship.png" width="300" /></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">The role of Go runtime</td>
    </tr>
  </tbody>
</table>

<p>Upon compiling, Go compiler replaces some keywords and built-in functions with Go runtime‚Äôs function calls.
For example, the <code class="language-plaintext highlighter-rouge">go</code> keyword‚Äîused to spawn a new goroutine‚Äîis substituted with a call to <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/proc.go#L5014-L5030"><code class="language-plaintext highlighter-rouge">runtime.newproc</code></a>, or the <code class="language-plaintext highlighter-rouge">new</code> function‚Äîused to allocate a new object‚Äîis replaced with a call to <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/malloc.go#L1710-L1715"><code class="language-plaintext highlighter-rouge">runtime.newobject</code></a>.</p>

<p>You might be surprised to learn that some functions in the Go runtime have no Go implementation at all.
For example, functions like <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/stubs.go#L28-L31"><code class="language-plaintext highlighter-rouge">getg</code></a> are recognized by the Go compiler and replaced with low-level assembly code during compilation.
Other function, such as <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/stubs.go#L214-L214"><code class="language-plaintext highlighter-rouge">gogo</code></a>, are platform-specific and implemented entirely in assembly.
It is the responsibility of the Go linker to connect these assembly implementations with their Go declarations.</p>

<p>In some cases, a function appears to have no implementation in its package, but is actually linked to a definition in the Go runtime using the <a href="https://pkg.go.dev/cmd/compile#hdr-Linkname_Directive"><code class="language-plaintext highlighter-rouge">//go:linkname</code></a> compiler directive.
For instance, the commonly used <a href="https://github.com/golang/go/blob/go1.24.0/src/time/sleep.go#L12-L14"><code class="language-plaintext highlighter-rouge">time.Sleep</code></a> function  is linked to its actual implementation at <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/time.go#L297-L340"><code class="language-plaintext highlighter-rouge">runtime.timeSleep</code></a></p>

<h2 id="primitive-scheduler">Primitive Scheduler</h2>

<blockquote>
  <p>‚ö†Ô∏è The Go scheduler isn‚Äôt a standalone object, but rather a collection of functions that facilitate the scheduling.
Additionally, it doesn‚Äôt run on a dedicated thread; instead, it runs on the same threads that goroutines run on.
These concepts will become clearer as you read through the rest of the post.</p>
</blockquote>

<p>If you‚Äôve ever worked in concurrency programming, you might be familiar with multithreading models.
It specifies how user-space threads (coroutines in Kotlin, Lua or goroutines in Go) are multiplexed onto single or multiple kernel threads.
Typically, there are three models: many-to-one (N:1), one-to-one (1:1), and many-to-many (M:N).</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center"><img src="/assets/2025-03-11-go-scheduling/n_to_1_multithreading_model.png" /></th>
      <th style="text-align: center"><img src="/assets/2025-03-11-go-scheduling/1_to_1_multithreading_model.png" /></th>
      <th style="text-align: center"><img src="/assets/2025-03-11-go-scheduling/m_to_n_multithreading_model.png" /></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">Many-to-one<br />multithreading model<sup><a href="#references">1</a></sup></td>
      <td style="text-align: center">One-to-one<br />multithreading model<sup><a href="#references">2</a></sup></td>
      <td style="text-align: center">Many-to-many<br />multithreading model<sup><a href="#references">3</a></sup></td>
    </tr>
  </tbody>
</table>

<p>Go opts for the many-to-many (M:N) threading model, which allows multiple goroutines to be multiplexed onto multiple kernel threads.
This approach sacrifices complexity to take advantage of multicore system and make Go program efficient with system calls, addressing the problems of both N:1 and 1:1 models.
As kernel doesn‚Äôt know what goroutine is and only offers thread as concurrency unit to user-space application, it is the kernel thread that runs scheduling logic, executes goroutine code, and makes system call on behalf of goroutines.</p>

<p>In the early days, particularly before version 1.1, Go implemented the M:N multithreading model in a naive way.
There were only two entities: goroutines (<code class="language-plaintext highlighter-rouge">G</code>) and kernel threads (<code class="language-plaintext highlighter-rouge">M</code>, or <em>machines</em>).
A single global run queue was used to store all runnable goroutines and guarded with lock to prevent race condition.
The scheduler‚Äîrunning on every thread <code class="language-plaintext highlighter-rouge">M</code>‚Äîwas responsible for selecting a goroutine from the global run queue and executing it.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center"><img src="/assets/2025-03-11-go-scheduling/primitive_scheduler.png" width="500" /></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">Go‚Äôs primitive scheduler</td>
    </tr>
  </tbody>
</table>

<p>Nowadays, Go is famous for its performant concurrency model. 
But that‚Äôs not the case for the early Go.
Dmitry Vyukov‚Äîa Go contributor‚Äîpointed out multiple issues with this implementation in his famous <a href="https://docs.google.com/document/d/1TTj4T2JO42uD5ID9e89oa0sLKhJYD0Y_kqxDv3I3XMw">Scalable Go Scheduler Design</a>: ‚ÄúIn general, the scheduler may inhibit users from using idiomatic fine-grained concurrency where performance is critical.‚Äù
Let me explain in more detail what he meant.</p>

<p>Firstly, the global run queue was a bottleneck for performance.
When a goroutine was created, threads had to acquire a lock to put it into the global run queue.
Similarly, when threads wanted to pick up a goroutine from the global run queue, they also had to acquire the lock.
You may know that locking is not free, it does have overhead with lock contention.
Lock contention leads to performance degradation, especially in high-concurrency scenarios.</p>

<p>Secondly, threads frequently handoff its associated goroutine to another thread.
This cause poor locality and excessive context switch overhead.
Child goroutine usually wants to communicate with its parent goroutine.
Therefore, making child goroutine run on the same thread as its parent goroutine is more performant.</p>

<p>Thirdly, as Go‚Äôs been using <a href="https://google.github.io/tcmalloc/design.html">Thread-caching Malloc</a>, every thread <code class="language-plaintext highlighter-rouge">M</code> has a thread-local cache <code class="language-plaintext highlighter-rouge">mcache</code> so that it can use for allocation or to hold free memory.
While <code class="language-plaintext highlighter-rouge">mcache</code> is only used by <code class="language-plaintext highlighter-rouge">M</code>s executing Go code, it is even attached with <code class="language-plaintext highlighter-rouge">M</code>s blocking in a system call, which don‚Äôt use <code class="language-plaintext highlighter-rouge">mcache</code> at all.
An <code class="language-plaintext highlighter-rouge">mcache</code> can take up to 2MB of memory, and it is not freed until thread <code class="language-plaintext highlighter-rouge">M</code> is destroyed.
Because the ratio between <code class="language-plaintext highlighter-rouge">M</code>s running Go code and all <code class="language-plaintext highlighter-rouge">M</code>s can be as high as 1:100 (too many threads are blocking in system call), this could lead to excessive resource consumption and poor data locality.</p>

<h2 id="scheduler-enhancement">Scheduler Enhancement</h2>

<p>Now that you have a understanding of the issues with early Go scheduler, let‚Äôs examine some of the enhancement proposals to see how Go team addressed these issues so that we have a performant scheduler today.</p>

<h3 id="proposal-1-introduction-of-local-run-queue">Proposal 1: Introduction of Local Run Queue</h3>

<p>Each thread <code class="language-plaintext highlighter-rouge">M</code> is equipped with a local run queue to store runnable goroutines.
When a running goroutine <code class="language-plaintext highlighter-rouge">G</code> on thread <code class="language-plaintext highlighter-rouge">M</code> spawns a new goroutine <code class="language-plaintext highlighter-rouge">G1</code> using the <code class="language-plaintext highlighter-rouge">go</code> keyword, <code class="language-plaintext highlighter-rouge">G1</code> is added to <code class="language-plaintext highlighter-rouge">M</code>‚Äôs local run queue.
If the local queue is full, <code class="language-plaintext highlighter-rouge">G1</code> is instead placed in the global run queue.
When selecting a goroutine to execute, <code class="language-plaintext highlighter-rouge">M</code> first checks its local run queue before consulting the global run queue.
Thus, this proposal addresses the first and second issues as described in the last section.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center"><img src="/assets/2025-03-11-go-scheduling/proposal_1.png" width="500" /></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">Proposal 1 for scheduler enhancement</td>
    </tr>
  </tbody>
</table>

<p>However, it can‚Äôt resolve the third issue.
When many threads <code class="language-plaintext highlighter-rouge">M</code> are blocked in system calls, their <code class="language-plaintext highlighter-rouge">mcache</code> stays attached, causing high memory usage by the Go scheduler itself, not to mention the memory usage of the program that we‚ÄîGo programmers‚Äîwrite.</p>

<p>It also introduces another performance problem.
In order to avoid starving goroutines in a blocked <code class="language-plaintext highlighter-rouge">M</code>‚Äôs local run queue like <code class="language-plaintext highlighter-rouge">M1</code> in the figure above, the scheduler should allow other threads to <em>steal</em> goroutine from it.
However, with a large number of blocked threads, scanning all of them to find a non-empty run queue becomes expensive.</p>

<h3 id="proposal-2-introduction-of-logical-processor">Proposal 2: Introduction of Logical Processor</h3>

<p>This proposal is described in <a href="https://docs.google.com/document/d/1TTj4T2JO42uD5ID9e89oa0sLKhJYD0Y_kqxDv3I3XMw">Scalable Go Scheduler Design</a>, where the notion of <em>logical</em> processor <code class="language-plaintext highlighter-rouge">P</code> is introduced.
By <em>logical</em>, it means that <code class="language-plaintext highlighter-rouge">P</code> pretends to execute goroutine code, but in practice, it is thread <code class="language-plaintext highlighter-rouge">M</code> associated with <code class="language-plaintext highlighter-rouge">P</code> that actually performs the execution.
Thread‚Äôs local run queue and <code class="language-plaintext highlighter-rouge">mcache</code> are now owned by <code class="language-plaintext highlighter-rouge">P</code>.</p>

<p>This proposal effectively addresses open issues in the last section.
As <code class="language-plaintext highlighter-rouge">mcache</code> is now attached to <code class="language-plaintext highlighter-rouge">P</code> instead of <code class="language-plaintext highlighter-rouge">M</code> and <code class="language-plaintext highlighter-rouge">M</code> is detached from <code class="language-plaintext highlighter-rouge">P</code> when <code class="language-plaintext highlighter-rouge">G</code> makes system call, the memory consumption stays low when there are a large number of <code class="language-plaintext highlighter-rouge">M</code>s entering system calls.
Also, as the number of <code class="language-plaintext highlighter-rouge">P</code> is limited, the <em>stealing</em> mechanism is efficient.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center"><img src="/assets/2025-03-11-go-scheduling/proposal_2.png" width="500" /></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">Proposal 2 for scheduler enhancement</td>
    </tr>
  </tbody>
</table>

<p>With the introduction of logical processors, the multithreading model remains M:N.
But in Go, it is specifically referred to as the GMP model as there are three kinds of entities: goroutine, thread and processor.</p>

<h2 id="gmp-model">GMP Model</h2>

<h3 id="goroutine-g">Goroutine: <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/runtime2.go#L396-L508"><code class="language-plaintext highlighter-rouge">g</code></a></h3>

<p>When the <code class="language-plaintext highlighter-rouge">go</code> keyword is followed by a function call, a new instance of <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/runtime2.go#L396-L508"><code class="language-plaintext highlighter-rouge">g</code></a>, referred to as <code class="language-plaintext highlighter-rouge">G</code>, is created.
<code class="language-plaintext highlighter-rouge">G</code> is an object that represents a goroutine, containing metadata such as its execution state, stack, and a program counter pointing to the associated function.
Executing a goroutine simply means running the function that <code class="language-plaintext highlighter-rouge">G</code> references.</p>

<p>When a goroutine finishes execution, it isn‚Äôt destroyed; instead, it becomes <em>dead</em> and is placed into the free list of the current processor <code class="language-plaintext highlighter-rouge">P</code> .
If <code class="language-plaintext highlighter-rouge">P</code>‚Äôs free list is full, the dead goroutine is moved to the global free list.
When a new goroutine is created, the scheduler first attempts to reuse one from the free list before allocating a new one from scratch.
This recycling mechanism makes goroutine creation significantly cheaper than creating a new thread.</p>

<p>The figure and table below described the state machine of goroutines in the GMP model.
Some states and transitions are omitted for simplicity.
The actions that trigger state transitions will be described along the post.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">State</th>
      <th>¬†¬†¬† Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center"><a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/runtime2.go#L36-L39">Idle</a></td>
      <td>Has just been created, and not yet initialized</td>
    </tr>
    <tr>
      <td style="text-align: center"><a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/runtime2.go#L40-L42">Runnable</a></td>
      <td>Currently in run queue, and about to execute code</td>
    </tr>
    <tr>
      <td style="text-align: center"><a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/runtime2.go#L44-L47">Running</a></td>
      <td>Not in a run queue, and executing code</td>
    </tr>
    <tr>
      <td style="text-align: center"><a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/runtime2.go#L49-L52">Syscall</a></td>
      <td>Executing system call, and not executing code</td>
    </tr>
    <tr>
      <td style="text-align: center"><a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/runtime2.go#L54-L62">Waiting</a></td>
      <td>Not executing code, and not in a run queue, e.g. waiting for channel</td>
    </tr>
    <tr>
      <td style="text-align: center"><a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/runtime2.go#L68-L74">Dead</a></td>
      <td>Currently in a free list, just exited, or just  beiging initialized</td>
    </tr>
  </tbody>
</table>

<table>
  <thead>
    <tr>
      <th style="text-align: center"><img src="/assets/2025-03-11-go-scheduling/goroutine_state_machine.png" width="400" /></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">State machine of goroutines in GMP model</td>
    </tr>
  </tbody>
</table>

<h3 id="thread-m">Thread: <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/runtime2.go#L528-L630"><code class="language-plaintext highlighter-rouge">m</code></a></h3>

<p>All Go code‚Äîwhether it‚Äôs user code, the scheduler, or the garbage collector‚Äîruns on threads that are managed by the operating system kernel.
In order for the Go scheduler to make threads work well in GMP model, <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/runtime2.go#L528-L630"><code class="language-plaintext highlighter-rouge">m</code></a> struct representing threads is introduced, and an instance of <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/runtime2.go#L528-L630"><code class="language-plaintext highlighter-rouge">m</code></a> is called <code class="language-plaintext highlighter-rouge">M</code>.</p>

<p><code class="language-plaintext highlighter-rouge">M</code> maintains reference to the current goroutine <code class="language-plaintext highlighter-rouge">G</code>, the current processor <code class="language-plaintext highlighter-rouge">P</code> if <code class="language-plaintext highlighter-rouge">M</code> is executing Go code, the previous processor <code class="language-plaintext highlighter-rouge">P</code> if <code class="language-plaintext highlighter-rouge">M</code> is executing system call, and the next processor <code class="language-plaintext highlighter-rouge">P</code> if <code class="language-plaintext highlighter-rouge">M</code> is about to be created.</p>

<p>Each <code class="language-plaintext highlighter-rouge">M</code> also holds reference to a special goroutine called <code class="language-plaintext highlighter-rouge">g0</code>, which runs on the system stack‚Äîthe stack provided by the kernel to the thread.
Unlike the system stack, a regular goroutine‚Äôs stack is dynamically sized; it grows and shrinks as needed.
However, the operations for growing or shrinking a stack must themselves run on a valid stack. For this, the system stack is used.
When the scheduler‚Äîrunning on an <code class="language-plaintext highlighter-rouge">M</code>‚Äîneeds to perform stack management, it switches from the goroutine‚Äôs stack to the system stack.
In addition to stack growth and shrinkage, operations like garbage collection and <a href="#goroutine-parking-gopark">parking a goroutine</a> also require execution on the system stack.
Whenever a thread performs such operation, it switches to the system stack and executes the operation in the context of <code class="language-plaintext highlighter-rouge">g0</code>.</p>

<p>Unlike goroutine, threads run scheduler code as soon as <code class="language-plaintext highlighter-rouge">M</code> is created, therefore the initial state of <code class="language-plaintext highlighter-rouge">M</code> is <em>running</em>.
When <code class="language-plaintext highlighter-rouge">M</code> is created or woken up, the scheduler guarantees that there is always an <em>idle</em> processor <code class="language-plaintext highlighter-rouge">P</code> so that it can be associated with <code class="language-plaintext highlighter-rouge">M</code> to run Go code.
If <code class="language-plaintext highlighter-rouge">M</code> is executing system call, it will be detached from <code class="language-plaintext highlighter-rouge">P</code> (will be described in <a href="#handling-system-calls">Handling System Calls</a> section) and <code class="language-plaintext highlighter-rouge">P</code> might be acquired by another thread <code class="language-plaintext highlighter-rouge">M1</code> to continues its work.
If <code class="language-plaintext highlighter-rouge">M</code> can‚Äôt find a runnable goroutine from its local run queue, the global run queue, or <code class="language-plaintext highlighter-rouge">netpoll</code> (will be described in <a href="#how-netpoll-works">How netpoll Works</a> section), it keeps spinning to steal goroutines from other processors <code class="language-plaintext highlighter-rouge">P</code> and from the global run queue again.
Note that not all <code class="language-plaintext highlighter-rouge">M</code> enters spinning state, it does so only if the number of spinning threads is less than half of the number of busy processors.
When <code class="language-plaintext highlighter-rouge">M</code> has nothing to do, rather than being destroyed, it goes to sleep and waits to be acquired by a another processor <code class="language-plaintext highlighter-rouge">P1</code> later (described in <a href="#finding-a-runnable-goroutine">Finding a Runnable Goroutine</a>).</p>

<p>The figure and table below described the state machine of threads in the GMP model.
Some states and transitions are omitted for simplicity.
<em>Spinning</em> is a substate of <em>running</em>, in which thread consumes CPU cycles to solely execute Go runtime code that steals goroutine.
The actions that trigger state transitions will be described along the post.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">State</th>
      <th>¬†¬†¬† Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">Running</td>
      <td>Executing Go runtime code, or user Go code</td>
    </tr>
    <tr>
      <td style="text-align: center">Syscall</td>
      <td>Currently executing (blocking in) a system call</td>
    </tr>
    <tr>
      <td style="text-align: center">Spinning</td>
      <td>Stealing goroutine from other processors</td>
    </tr>
    <tr>
      <td style="text-align: center">Sleep</td>
      <td>Sleeping, not consuming CPU cycle</td>
    </tr>
  </tbody>
</table>

<table>
  <thead>
    <tr>
      <th style="text-align: center"><img src="/assets/2025-03-11-go-scheduling/thread_state_machine.png" width="500" /></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">State machine of threads in GMP model</td>
    </tr>
  </tbody>
</table>

<h3 id="processor-p">Processor: <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/runtime2.go#L632-L757"><code class="language-plaintext highlighter-rouge">p</code></a></h3>

<p><a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/runtime2.go#L632-L757"><code class="language-plaintext highlighter-rouge">p</code></a> struct conceptually represents a physical processor to execute goroutines.
Instances of <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/runtime2.go#L632-L757"><code class="language-plaintext highlighter-rouge">p</code></a> are called <code class="language-plaintext highlighter-rouge">P</code>, and they are created during the program‚Äôs bootstrap phase.
While the number of threads created could be large (<a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/proc.go#L827-L827">10000</a> in Go 1.24), the number of processors is usually small and determined by the <a href="https://pkg.go.dev/runtime#GOMAXPROCS"><code class="language-plaintext highlighter-rouge">GOMAXPROCS</code></a>.
There are exactly <a href="https://pkg.go.dev/runtime#GOMAXPROCS"><code class="language-plaintext highlighter-rouge">GOMAXPROCS</code></a> processors, regardless of its state.</p>

<p>To minimize lock contention on the global run queue, each processor <code class="language-plaintext highlighter-rouge">P</code> in the Go runtime maintains a local run queue.
A local run queue is not just a queue but composed of two components: <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/runtime2.go#L655-L667"><code class="language-plaintext highlighter-rouge">runnext</code></a> which holds a single prioritized goroutine, and <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/runtime2.go#L654-L654"><code class="language-plaintext highlighter-rouge">runq</code></a> which is a queue of goroutines.
Both of these components serve as a source of runnable goroutines for <code class="language-plaintext highlighter-rouge">P</code>, but <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/runtime2.go#L655-L667"><code class="language-plaintext highlighter-rouge">runnext</code></a> exists specifically as a performance optimization.
The Go scheduler allows <code class="language-plaintext highlighter-rouge">P</code> to steal goroutines from other processors <code class="language-plaintext highlighter-rouge">P1</code>‚Äôs local run queue.
<code class="language-plaintext highlighter-rouge">P1</code>‚Äôs <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/runtime2.go#L655-L667"><code class="language-plaintext highlighter-rouge">runnext</code></a> in only consulted if the first three attempts stealing from its <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/runtime2.go#L654-L654"><code class="language-plaintext highlighter-rouge">runq</code></a> is unsuccessful.
Therefore, when <code class="language-plaintext highlighter-rouge">P</code> wants to execute a goroutine, there is less lock contention if it looks for a runnable goroutine from its <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/runtime2.go#L655-L667"><code class="language-plaintext highlighter-rouge">runnext</code></a> first.</p>

<p>The <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/runtime2.go#L654-L654"><code class="language-plaintext highlighter-rouge">runq</code></a> component of <code class="language-plaintext highlighter-rouge">P</code> is an array-based, fixed-size, and circular queue.
By array-based and fixed-size with 256 slots, it allows better cache locality and reduces memory allocation overhead.
Fixed-size is safe for <code class="language-plaintext highlighter-rouge">P</code>‚Äôs local run queues as we also have the global run queue as a backup.
By circular, it allows efficiently adding and removing goroutines without needing to shift elements around.</p>

<p>Each <code class="language-plaintext highlighter-rouge">P</code> instance also maintains references to some memory management data structures such as <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/mcache.go#L13-L55"><code class="language-plaintext highlighter-rouge">mcache</code></a> and <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/mpagecache.go#L14-L22"><code class="language-plaintext highlighter-rouge">pageCache</code></a>.
<a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/mcache.go#L13-L55"><code class="language-plaintext highlighter-rouge">mcache</code></a> serves as the front-end in <a href="https://google.github.io/tcmalloc/design.html">Thread-Caching Malloc</a> model and is used by <code class="language-plaintext highlighter-rouge">P</code> to allocate micro and small objects.
<a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/mpagecache.go#L14-L22"><code class="language-plaintext highlighter-rouge">pageCache</code></a>, on the other hand, enables the memory allocator to fetch memory pages without acquiring the <a href="https://www.ibm.com/docs/en/sdk-java-technology/8?topic=management-heap-allocation#the-allocator">heap lock</a>, thereby improving performance under high concurrency.</p>

<p>In order for a Go program to work well with <a href="https://pkg.go.dev/time#Sleep">sleeps</a>, <a href="https://pkg.go.dev/time#After">timeouts</a> or <a href="https://pkg.go.dev/time#Tick">intervals</a>, <code class="language-plaintext highlighter-rouge">P</code> also manages timers implemented by <a href="https://en.wikipedia.org/wiki/Heap_(data_structure)">min-heap</a> data structure.
When looking for a runnable goroutine, <code class="language-plaintext highlighter-rouge">P</code> also checks if there are any timers that have expired.
If so, <code class="language-plaintext highlighter-rouge">P</code> adds the corresponding goroutine with timer to <code class="language-plaintext highlighter-rouge">P</code>‚Äôs local run queue, waking up the goroutine.</p>

<p>The figure and table below described the state machine of processors in the GMP model.
Some states and transitions are omitted for simplicity.
The actions that trigger state transitions will be described along the post.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">State</th>
      <th>¬†¬†¬† Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center"><a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/runtime2.go#L113-L120">Idle</a></td>
      <td>Not executing Go runtime code or user Go code</td>
    </tr>
    <tr>
      <td style="text-align: center"><a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/runtime2.go#L122-L129">Running</a></td>
      <td>Associated with a <code class="language-plaintext highlighter-rouge">M</code> that is executing user Go code</td>
    </tr>
    <tr>
      <td style="text-align: center"><a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/runtime2.go#L131-L141">Syscall</a></td>
      <td>Associated with a <code class="language-plaintext highlighter-rouge">M</code> that is executing system call</td>
    </tr>
    <tr>
      <td style="text-align: center"><a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/runtime2.go#L143-L151">GCStop</a></td>
      <td>Associated with a <code class="language-plaintext highlighter-rouge">M</code> that is stopped-the-world for garbage collection</td>
    </tr>
    <tr>
      <td style="text-align: center"><a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/runtime2.go#L153-L157">Dead</a></td>
      <td>No longer in-used, waiting to be reused when <a href="https://pkg.go.dev/runtime#GOMAXPROCS">GOMAXPROCS</a> grows</td>
    </tr>
  </tbody>
</table>

<table>
  <thead>
    <tr>
      <th style="text-align: center"><img src="/assets/2025-03-11-go-scheduling/processor_state_machine.png" width="500" /></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">State machine of processors in GMP model</td>
    </tr>
  </tbody>
</table>

<p>At the early execution of a Go program, there are <a href="https://pkg.go.dev/runtime#GOMAXPROCS"><code class="language-plaintext highlighter-rouge">GOMAXPROCS</code></a> processors <code class="language-plaintext highlighter-rouge">P</code> in the <em>idle</em> state.
When a thread <code class="language-plaintext highlighter-rouge">M</code> acquires a processor to run user Go code, <code class="language-plaintext highlighter-rouge">P</code> transitions to the <em>running</em> state.
If the current goroutine <code class="language-plaintext highlighter-rouge">G</code> makes a system call, <code class="language-plaintext highlighter-rouge">P</code> is detached from <code class="language-plaintext highlighter-rouge">M</code> and enters the <em>syscall</em> state.
During the system call, if <code class="language-plaintext highlighter-rouge">P</code> is seized by <code class="language-plaintext highlighter-rouge">sysmon</code> (see <a href="#non-cooperative-preemption">Non-cooperative Preemption</a>), it first transitions to <em>idle</em>, then is handed off to another thread (<code class="language-plaintext highlighter-rouge">M1</code>) and enters the <em>running</em> state.
Otherwise, once the system call completes, <code class="language-plaintext highlighter-rouge">P</code> is reattached to last <code class="language-plaintext highlighter-rouge">M</code> and resumes the <em>running</em> state (see <a href="#handling-system-calls">Handling system calls</a>).
When a stop-the-world garbage collection occurs, <code class="language-plaintext highlighter-rouge">P</code> transitions to the <em>gcStop</em> state and returns to its previous state once start-the-world resumes.
If <a href="https://pkg.go.dev/runtime#GOMAXPROCS"><code class="language-plaintext highlighter-rouge">GOMAXPROCS</code></a> is decreased at runtime, redundant processors transition to the <em>dead</em> state and are reused if <a href="https://pkg.go.dev/runtime#GOMAXPROCS"><code class="language-plaintext highlighter-rouge">GOMAXPROCS</code></a> increases later.</p>

<h2 id="program-bootstrap">Program Bootstrap</h2>

<p>To enable the Go scheduler, it must be initialized during the program‚Äôs bootstrap.
This initialization is handled in assembly via the <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/asm_amd64.s#L159-L159"><code class="language-plaintext highlighter-rouge">runtime¬∑rt0_go</code></a> function.
During this phase, thread <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/proc.go#L117-L117"><code class="language-plaintext highlighter-rouge">M0</code></a> (representing the main thread) and goroutine <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/proc.go#L118-L118"><code class="language-plaintext highlighter-rouge">G0</code></a> (<a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/proc.go#L117-L117"><code class="language-plaintext highlighter-rouge">M0</code></a>‚Äôs system stack goroutine) are created.
<a href="https://en.wikipedia.org/wiki/Thread-local_storage">Thread-local storage</a> (TLS) for the main thread is also set up, and the address of <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/proc.go#L118-L118"><code class="language-plaintext highlighter-rouge">G0</code></a> is stored in this TLS, allowing it to be retrieved later via <a href="#getting-goroutine-getg"><code class="language-plaintext highlighter-rouge">getg</code></a>.</p>

<p>The bootstrap process then invokes the assembly function <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/asm_amd64.s#L349"><code class="language-plaintext highlighter-rouge">runtime¬∑schedinit</code></a>, whose Go implementation can be found at <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/proc.go#L790-L898"><code class="language-plaintext highlighter-rouge">runtime.schedinit</code></a>.
This function performs various initializations, most notably invoking <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/proc.go#L5719-L5868"><code class="language-plaintext highlighter-rouge">procresize</code></a>, which sets up to <a href="https://pkg.go.dev/runtime#GOMAXPROCS"><code class="language-plaintext highlighter-rouge">GOMAXPROCS</code></a> logical processors <code class="language-plaintext highlighter-rouge">P</code> in <em>idle</em> state.
The main thread <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/proc.go#L117-L117"><code class="language-plaintext highlighter-rouge">M0</code></a> is then associated with the first processors, transitioning its state from <em>idle</em> to <em>running</em> to execute goroutines.</p>

<p>Afterward, the main goroutine is created to run <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/proc.go#L146-L148"><code class="language-plaintext highlighter-rouge">runtime.main</code></a> function, which serves as the Go runtime entry point.
Within the <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/proc.go#L146-L148"><code class="language-plaintext highlighter-rouge">runtime.main</code></a> function, a dedicated thread is created to launch <code class="language-plaintext highlighter-rouge">sysmon</code>, which will be described in <a href="#non-cooperative-preemption">Non-cooperative Preemption</a> section.
Note that <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/proc.go#L146-L148"><code class="language-plaintext highlighter-rouge">runtime.main</code></a> is different from the <code class="language-plaintext highlighter-rouge">main</code> function that we write; the latter appears in the runtime as <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/proc.go#L134-L135"><code class="language-plaintext highlighter-rouge">main_main</code></a>.</p>

<p>The main thread then calls <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/proc.go#L1769-L1769"><code class="language-plaintext highlighter-rouge">mstart</code></a> to begin execution on <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/proc.go#L117-L117"><code class="language-plaintext highlighter-rouge">M0</code></a>, starting the <a href="#schedule-loop">schedule loop</a> to pick up and execute the main goroutine.
In the <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/proc.go#L146-L148"><code class="language-plaintext highlighter-rouge">runtime.main</code></a>, after additional initialization steps, control is finally handed off to the user-defined <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/proc.go#L134-L135"><code class="language-plaintext highlighter-rouge">main_main</code></a> function, where the program begins executing user Go code.</p>

<p>It‚Äôs worth noting that the main thread, <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/proc.go#L117-L117"><code class="language-plaintext highlighter-rouge">M0</code></a>, is responsible not only for running the main goroutine but also for executing other goroutines.
Whenever the main goroutine is blocked‚Äîsuch as waiting for a system call or while waiting on a channel‚Äîthe main thread looks for another runnable goroutine and execute it.</p>

<p>Summing it up, when the program starts, there is one goroutine <code class="language-plaintext highlighter-rouge">G</code> executing the <code class="language-plaintext highlighter-rouge">main</code> function; two threads‚Äîone is the main thread <code class="language-plaintext highlighter-rouge">M0</code>, and the other is created to launch <code class="language-plaintext highlighter-rouge">sysmon</code>; one processor <code class="language-plaintext highlighter-rouge">P0</code> in <em>running</em> state, and <code class="language-plaintext highlighter-rouge">GOMAXPROCS‚àí1</code> processors in <em>idle</em> state.
The main thread <code class="language-plaintext highlighter-rouge">M0</code> is initially associated with processor <code class="language-plaintext highlighter-rouge">P0</code> to run the main goroutine <code class="language-plaintext highlighter-rouge">G</code>.</p>

<p>The figure below illustrates the program‚Äôs state at startup.
It assumes that <a href="https://pkg.go.dev/runtime#GOMAXPROCS"><code class="language-plaintext highlighter-rouge">GOMAXPROCS</code></a> is set to 2 and that the <code class="language-plaintext highlighter-rouge">main</code> function has just started.
Processor <code class="language-plaintext highlighter-rouge">P0</code> is executing the main goroutine and is therefore in <em>running</em> state.
Processor <code class="language-plaintext highlighter-rouge">P1</code> is not executing any goroutine and is in <em>idle</em> state.
While the main thread <code class="language-plaintext highlighter-rouge">M0</code> is associated with processor <code class="language-plaintext highlighter-rouge">P0</code> to execute main goroutine, another thread <code class="language-plaintext highlighter-rouge">M1</code> is created to run <code class="language-plaintext highlighter-rouge">sysmon</code>.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center"><img src="/assets/2025-03-11-go-scheduling/program_bootstrap.png" width="500" /></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">Program bootstrap in GMP model</td>
    </tr>
  </tbody>
</table>

<h2 id="creating-goroutine">Creating Goroutine</h2>

<p>Go offers us a simple API to start a concurrent execution unit: <code class="language-plaintext highlighter-rouge">go func() { ... } ()</code>.
Under the hood, Go runtime does a lot complicated work to make it happen.
The <code class="language-plaintext highlighter-rouge">go</code> keyword is just a syntactic sugar for Go runtime <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/proc.go#L5014-L5030"><code class="language-plaintext highlighter-rouge">newproc</code></a> function, which is responsible for scheduling a new goroutine.
This function essentially does 3 things: initialize the goroutine, put it into the run queue of the processor <code class="language-plaintext highlighter-rouge">P</code> which the caller goroutine is running on, wake up another processor <code class="language-plaintext highlighter-rouge">P1</code>.</p>

<h3 id="initializing-goroutine">Initializing Goroutine</h3>

<p>When <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/proc.go#L5014-L5030"><code class="language-plaintext highlighter-rouge">newproc</code></a> is called, it creates a new goroutine <code class="language-plaintext highlighter-rouge">G</code> only if there are no idle goroutines available.
Goroutines become idle after they return from execution.
The newly created goroutine <code class="language-plaintext highlighter-rouge">G</code> is initialized with a 2KB stack, as defined by the <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/stack.go#L75-L75"><code class="language-plaintext highlighter-rouge">stackMin</code></a> constant in Go runtime.
Additionally, <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/stubs.go#L281-L291"><code class="language-plaintext highlighter-rouge">goexit</code></a>‚Äîwhich handles cleanup logic and scheduling logic‚Äîis pushed onto <code class="language-plaintext highlighter-rouge">G</code>‚Äôs call stack to ensure it is executed when <code class="language-plaintext highlighter-rouge">G</code> returns.
After initialization, <code class="language-plaintext highlighter-rouge">G</code> transitions from <em>dead</em> state to <em>runnable</em> state, indicating that it‚Äôs ready to be scheduled for execution.</p>

<h3 id="putting-goroutine-into-queue">Putting Goroutine into Queue</h3>

<p>As mentioned earlier, each processor <code class="language-plaintext highlighter-rouge">P</code> has a run queue composed of two parts: <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/runtime2.go#L655-L667"><code class="language-plaintext highlighter-rouge">runnext</code></a> and <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/runtime2.go#L654-L654"><code class="language-plaintext highlighter-rouge">runq</code></a>.
When a new goroutine is created, it is placed in <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/runtime2.go#L655-L667"><code class="language-plaintext highlighter-rouge">runnext</code></a>.
If <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/runtime2.go#L655-L667"><code class="language-plaintext highlighter-rouge">runnext</code></a> already contains a goroutine <code class="language-plaintext highlighter-rouge">G1</code>, the scheduler attempts to move <code class="language-plaintext highlighter-rouge">G1</code> to <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/runtime2.go#L654-L654"><code class="language-plaintext highlighter-rouge">runq</code></a>‚Äîprovided <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/runtime2.go#L654-L654"><code class="language-plaintext highlighter-rouge">runq</code></a> is not full‚Äîand put <code class="language-plaintext highlighter-rouge">G</code> into <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/runtime2.go#L655-L667"><code class="language-plaintext highlighter-rouge">runnext</code></a>.
If <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/runtime2.go#L654-L654"><code class="language-plaintext highlighter-rouge">runq</code></a> is full, <code class="language-plaintext highlighter-rouge">G1</code> along with half of the goroutines in <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/runtime2.go#L654-L654"><code class="language-plaintext highlighter-rouge">runq</code></a> are moved to the global run queue to reduce the workload for <code class="language-plaintext highlighter-rouge">P</code>.</p>

<h3 id="waking-up-processor">Waking Up Processor</h3>

<p>When a new goroutine is created, and we aim to maximize program concurrency, the thread which goroutine is running on attempts to wake up another processor <code class="language-plaintext highlighter-rouge">P</code> by <a href="https://man7.org/linux/man-pages/man2/futex.2.html"><code class="language-plaintext highlighter-rouge">futex</code></a> system call. 
To do this, it first checks for any idle processors.
If an idle processor <code class="language-plaintext highlighter-rouge">P</code> is available, a new thread is either created or an existing one is woken up to enter the <a href="#schedule-loop">schedule loop</a>, where it will look for a runnable goroutine to execute.
The logic for creating or reusing thread is described in <a href="#start-thread-startm">Start Thread</a> section.</p>

<p>As previously mentioned, <a href="https://pkg.go.dev/runtime#GOMAXPROCS"><code class="language-plaintext highlighter-rouge">GOMAXPROCS</code></a>‚Äîthe number of active processors <code class="language-plaintext highlighter-rouge">P</code>‚Äîdictates how many goroutines can run concurrently.
If all processors are busy and new goroutines keep spawning, neither existing thread is woken up nor new thread is created.</p>

<h3 id="putting-it-all-together">Putting It All Together</h3>

<p>The figure below illustrates the process of how goroutines are created.
For simplicity, it assumes <a href="https://pkg.go.dev/runtime#GOMAXPROCS"><code class="language-plaintext highlighter-rouge">GOMAXPROCS</code></a> is set to 2, processor <code class="language-plaintext highlighter-rouge">P1</code> hasn‚Äôt entered the <a href="#schedule-loop">schedule loop</a> yet, and <code class="language-plaintext highlighter-rouge">main</code> function does nothing but keeps spawning new goroutines.
Since goroutines don‚Äôt execute system call (discussed in <a href="#handling-system-calls">Handling System Calls</a> section), there is exactly one additional thread <code class="language-plaintext highlighter-rouge">M2</code> is created to associate with processor <code class="language-plaintext highlighter-rouge">P1</code>.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center"><img src="/assets/2025-03-11-go-scheduling/creating_goroutine.png" /></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">How goroutines are created in GMP model</td>
    </tr>
  </tbody>
</table>

<h2 id="schedule-loop">Schedule Loop</h2>

<p>The <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/proc.go#L3986-L4068"><code class="language-plaintext highlighter-rouge">schedule</code></a> function in the Go runtime is responsible for finding and executing a runnable goroutine.
It is invoked in various scenarios: when a new thread is created, when <a href="https://pkg.go.dev/runtime#Gosched"><code class="language-plaintext highlighter-rouge">Gosched</code></a> is called, when a goroutine is parked or preempted, or after a goroutine completes a system call and returns.</p>

<p>The process of selecting a runnable goroutine is complex and will be detailed in the <a href="#finding-a-runnable-goroutine">Finding a Runnable Goroutine</a> section.
Once a goroutine is selected, it transitions from <em>runnable</em> to <em>running</em> state, signaling that it‚Äôs ready to run.
At this point, a kernel thread invokes the <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/stubs.go#L214-L214"><code class="language-plaintext highlighter-rouge">gogo</code></a> function to begin goroutine execution.</p>

<p>But why is it called a <em>loop</em>? As described in the <a href="#initializing-goroutine">Initializing Goroutine</a> section, when a goroutine completes, the <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/stubs.go#L281-L291"><code class="language-plaintext highlighter-rouge">goexit</code></a> function is invoked.
This function eventually leads to a call to <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/proc.go#L4307-L4310"><code class="language-plaintext highlighter-rouge">goexit0</code></a>, which performs cleanup for the terminating goroutine and re-enters the <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/proc.go#L3986-L4068"><code class="language-plaintext highlighter-rouge">schedule</code></a> function‚Äîbringing the <a href="#schedule-loop">schedule loop</a> back.</p>

<p>The following diagram illustrates the schedule loop in Go runtime, where <span style="color:#c71585">pink</span> blocks happen in user Go code and <span style="color:#ffd700">yellow</span> blocks happen in the Go runtime code.
Although the following may seem obvious, please note that the schedule loop is executed by thread.
That‚Äôs why it happens after thread initialization (the <span style="color:#0056b3">blue</span> block).</p>

<table>
    <thead>
        <tr>
            <td>
                <pre class="mermaid" style="margin: unset">

graph LR
    subgraph Thread_Init[&amp;nbsp]
    newm["newm()"] ==&gt; mstart["mstart()"]
    mstart ==&gt; mstart0["mstart0()"]
    mstart0 ==&gt; mstart1["mstart1()"]
    end
    mstart1 ==&gt; schedule["schedule()"]
    schedule ==&gt; findrunnable["findrunnable()<br />Find a runnable goroutine"]
    findrunnable ==&gt; execute["execute()"]
    execute ==&gt; gogo["gogo()<br />Execute a goroutine"]
    gogo ==&gt; |Goroutine executes code and returns|goexit["goexit()"]
    gogo ==&gt; |Goroutine executes<br />system call|entersyscall["entersyscall()"]
    entersyscall ==&gt; exitsyscall["exitsyscall()"]
    exitsyscall ==&gt; schedule
    goexit ==&gt; goexit1["goexit1()"]
    goexit1 ==&gt; goexit0["goexit0()"]
    goexit0 ==&gt; schedule
    style Thread_Init fill:#bfdfff

                </pre>
            </td>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td style="text-align: center">
                The schedule loop in Go runtime
            </td>
        </tr>
    </tbody>
</table>

<p>But if the main thread is stuck in schedule loop, how can the process exit?
Just take a look at the <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/proc.go#L307-L307"><code class="language-plaintext highlighter-rouge">main</code></a> function in Go runtime, which is executed by main goroutine.
After <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/proc.go#L134-L135"><code class="language-plaintext highlighter-rouge">main_main</code></a>‚Äîalias of the <code class="language-plaintext highlighter-rouge">main</code> function that Go programmers write‚Äîreturns, <a href="https://man7.org/linux/man-pages/man3/exit.3.html"><code class="language-plaintext highlighter-rouge">exit</code></a> system call is invoked to terminate the process.
That‚Äôs how the process can exit and the reason why the main goroutine doesn‚Äôt wait for goroutines spawned by <code class="language-plaintext highlighter-rouge">go</code> keyword.</p>

<h2 id="finding-a-runnable-goroutine">Finding a Runnable Goroutine</h2>

<p>It is the thread <code class="language-plaintext highlighter-rouge">M</code>‚Äôs responsibility to find a suitable runnable goroutine so that goroutine starvation can be minimized.
This logic is implemented in the <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/proc.go#L3267-L3646"><code class="language-plaintext highlighter-rouge">findRunnable</code></a>, which is called by the <a href="#schedule-loop">schedule loop</a>.</p>

<p>Thread <code class="language-plaintext highlighter-rouge">M</code> looks for a runnable goroutine the following order, stopping the chain if it finds one:</p>
<ol>
  <li>Check <a href="https://go.dev/blog/execution-traces-2024#trace-reader-api">trace reader</a> goroutine‚Äôs availability (used in <a href="#non-cooperative-preemption">Non-cooperative Preemption</a> section).</li>
  <li>Check garbage collection worker goroutine‚Äôs availability (described in <a href="#garbage-collector">Garbage Collector</a> section).</li>
  <li>1/61 of the time, check the global run queue.</li>
  <li>Check local run queue of the associated processor <code class="language-plaintext highlighter-rouge">P</code> if <code class="language-plaintext highlighter-rouge">M</code> is spinning.</li>
  <li>Check the global run queue again.</li>
  <li>Check netpoll for I/O ready goroutine (described in <a href="#how-netpoll-works">How netpoll Works</a> section).</li>
  <li>Steal from other processors <code class="language-plaintext highlighter-rouge">P1</code>‚Äôs local run queue.</li>
  <li>Check garbage collection worker goroutine‚Äôs availability again.</li>
  <li>Check the global run queue again if <code class="language-plaintext highlighter-rouge">M</code> is spinning.</li>
</ol>

<p>Step 1, 2 and 8 are for Go runtime internal use only.
In step 1, trace reader is used for tracing the execution of the program.
You will see how it‚Äôs used in the <a href="#goroutine-preemption">Goroutine Preemption</a> section later.
Meanwhile, step 2 and 8 allow the garbage collector to run concurrently with the regular goroutines.
Although these steps don‚Äôt contribute to ‚Äúuser-visible‚Äù progress, they are essential for the Go runtime to function properly.</p>

<p>Step 3, 5 and 9 don‚Äôt just take one goroutine but attempts to grab a batch for better efficiency.
The batch size is calculated as <code class="language-plaintext highlighter-rouge">(global_queue_size/number_of_processors)+1</code>, but it‚Äôs limited by several factors: it won‚Äôt exceed the specified maximum parameter, and won‚Äôt take more than half of the P‚Äôs local queue capacity.
After determining how many to take, it pops one goroutine to return directly (which will be run immediately) and puts the rest into the P‚Äôs local run queue.
This batching approach helps with load balancing across processors and reduces contention on the global queue lock, as processors don‚Äôt need to access the global queue as frequently.</p>

<p>Step 4 is a bit more tricky because the local run queue of <code class="language-plaintext highlighter-rouge">P</code> contains two parts: <code class="language-plaintext highlighter-rouge">runnext</code> and <code class="language-plaintext highlighter-rouge">runq</code>.
If <code class="language-plaintext highlighter-rouge">runnext</code> is not empty, it returns the goroutine in <code class="language-plaintext highlighter-rouge">runnext</code>.
Otherwise, it checks <code class="language-plaintext highlighter-rouge">runq</code> for any runnable goroutine and dequeue it.
Step 6 will be described in detail in <a href="#how-netpoll-works">How netpoll Works</a> section.</p>

<p>Step 7 is the most complex part of the process.
It attempts up to four times to steal work from another processor, referred to as <code class="language-plaintext highlighter-rouge">P1</code>.
During the first three attempts, it tries to steal goroutines only from <code class="language-plaintext highlighter-rouge">P1</code>‚Äôs <code class="language-plaintext highlighter-rouge">runq</code>. 
If successful, half of the goroutines from <code class="language-plaintext highlighter-rouge">P1</code>‚Äôs <code class="language-plaintext highlighter-rouge">runq</code> are transferred to the current processor <code class="language-plaintext highlighter-rouge">P</code>‚Äôs <code class="language-plaintext highlighter-rouge">runq</code>.
On the last attempt, it first tries to steal from <code class="language-plaintext highlighter-rouge">P1</code>‚Äôs <code class="language-plaintext highlighter-rouge">runnext</code> slot‚Äîif available‚Äîbefore falling back to <code class="language-plaintext highlighter-rouge">P1</code>‚Äôs <code class="language-plaintext highlighter-rouge">runq</code>.</p>

<p>Note that <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/proc.go#L3267-L3646"><code class="language-plaintext highlighter-rouge">findRunnable</code></a> not only finds a runnable goroutine but also wakes up goroutine that went into sleep before step 1 happens.
Once the goroutine wakes up, it‚Äôll be put into the local run queue of the processor <code class="language-plaintext highlighter-rouge">P</code> that was executing it, waiting to be picked up and executed by some thread <code class="language-plaintext highlighter-rouge">M</code>.</p>

<p>If no goroutine is found after step 9, thread <code class="language-plaintext highlighter-rouge">M</code> waits on <code class="language-plaintext highlighter-rouge">netpoll</code> until the nearest <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/time.go#L35-L107">timer</a> expires‚Äîsuch as when a goroutine wakes up from sleep (since sleeping in Go internally creates a timer).
Why is <code class="language-plaintext highlighter-rouge">netpoll</code> involved with timers? This is because Go‚Äôs timer system heavily relies on <code class="language-plaintext highlighter-rouge">netpoll</code>, as noted in <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/time.go#L427-L427">this</a> code comment.
After <code class="language-plaintext highlighter-rouge">netpoll</code> returns, <code class="language-plaintext highlighter-rouge">M</code> re-enters the <a href="#schedule-loop">schedule loop</a> to search for a runnable goroutine again.</p>

<p>The previous two behaviors of <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/proc.go#L3267-L3646"><code class="language-plaintext highlighter-rouge">findRunnable</code></a> allows the Go scheduler to wake up asleep goroutines, allowing the program to continue executing.
They explain why every goroutine including the main one has chance to run after falling asleep.
Let‚Äôs see how the following Go program works in another post üòÑ.</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="s">"time"</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">go</span> <span class="k">func</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">time</span><span class="o">.</span><span class="n">Sleep</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">Second</span><span class="p">)</span>
    <span class="p">}()</span>
	
    <span class="n">time</span><span class="o">.</span><span class="n">Sleep</span><span class="p">(</span><span class="m">2</span><span class="o">*</span><span class="n">time</span><span class="o">.</span><span class="n">Second</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>If <code class="language-plaintext highlighter-rouge">P</code> has no <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/time.go#L35-L107">timer</a>, its corresponding thread <code class="language-plaintext highlighter-rouge">M</code> will go idle.
<code class="language-plaintext highlighter-rouge">P</code> is placed into idle list, <code class="language-plaintext highlighter-rouge">M</code> goes to sleep by calling the <a href="#stop-thread-stopm"><code class="language-plaintext highlighter-rouge">stopm</code></a> function.
It remains asleep until another <code class="language-plaintext highlighter-rouge">M1</code> thread  wakes it up, typically upon the creation of a new goroutine, as explained in <a href="#waking-up-processor">Waking Up Processor</a>.
Once awakened, <code class="language-plaintext highlighter-rouge">M</code> reenters the <a href="#schedule-loop">schedule loop</a> to search for and execute a runnable goroutine.</p>

<h2 id="goroutine-preemption">Goroutine Preemption</h2>

<p>Preemption is the act of temporarily interrupting a goroutine execution to allow other goroutines to run, preventing goroutine starvation.
There are two types of preemption in Go:</p>

<ul>
  <li>Non-cooperative preemption: a too long-running goroutine is forced to stop.</li>
  <li>Cooperative preemption: a goroutine voluntarily yields its processor <code class="language-plaintext highlighter-rouge">P</code>.</li>
</ul>

<p>Let‚Äôs see how these two types of preemption work in Go.</p>

<h3 id="non-cooperative-preemption">Non-cooperative Preemption</h3>

<p>Let‚Äôs take an example to understand how non-cooperative preemption works.
In this program, we have two goroutines that calculate the Fibonacci number, which is a tight loop with CPU intensive operations.
In order to make sure that only one goroutine can run at a time, we set the maximum number of logical processors to 1 using <a href="https://pkg.go.dev/runtime#GOMAXPROCS"><code class="language-plaintext highlighter-rouge">GOMAXPROCS</code></a> when running the program: <code class="language-plaintext highlighter-rouge">GOMAXPROCS=1 go run main.go</code>.</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="p">(</span>
    <span class="s">"runtime"</span>
    <span class="s">"time"</span>
<span class="p">)</span>

<span class="k">func</span> <span class="n">fibonacci</span><span class="p">(</span><span class="n">n</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="m">1</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">n</span>
    <span class="p">}</span>   
    <span class="n">previous</span><span class="p">,</span> <span class="n">current</span> <span class="o">:=</span> <span class="m">0</span><span class="p">,</span> <span class="m">1</span>
    <span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="m">2</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
        <span class="n">previous</span><span class="p">,</span> <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="p">,</span> <span class="n">previous</span><span class="o">+</span><span class="n">current</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">current</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">go</span> <span class="n">fibonacci</span><span class="p">(</span><span class="m">1</span><span class="n">_000_000_000</span><span class="p">)</span>
    <span class="k">go</span> <span class="n">fibonacci</span><span class="p">(</span><span class="m">2</span><span class="n">_000_000_000</span><span class="p">)</span>

    <span class="n">time</span><span class="o">.</span><span class="n">Sleep</span><span class="p">(</span><span class="m">3</span><span class="o">*</span><span class="n">time</span><span class="o">.</span><span class="n">Second</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Because there is exactly one processor <code class="language-plaintext highlighter-rouge">P</code>, there are many cases that could happen. 
One, neither goroutine runs because the main function has taken control of <code class="language-plaintext highlighter-rouge">P</code>.
Two, one goroutine runs while the other is starved of execution.
Three, somehow both goroutines run concurrently‚Äîalmost magically.</p>

<p>Fortunately, Go does support us to get the idea of what is happening with the scheduling.
The <a href="https://go.dev/pkg/runtime/trace">runtime/trace</a> package contains a powerful tool for understanding and troubleshooting Go programs.
To use it, we need to add instrument to the <code class="language-plaintext highlighter-rouge">main</code> method to export the traces to file.</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">file</span><span class="p">,</span> <span class="n">_</span> <span class="o">:=</span> <span class="n">os</span><span class="o">.</span><span class="n">Create</span><span class="p">(</span><span class="s">"trace.out"</span><span class="p">)</span>
    <span class="n">_</span> <span class="o">=</span> <span class="n">trace</span><span class="o">.</span><span class="n">Start</span><span class="p">(</span><span class="n">file</span><span class="p">)</span>
    <span class="k">defer</span> <span class="n">trace</span><span class="o">.</span><span class="n">Stop</span><span class="p">()</span>
    <span class="o">...</span>
<span class="p">}</span>
</code></pre></div></div>

<p>After the program finishes running, we use the command <code class="language-plaintext highlighter-rouge">go tool trace trace.out</code> to visualize the trace.
I have prepared the <code class="language-plaintext highlighter-rouge">trace.out</code> file <a href="/assets/2025-03-11-go-scheduling/non_cooperative_preempt_trace.out">here</a> just in case you want to play with it.
In the figure below, the horizontal axis represents which goroutine is running on <code class="language-plaintext highlighter-rouge">P</code> at a given time.
As expected, there is only one logical processor <code class="language-plaintext highlighter-rouge">P</code> named ‚ÄúProc 0‚Äù, resulted from <code class="language-plaintext highlighter-rouge">GOMAXPROCS=1</code>.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center"><img src="/assets/2025-03-11-go-scheduling/runtime_trace_start.png" /></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">Trace visualization when program starts</td>
    </tr>
  </tbody>
</table>

<p>By zooming in (pressing ‚ÄòW‚Äô) to the start of the timeline, you can see that the process begins with <code class="language-plaintext highlighter-rouge">main.main</code> (the <code class="language-plaintext highlighter-rouge">main</code> function in the <code class="language-plaintext highlighter-rouge">main</code> package), which runs on the main goroutine, G1.
After a few microseconds, still on Proc 0, goroutine G10 is scheduled to execute the <code class="language-plaintext highlighter-rouge">fibonacci</code> function, taking over the processor and preempting G1.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center"><img src="/assets/2025-03-11-go-scheduling/runtime_trace_preempt.png" /></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">Trace visualization when non-cooperative preemption happens</td>
    </tr>
  </tbody>
</table>

<p>By zooming out (pressing ‚ÄòS‚Äô) and scrolling slightly to the right, it can be observed that G10 is later replaced by another goroutine, G9, which is the next instance running the <code class="language-plaintext highlighter-rouge">fibonacci</code> function.
This goroutine is also executed on Proc 0. Pay attention to <code class="language-plaintext highlighter-rouge">runtime.asyncPreempt:47</code> in the figure, I will explain this in a moment.</p>

<p>From the demo, it can be concluded that the Go is capable of preempting goroutines that are CPU-bound.
But why is it possible because if a goroutines continuously taking up the CPU, how can it be preempted?
This is a hard problem and there was a long <a href="https://github.com/golang/go/issues/10958">discussion</a> on the Go issue tracker.
The problem was not addressed until Go 1.14, where asynchronous preemption was firstly introduced.</p>

<p>In Go runtime, there is a daemon running on a dedicated thread <code class="language-plaintext highlighter-rouge">M</code> without a <code class="language-plaintext highlighter-rouge">P</code>, called <code class="language-plaintext highlighter-rouge">sysmon</code> (i.e. system monitor). 
When <code class="language-plaintext highlighter-rouge">sysmon</code> finds a goroutine that has been using <code class="language-plaintext highlighter-rouge">P</code> for more than 10ms (<a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/proc.go#L6245-L6245"><code class="language-plaintext highlighter-rouge">forcePreemptNS</code></a> constant in Go runtime), it signals thread <code class="language-plaintext highlighter-rouge">M</code> by executing <a href="https://man7.org/linux/man-pages/man2/tkill.2.html"><code class="language-plaintext highlighter-rouge">tgkill</code></a> system call to forcefully preempt the running goroutine.
Yes, you didn‚Äôt read that wrong. According to the <a href="https://man7.org/linux/man-pages/man2/tkill.2.html">Linux manual page</a>, <a href="https://man7.org/linux/man-pages/man2/tkill.2.html"><code class="language-plaintext highlighter-rouge">tgkill</code></a> is used to send a signal to a thread, not to kill a thread.
The signal is <code class="language-plaintext highlighter-rouge">SIGURG</code>, and the reason it being chosen is described <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/signal_unix.go#L43-L73">here</a>.</p>

<p>Upon receiving <code class="language-plaintext highlighter-rouge">SIGURG</code>, the execution of the program is transferred to the signal handler, registered by a call of <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/proc.go#L1879-L1879"><code class="language-plaintext highlighter-rouge">initsig</code></a> function upon thread initialization.
Note that the signal handler can run concurrently with goroutine code or the scheduler code, as depicted in the figure below.
The execution switch from main program to signal handler is triggered by the kernel<a href="https://stackoverflow.com/questions/6949025/how-are-asynchronous-signal-handlers-executed-on-linux/"><sup>4,</sup></a><a href="https://unix.stackexchange.com/questions/733013/how-is-a-signal-delivered-in-linux"><sup>5</sup></a>.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center"><img src="/assets/2025-03-11-go-scheduling/signal_delivery_and_handler_execution.png" width="500" /></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">Signal delivery and handler execution<sup><a href="#references">6</a></sup></td>
    </tr>
  </tbody>
</table>

<p>In the signal handler, the program counter is set to the <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/preempt.go#L295-L299"><code class="language-plaintext highlighter-rouge">asyncPreempt</code></a> function, allowing the goroutine to be suspended and creating space for preemption.
In the assembly implementation of <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/preempt_arm64.s"><code class="language-plaintext highlighter-rouge">asyncPreempt</code></a> function, it saves the goroutine‚Äôs registers and call <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/preempt.go#L302-L311"><code class="language-plaintext highlighter-rouge">asyncPreempt2</code></a> function at line <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/preempt_arm64.s#L47">47</a>.
That is reason for the appearance of <code class="language-plaintext highlighter-rouge">runtime.asyncPreempt:47</code> in the visualization.
In <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/preempt.go#L302-L311"><code class="language-plaintext highlighter-rouge">asyncPreempt2</code></a>, the goroutine <code class="language-plaintext highlighter-rouge">g0</code> of thread <code class="language-plaintext highlighter-rouge">M</code> will enter <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/proc.go#L4191-L4193"><code class="language-plaintext highlighter-rouge">gopreempt_m</code></a> to disassociate goroutine <code class="language-plaintext highlighter-rouge">G</code> from <code class="language-plaintext highlighter-rouge">M</code> and enqueue <code class="language-plaintext highlighter-rouge">G</code> into the global run queue.
The thread then continues with the <a href="#schedule-loop">schedule loop</a>, finding another runnable goroutine and execute it.</p>

<p>As preemption signal is triggered by <code class="language-plaintext highlighter-rouge">sysmon</code> but the actual preemption doesn‚Äôt happen until the thread receives preemption signal, this kind of preemption is asynchronous.
That‚Äôs why goroutines can actually run beyond the time limit 10ms, like goroutine G9 in the example.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center"><img src="/assets/2025-03-11-go-scheduling/non_cooperative_preemption.png" width="600" /></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">Non-cooperative preemption in GMP model</td>
    </tr>
  </tbody>
</table>

<h3 id="cooperative-preemption-in-early-go">Cooperative Preemption in Early Go</h3>

<p>In the early days of Go, Go runtime itself was not able to preempt a goroutines that have tight loop like the example above.
We, as Go programmers, had to tell goroutines to cooperatively give up its processor <code class="language-plaintext highlighter-rouge">P</code> by making a call to <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/proc.go#L358-L365"><code class="language-plaintext highlighter-rouge">runtime.Gosched()</code></a> in the loop body.
There was a Stackoverflow <a href="https://stackoverflow.com/questions/13107958/what-exactly-does-runtime-gosched-do">question</a> that described an example and the behavior of <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/proc.go#L358-L365"><code class="language-plaintext highlighter-rouge">runtime.Gosched()</code></a>.</p>

<p>From the programmer‚Äôs point of view, this is very tedious and error-prone, and it did have some performance <a href="https://github.com/golang/go/issues/12553">issue</a> in actuality.
Therefore, the Go team has decided to implement a clever way to preempt the goroutine by the runtime itself.
This will be discussed in the next section.</p>

<h3 id="cooperative-preemption-since-go-114">Cooperative Preemption Since Go 1.14</h3>

<p>Do you wonder why I didn‚Äôt use <code class="language-plaintext highlighter-rouge">fmt.Printf</code> in each iteration and check the terminal to see whether both goroutines have chance to run?
That‚Äôs because if I had done that, it would have become a cooperative preemption, not a non-cooperative preemption anymore.</p>

<h4 id="disassemble-the-program">Disassemble the Program</h4>
<p>To better understand this, let‚Äôs compile the program and analyze its assembly code.
Since the Go compiler applies various optimizations that can make debugging more challenging, we need to disable them when building the program.
This can be done by <code class="language-plaintext highlighter-rouge">go build -gcflags="all=-N -l" -o fibonacci main.go</code>.</p>

<p>For easier debugging, I use <a href="https://github.com/go-delve/delve">Delve</a>, a powerful debugger for Go, to disassemble the <code class="language-plaintext highlighter-rouge">fibonacci</code> function: <code class="language-plaintext highlighter-rouge">dlv exec ./fibonacci</code>.
Once inside the debugger, I run the following command to view the assembly code of the <code class="language-plaintext highlighter-rouge">fibonacci</code> function: <code class="language-plaintext highlighter-rouge">disassemble -l main.fibonacci</code>.
You can find the assembly code of the original program <a href="/assets/2025-03-11-go-scheduling/non_cooperative_preempt.s">here</a>.
As I‚Äôm building the program on my local machine, which is darwin/arm64, the assembly code built on your machine could be different from mine.</p>

<p>That‚Äôs all set, let‚Äôs take a look at the assembly of the <code class="language-plaintext highlighter-rouge">fibonacci</code> function to see what it does.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>      main.go:11      0x1023e8890     900b40f9        MOVD 16(R28), R16
      main.go:11      0x1023e8894     f1c300d1        SUB $48, RSP, R17
      main.go:11      0x1023e8898     3f0210eb        CMP R16, R17
      main.go:11      0x1023e889c     090c0054        BLS 96(PC)
      ...
      main.go:17      0x1023e8910     6078fd97        CALL runtime.convT64(SB)
      ...
      main.go:17      0x1023e895c     4d78fd97        CALL runtime.convT64(SB)
      ...
      main.go:20      0x1023e8a18     c0035fd6        RET
      main.go:11      0x1023e8a1c     e00700f9        MOVD R0, 8(RSP)
      main.go:11      0x1023e8a20     e3031eaa        MOVD R30, R3
      main.go:11      0x1023e8a24     dbe7fe97        CALL runtime.morestack_noctxt(SB)
      main.go:11      0x1023e8a28     e00740f9        MOVD 8(RSP), R0
      main.go:11      0x1023e8a2c     99ffff17        JMP main.fibonacci(SB)
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">MOVD 16(R28), R16</code> loads the value at offset 16 from the register <code class="language-plaintext highlighter-rouge">R28</code>, which holds the goroutine data structure <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/runtime2.go#L396-L396"><code class="language-plaintext highlighter-rouge">g</code></a>, and store that value in register <code class="language-plaintext highlighter-rouge">R16</code>.
The loaded value is the <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/runtime2.go#L405-L405"><code class="language-plaintext highlighter-rouge">stackguard0</code></a> field, which serves as the stack guard for the current goroutine.
But what exactly is a stack guard? You may know that a goroutine‚Äôs stack is growable, but how does Go runtime determine when it needs to grow?
The stack guard is a special value placed at the end of the stack. When the stack pointer reaches this value, Go runtime detects that the stack is nearly full and needs to grow‚Äîthat‚Äôs exactly what the next three instructions do.</p>

<p><code class="language-plaintext highlighter-rouge">SUB $48, RSP, R17</code> loads the goroutine‚Äôs stack pointer from the register <code class="language-plaintext highlighter-rouge">RPS</code> to register <code class="language-plaintext highlighter-rouge">R17</code> and subtracts 48 from it.
<code class="language-plaintext highlighter-rouge">CMP R16, R17</code> compares the stack guard with the stack pointer, and <code class="language-plaintext highlighter-rouge">BLS 96(PC)</code> branches to the instruction located 96 instructions ahead in the program if the stack pointer is less than or equal to the stack guard.
Why less than or equal (‚â§) but not greater or equal (‚â•)?
Because stack grows downward, the stack pointer is always greater than the stack guard.</p>

<p>Have you ever wondered why these instructions don‚Äôt appear in the Go code but still show up in the assembly?
That‚Äôs because upon compiling, Go compiler automatically inserts these instructions in function <a href="https://en.wikipedia.org/wiki/Function_prologue_and_epilogue">prologue</a>.
This applies for every function like <code class="language-plaintext highlighter-rouge">fmt.Println</code>, not just our <code class="language-plaintext highlighter-rouge">fibonacci</code>.</p>

<p>After advancing 96 instructions, execution reaches the <code class="language-plaintext highlighter-rouge">MOVD R0, 8(RSP)</code> instruction and then proceeds to <code class="language-plaintext highlighter-rouge">CALL runtime.morestack_noctxt(SB)</code>.
<a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/asm_arm64.s#L348-L348"><code class="language-plaintext highlighter-rouge">runtime.morestack_noctxt</code></a> function will eventually call <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/stack.go#L966-L966"><code class="language-plaintext highlighter-rouge">newstack</code></a> to grow the stack and optionally enter <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/proc.go#L4191-L4193"><code class="language-plaintext highlighter-rouge">gopreempt_m</code></a> to trigger preemption as discussed in non-cooperative preemption.
The key point of cooperative preemption is the condition for entering <code class="language-plaintext highlighter-rouge">gopreempt_m</code>, which is <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/stack.go#L1025-L1025"><code class="language-plaintext highlighter-rouge">stackguard0 == stackPreempt</code></a>.
This means that whenever a goroutine wants to extend its stack, it will be preempted if its <code class="language-plaintext highlighter-rouge">stackguard0</code> was set to <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/stack.go#L128-L130"><code class="language-plaintext highlighter-rouge">stackPreempt</code></a> earlier.</p>

<p><a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/stack.go#L128-L130"><code class="language-plaintext highlighter-rouge">stackPreempt</code></a> can be set by the <code class="language-plaintext highlighter-rouge">sysmon</code> if a goroutine has been running for more than 10ms.
The goroutine will then be cooperatively preempted if it makes a function call or non-cooperatively preempted by the thread‚Äôs signal handler, whichever happens first.
It can also be set when the goroutine enters or exits a system call or during the tracing phase of the garbage collector.
See <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/proc.go#L6366-L6366">sysmon preemption</a>, <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/proc.go#L4525-L4525">syscall entry</a>/<a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/proc.go#L4663-L4663">exit</a>, <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/trace.go#L389-L389">garbage collector tracing</a>.</p>

<h4 id="trace-visualization">Trace Visualization</h4>

<p>Alright, let‚Äôs rerun the program‚Äîmake sure <code class="language-plaintext highlighter-rouge">GOMAXPROCS=1</code> is set‚Äîand then check out the trace.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center"><img src="/assets/2025-03-11-go-scheduling/runtime_trace_cooperative_preempt.png" /></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">Trace visualization when cooperative preemption happens</td>
    </tr>
  </tbody>
</table>

<p>You can clearly see that goroutines relinquish the logical processor after just tens of microseconds‚Äîunlike with non-cooperative preemption, where they might retain it for over 10 milliseconds.
Notably, G9‚Äôs stack trace ends at the <code class="language-plaintext highlighter-rouge">fmt.Printf</code> inside the loop body, demonstrating the stack guard check in function prologue.
This visualization precisely illustrates cooperative preemption, where goroutines <em>voluntarily</em> yield the processor.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center"><img src="/assets/2025-03-11-go-scheduling/cooperative_preemption.png" width="600" /></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">Cooperative preemption in GMP model</td>
    </tr>
  </tbody>
</table>

<h2 id="handling-system-calls">Handling System Calls</h2>

<p><a href="https://en.wikipedia.org/wiki/System_call">System calls</a> are services provided by the kernel that user-space applications access through an API.
These services include fundamental operations, for example, reading files, establishing connections, or allocating memory.
In Go, you rarely need to interact with system calls directly, as the standard library offers higher-level abstractions that simplify these tasks.</p>

<p>However, understanding how system calls work is crucial to gaining insight into Go runtime, standard library internals, as well as performance optimization.
Go‚Äôs runtime employs an M:N threading model, further optimized by the use of logical processors <code class="language-plaintext highlighter-rouge">P</code>, making its approach to handling system calls particularly interesting.</p>

<h3 id="system-call-classification">System Call Classification</h3>

<p>In Go runtime, there are two wrapper functions around kernel system calls: <a href="https://github.com/golang/go/blob/go1.24.0/src/syscall/syscall_linux.go#L54-L56"><code class="language-plaintext highlighter-rouge">RawSyscall</code></a> and <a href="https://github.com/golang/go/blob/go1.24.0/src/syscall/syscall_linux.go#L72-L89"><code class="language-plaintext highlighter-rouge">Syscall</code></a>.
The Go code we write uses these functions to invoke system calls. Each function accepts a system call number, its arguments, and returns values along with an error code.</p>

<p><a href="https://github.com/golang/go/blob/go1.24.0/src/syscall/syscall_linux.go#L72-L89"><code class="language-plaintext highlighter-rouge">Syscall</code></a> is typically used for operations with unpredictable durations, such as reading from a file or writing an HTTP response.
Since the duration of these operations is non-deterministic, Go runtime needs to account for them to ensure efficient use of resources.
The function coordinates goroutines <code class="language-plaintext highlighter-rouge">G</code>, threads <code class="language-plaintext highlighter-rouge">M</code>, and processors <code class="language-plaintext highlighter-rouge">P</code>, allowing the Go runtime to maintain performance and responsiveness during blocking system calls.</p>

<p>Nevertheless, not all system calls are unpredictable. For example, retrieving the process ID or getting the current time is usually quick and consistent. For these types of operations, <a href="https://github.com/golang/go/blob/go1.24.0/src/syscall/syscall_linux.go#L54-L56"><code class="language-plaintext highlighter-rouge">RawSyscall</code></a> is used.
Since no scheduling is involved, the association between goroutines <code class="language-plaintext highlighter-rouge">G</code>, threads <code class="language-plaintext highlighter-rouge">M</code>, and processors <code class="language-plaintext highlighter-rouge">P</code> remains intact when raw system calls are made.</p>

<p>Internally, <a href="https://github.com/golang/go/blob/go1.24.0/src/syscall/syscall_linux.go#L72-L89"><code class="language-plaintext highlighter-rouge">Syscall</code></a> delegates to <a href="https://github.com/golang/go/blob/go1.24.0/src/syscall/syscall_linux.go#L54-L56"><code class="language-plaintext highlighter-rouge">RawSyscall</code></a> to perform the actual system call, but wraps it with additional scheduling logic, which will be described in detail in the next section.</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">Syscall</span><span class="p">(</span><span class="n">trap</span><span class="p">,</span> <span class="n">a1</span><span class="p">,</span> <span class="n">a2</span><span class="p">,</span> <span class="n">a3</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="p">(</span><span class="n">r1</span><span class="p">,</span> <span class="n">r2</span> <span class="kt">uintptr</span><span class="p">,</span> <span class="n">err</span> <span class="n">Errno</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">runtime_entersyscall</span><span class="p">()</span>
    <span class="n">r1</span><span class="p">,</span> <span class="n">r2</span><span class="p">,</span> <span class="n">err</span> <span class="o">=</span> <span class="n">RawSyscall6</span><span class="p">(</span><span class="n">trap</span><span class="p">,</span> <span class="n">a1</span><span class="p">,</span> <span class="n">a2</span><span class="p">,</span> <span class="n">a3</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="m">0</span><span class="p">)</span>
    <span class="n">runtime_exitsyscall</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="scheduling-in-syscall">Scheduling in <code class="language-plaintext highlighter-rouge">Syscall</code></h3>

<p>The scheduling logic is implemented in <a href="https://github.com/golang/go/blob/go1.24.0/src/syscall/syscall_linux.go#L28-L29"><code class="language-plaintext highlighter-rouge">runtime_entersyscall</code></a> function and <a href="https://github.com/golang/go/blob/go1.24.0/src/syscall/syscall_linux.go#L31-L32"><code class="language-plaintext highlighter-rouge">runtime_exitsyscall</code></a> function, respectively before and after actual system call is made.
Under the hood, these functions are actually <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/proc.go#L4512-L4532"><code class="language-plaintext highlighter-rouge">runtime.entersyscall</code></a> and <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/proc.go#L4644-L4747"><code class="language-plaintext highlighter-rouge">runtime.exitsyscall</code></a>.
This association are created at compile time.</p>

<p>Before an actual system call is made, Go runtime records that the invoking goroutine is no longer using the CPU.
The goroutine <code class="language-plaintext highlighter-rouge">G</code> transitions from <em>running</em> state to <em>syscall</em> state, and its stack pointer, program counter, and frame pointer are saved for later restoration.
The association between thread <code class="language-plaintext highlighter-rouge">M</code> and processor <code class="language-plaintext highlighter-rouge">P</code> is then temporarily detached, and <code class="language-plaintext highlighter-rouge">P</code> transitions to <em>syscall</em> state.
This logic is implemented in the <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/proc.go#L4413-L4510"><code class="language-plaintext highlighter-rouge">runtime.reentersyscall</code></a>, which is invoked by <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/proc.go#L4512-L4532"><code class="language-plaintext highlighter-rouge">runtime.entersyscall</code></a>.</p>

<p>Interestingly, the <code class="language-plaintext highlighter-rouge">sysmon</code> (mentioned in the <a href="#non-cooperative-preemption">Non-cooperative Preemption</a> section) monitors not only processors running goroutine code (where <code class="language-plaintext highlighter-rouge">P</code> is in <em>running</em> state), but also those making system calls (where <code class="language-plaintext highlighter-rouge">P</code> is in <em>syscall</em> state).
If a <code class="language-plaintext highlighter-rouge">P</code> remains in <em>syscall</em> state for more than 10ms, instead of non-cooperatively preempting the running goroutine, a <a href="#processor-handoff-handoffp">processor handoff</a> takes place.
This keeps the association between goroutine <code class="language-plaintext highlighter-rouge">G</code> and thread <code class="language-plaintext highlighter-rouge">M</code>, and attaches another  thread <code class="language-plaintext highlighter-rouge">M1</code> to this <code class="language-plaintext highlighter-rouge">P</code>, allowing runnable goroutines to run on that <code class="language-plaintext highlighter-rouge">M1</code> thread.
Apparently, as <code class="language-plaintext highlighter-rouge">P</code> is now executing code, its status is running rather than syscall as before.</p>

<p>Note that while system call is still in progress and whether <code class="language-plaintext highlighter-rouge">sysmon</code> happens to seize <code class="language-plaintext highlighter-rouge">P</code> or not, the association between goroutine <code class="language-plaintext highlighter-rouge">G</code> and thread <code class="language-plaintext highlighter-rouge">M</code> still remains.
Why? Because the Go program (including Go runtime and Go code we write) are just user-space process.
The only mean of execution that kernel provides user-space process is thread.
It is the responsibility of thread to run Go runtime code, user Go code and make system call.
A thread <code class="language-plaintext highlighter-rouge">M</code> makes system call on behalf of some goroutine <code class="language-plaintext highlighter-rouge">G</code>, that‚Äôs why the association between them is maintained as-is.
Therefore, even if <code class="language-plaintext highlighter-rouge">P</code> is seized by <code class="language-plaintext highlighter-rouge">sysmon</code>, <code class="language-plaintext highlighter-rouge">M</code> remains blocked, waiting for the system call to complete before it can invoke the <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/proc.go#L4644-L4747"><code class="language-plaintext highlighter-rouge">runtime.exitsyscall</code></a> function.</p>

<p>Another important point is that whenever a processor <code class="language-plaintext highlighter-rouge">P</code> is in <em>syscall</em> state, <u>it can't be taken up by another thread M to execute code</u> until <code class="language-plaintext highlighter-rouge">sysmon</code> happens to seize it or until the system call is completed.
Therefore, in case there are multiple system calls happening at the same time, the program (excluding system calls) doesn‚Äôt make any progress.
That‚Äôs why <a href="https://docs.hypermode.com/dgraph/overview">Dgraph</a> database hardcodes <a href="https://pkg.go.dev/runtime#GOMAXPROCS"><code class="language-plaintext highlighter-rouge">GOMAXPROCS</code></a> to 128 to <a href="https://github.com/hypermodeinc/dgraph/blob/v24.1.2/dgraph/main.go#L33-L36">‚Äúallow more disk I/O calls to be scheduled‚Äù</a>.</p>

<p>As described in <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/proc.go#L4644-L4747"><code class="language-plaintext highlighter-rouge">runtime.exitsyscall</code></a>, there are two paths the scheduler can take after the syscall is finished: fast path and slow path.
The latter only takes place if the former is not possible.</p>

<p>The fast path occurs when if is a processor <code class="language-plaintext highlighter-rouge">P</code> available to execute the goroutine <code class="language-plaintext highlighter-rouge">G</code> that has just completed its system call.
This <code class="language-plaintext highlighter-rouge">P</code> can either be the same one that previously executed <code class="language-plaintext highlighter-rouge">G</code>, if it is still in the <em>syscall</em> state (i.e., it hasn‚Äôt been seized by <code class="language-plaintext highlighter-rouge">sysmon</code>), or any other processor <code class="language-plaintext highlighter-rouge">P1</code> currently in the <em>idle</em> state‚Äîwhichever is found first.<br />
Note that when system call completes, the previous process <code class="language-plaintext highlighter-rouge">P</code> might not be in <em>syscall</em> state anymore bcause <code class="language-plaintext highlighter-rouge">sysmon</code> has seized it.
Before the fast path exits, <code class="language-plaintext highlighter-rouge">G</code> transition from <em>syscall</em> state to <em>running</em> state.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center"><img src="/assets/2025-03-11-go-scheduling/syscall_fast_path_1.png" width="300" /></th>
      <th style="text-align: center"><img src="/assets/2025-03-11-go-scheduling/syscall_fast_path_2.png" width="500" /></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">System call fast path when <br /> <code class="language-plaintext highlighter-rouge">sysmon</code> doesn‚Äôt seize processor <code class="language-plaintext highlighter-rouge">P</code></td>
      <td style="text-align: center">System call fast path when <br /> <code class="language-plaintext highlighter-rouge">sysmon</code> seizes processor <code class="language-plaintext highlighter-rouge">P</code></td>
    </tr>
  </tbody>
</table>

<p>In the slow path, the scheduler tries retrieving any idle processor <code class="language-plaintext highlighter-rouge">P</code> once again.
If it‚Äôs found, the goroutine <code class="language-plaintext highlighter-rouge">G</code> is scheduled to run on that <code class="language-plaintext highlighter-rouge">P</code>.
Otherwise, <code class="language-plaintext highlighter-rouge">G</code> is enqueued into the global run queue and the associated thread <code class="language-plaintext highlighter-rouge">M</code> is stopped by <a href="#stop-thread-stopm"><code class="language-plaintext highlighter-rouge">stopm</code></a> function, waiting to be woken up to continue the <a href="#schedule-loop">schedule loop</a>.</p>

<h2 id="network-io-and-file-io">Network I/O and File I/O</h2>

<p>This <a href="https://go.dev/blog/survey2024h2/what.svg">survey</a> shows that 75% of Go uses cases are web services and 45% are static websites.
It‚Äôs not a coincidence, Go is designed to be efficient for I/O operations to solve the notorious problem‚Äî<a href="https://en.wikipedia.org/wiki/C10k_problem">C10K</a>.
To see how Go solves it, let‚Äôs take a look at how Go handles I/O operations under the hood.</p>

<h3 id="http-server-under-the-hood">HTTP Server Under the Hood</h3>

<p>In Go, it‚Äôs incredibly straightforward to start an HTTP server. For example:</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="s">"net/http"</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">http</span><span class="o">.</span><span class="n">HandleFunc</span><span class="p">(</span><span class="s">"/"</span><span class="p">,</span> <span class="k">func</span><span class="p">(</span><span class="n">w</span> <span class="n">http</span><span class="o">.</span><span class="n">ResponseWriter</span><span class="p">,</span> <span class="n">r</span> <span class="o">*</span><span class="n">http</span><span class="o">.</span><span class="n">Request</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">w</span><span class="o">.</span><span class="n">WriteHeader</span><span class="p">(</span><span class="m">200</span><span class="p">)</span>
    <span class="p">})</span>
	
    <span class="n">http</span><span class="o">.</span><span class="n">ListenAndServe</span><span class="p">(</span><span class="s">":80"</span><span class="p">,</span> <span class="no">nil</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Functions like <code class="language-plaintext highlighter-rouge">http.ListenAndServe()</code> and <code class="language-plaintext highlighter-rouge">http.HandleFunc()</code> might seem deceptively simple‚Äîbut under the hood, they abstract away a lot of low-level networking complexity.
Go relies on many fundamental <a href="https://en.wikipedia.org/wiki/Unix_domain_socket">socket</a> operations (depicted in the figure below) to manage network communication.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center"><img src="/assets/2025-03-11-go-scheduling/socket_system_calls_in_http_server.png" width="300" /></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">Overview of system calls used with stream sockets<sup><a href="#references">7</a></sup></td>
    </tr>
  </tbody>
</table>

<p>Specifically, <code class="language-plaintext highlighter-rouge">http.ListenAndServe()</code> leverages <a href="https://man7.org/linux/man-pages/man2/socket.2.html"><code class="language-plaintext highlighter-rouge">socket()</code></a>, <a href="https://man7.org/linux/man-pages/man2/bind.2.html"><code class="language-plaintext highlighter-rouge">bind()</code></a>, <a href="https://man7.org/linux/man-pages/man2/listen.2.html"><code class="language-plaintext highlighter-rouge">listen()</code></a>, <a href="https://man7.org/linux/man-pages/man2/accept.2.html"><code class="language-plaintext highlighter-rouge">accept()</code></a> system calls to create TCP sockets, which are essentially <a href="https://en.wikipedia.org/wiki/File_descriptor">file descriptors</a>.
It binds the TCP listening socket to the specified address and port, listens for incoming connections, and creates a new connected socket to handle client requests.
This is achieved without requiring you to write socket-handling code.
Similarly, <code class="language-plaintext highlighter-rouge">http.HandleFunc()</code> registers your handler functions, abstracting away the lower-level details like using <a href="https://man7.org/linux/man-pages/man2/read.2.html"><code class="language-plaintext highlighter-rouge">read()</code></a> system call to read data, and <a href="https://man7.org/linux/man-pages/man2/write.2.html"><code class="language-plaintext highlighter-rouge">write()</code></a> system call to write data to the network socket.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center"><img src="/assets/2025-03-11-go-scheduling/go_http_server_meme.jpg" width="300" /></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">Go abstracts system calls to provide simple interface for HTTP server</td>
    </tr>
  </tbody>
</table>

<p>However, it‚Äôs not that simple for an HTTP server to handle tens of thousands of concurrent requests efficiently.
Go employs several techniques to achieve this. Let‚Äôs take a closer look at some notable I/O models in Linux and how Go takes advantage of them.</p>

<h3 id="blocking-io-non-blocking-io-and-io-multiplexing">Blocking I/O, Non-blocking I/O and I/O Multiplexing</h3>

<p>An I/O operation can be either blocking or non-blocking.
When a thread issues a blocking system call, its execution is suspended until the system call completes with the requested data.
In contrast, non-blocking I/O doesn‚Äôt suspend the thread; instead, it returns the requested data if available, or an error (<a href="https://man7.org/linux/man-pages/man3/errno.3.html#:~:text=POSIX.1%2D2001\).-,EAGAIN,-Resource%20temporarily%20unavailable"><code class="language-plaintext highlighter-rouge">EAGAIN</code></a> or <a href="https://man7.org/linux/man-pages/man3/errno.3.html#:~:text=POSIX.1%2D2001\).-,EAGAIN,-Resource%20temporarily%20unavailable"><code class="language-plaintext highlighter-rouge">EWOULDBLOCK</code></a>) if the data is not yet ready.
Blocking I/O is simpler to implement but inefficient, as it requires the application to spawn N threads for N connections.
In contrast, non-blocking I/O is more complex, but when implemented correctly, it enables significantly better resource utilization.
See the figures below for a visual comparison of these two models.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center"><img src="/assets/2025-03-11-go-scheduling/blocking_io.png" width="300" /></th>
      <th style="text-align: center"><img src="/assets/2025-03-11-go-scheduling/non_blocking_io.png" width="300" /></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">Blocking I/O model<sup><a href="#references">8</a></sup></td>
      <td style="text-align: center">Non-blocking I/O model<sup><a href="#references">9</a></sup></td>
    </tr>
  </tbody>
</table>

<p>Another I/O model worth mentioning is I/O multiplexing, in which <a href="https://man7.org/linux/man-pages/man2/select.2.html"><code class="language-plaintext highlighter-rouge">select</code></a>, or <a href="https://man7.org/linux/man-pages/man2/poll.2.html"><code class="language-plaintext highlighter-rouge">poll</code></a> system call is used to wait for one of a set of file descriptors to become ready to perform I/O.
In this model, the application blocks on one of these system calls, rather than on the actual I/O system calls, such as <a href="https://man7.org/linux/man-pages/man2/recv.2.html"><code class="language-plaintext highlighter-rouge">recvfrom</code></a> shown in the figures above.
When <a href="https://man7.org/linux/man-pages/man2/select.2.html"><code class="language-plaintext highlighter-rouge">select</code></a> returns that the socket is readable, the application calls <a href="https://man7.org/linux/man-pages/man2/recv.2.html"><code class="language-plaintext highlighter-rouge">recvfrom</code></a> to copy requested data to application buffer in user space.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center"><img src="/assets/2025-03-11-go-scheduling/io_multiplexing.png" width="500" /></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">I/O multiplexing model<sup><a href="#references">10</a></sup></td>
    </tr>
  </tbody>
</table>

<h3 id="io-model-in-go">I/O Model in Go</h3>

<p>Go uses a combination of non-blocking I/O and I/O multiplexing to handle I/O operations efficiently.
Due to the performance limitations of <a href="https://man7.org/linux/man-pages/man2/select.2.html"><code class="language-plaintext highlighter-rouge">select</code></a> and <a href="https://man7.org/linux/man-pages/man2/poll.2.html"><code class="language-plaintext highlighter-rouge">poll</code></a>  ‚Äîas explained in this <a href="https://jvns.ca/blog/2017/06/03/async-io-on-linux--select--poll--and-epoll/#why-don-t-we-use-poll-and-select">blog</a>‚ÄîGo avoids them in favor of more scalable alternatives: <a href="https://man7.org/linux/man-pages/man7/epoll.7.html">epoll</a> on Linux, <a href="https://man.freebsd.org/cgi/man.cgi?kqueue">kqueue</a> on Darwin, and <a href="https://learn.microsoft.com/en-us/windows/win32/fileio/i-o-completion-ports">IOCP</a> on Windows.
Go introduces netpoll, a function that abstracts these alternatives, to provide a unified interface for I/O multiplexing across different OS.</p>

<h2 id="how-netpoll-works">How netpoll Works</h2>

<p>Working with netpoll requires 4 steps: creating an <a href="https://man7.org/linux/man-pages/man7/epoll.7.html"><code class="language-plaintext highlighter-rouge">epoll</code></a> instance in kernel space, registering file descriptors with the <a href="https://man7.org/linux/man-pages/man7/epoll.7.html"><code class="language-plaintext highlighter-rouge">epoll</code></a> instance, <a href="https://man7.org/linux/man-pages/man7/epoll.7.html"><code class="language-plaintext highlighter-rouge">epoll</code></a> polls for I/O on file descriptors, and unregistering file descriptors from the <a href="https://man7.org/linux/man-pages/man7/epoll.7.html"><code class="language-plaintext highlighter-rouge">epoll</code></a> instance.
Let‚Äôs see how Go implements these steps.</p>

<h3 id="creating-epoll-instance-and-registering-goroutine">Creating epoll Instance and Registering Goroutine</h3>

<p>When a TCP listener <a href="https://github.com/golang/go/blob/go1.24.0/src/net/tcpsock.go#L374-L385">accepts</a> a connection, <a href="https://man7.org/linux/man-pages/man2/accept.2.html"><code class="language-plaintext highlighter-rouge">accept4</code></a> system call is invoked with <a href="https://man7.org/linux/man-pages/man2/socket.2.html#:~:text=of%0A%20%20%20%20%20%20%20socket()%3A-,SOCK_NONBLOCK,-Set%20the%20O_NONBLOCK"><code class="language-plaintext highlighter-rouge">SOCK_NONBLOCK</code></a> flag to set the socket‚Äôs file descriptor of the socket to non-blocking mode.
Following this, several descriptors are created to integrate with Go runtime‚Äôs netpoll.</p>

<ol>
  <li>An instance of <a href="https://github.com/golang/go/blob/go1.24.0/src/net/fd_posix.go#L16-L27"><code class="language-plaintext highlighter-rouge">net.netFD</code></a> is created to wrap the socket‚Äôs file descriptor.
This struct provides a higher-level abstraction for performing network operations on the underlying file descriptor.
When an instance of <a href="https://github.com/golang/go/blob/go1.24.0/src/net/fd_posix.go#L16-L27"><code class="language-plaintext highlighter-rouge">net.netFD</code></a> is initialized, <a href="https://man7.org/linux/man-pages/man2/epoll_create.2.html"><code class="language-plaintext highlighter-rouge">epoll_create</code></a> system call is invoked to create a <strong>single global</strong> <a href="https://man7.org/linux/man-pages/man7/epoll.7.html"><code class="language-plaintext highlighter-rouge">epoll</code></a> instance, which is used throughout the lifetime of the process.
This is performed in <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/netpoll.go#L213-L216"><code class="language-plaintext highlighter-rouge">poll_runtime_pollServerInit</code></a> function, and only runs once as being wrapped in a <a href="https://pkg.go.dev/sync#Once"><code class="language-plaintext highlighter-rouge">sync.Once</code></a>.</li>
  <li>Inside <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/netpoll.go#L243-L278"><code class="language-plaintext highlighter-rouge">poll_runtime_pollOpen</code></a>, Go runtime allocates a <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/netpoll.go#L72-L115"><code class="language-plaintext highlighter-rouge">runtime.pollDesc</code></a> instance, which contains scheduling metadata and <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/netpoll.go#L98-L101">references</a> to the goroutines involved in I/O.
The socket‚Äôs file descriptor is then registered with the interest list of <a href="https://man7.org/linux/man-pages/man7/epoll.7.html"><code class="language-plaintext highlighter-rouge">epoll</code></a> using <a href="https://man7.org/linux/man-pages/man2/epoll_ctl.2.html"><code class="language-plaintext highlighter-rouge">epoll_ctl</code></a> system call with <a href="https://man7.org/linux/man-pages/man2/epoll_ctl.2.html#:~:text=op%20argument%20are%3A-,EPOLL_CTL_ADD,-Add%20an%20entry"><code class="language-plaintext highlighter-rouge">EPOLL_CTL_ADD</code></a> operation.
As <a href="(https://man7.org/linux/man-pages/man7/epoll.7.html)"><code class="language-plaintext highlighter-rouge">epoll</code></a> monitors file descriptors rather than goroutines, <a href="https://man7.org/linux/man-pages/man2/epoll_ctl.2.html"><code class="language-plaintext highlighter-rouge">epoll_ctl</code></a> also associates the file descriptor with an instance of <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/netpoll.go#L72-L115"><code class="language-plaintext highlighter-rouge">runtime.pollDesc</code></a>, allowing the Go scheduler to identify which goroutine should be resumed when I/O readiness is reported.</li>
  <li>An instance of <a href="https://github.com/golang/go/blob/go1.24.0/src/internal/poll/fd_unix.go#L17-L48"><code class="language-plaintext highlighter-rouge">poll.FD</code></a> is created to manage read and write operations with polling support.
It holds a reference to a <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/netpoll.go#L72-L115"><code class="language-plaintext highlighter-rouge">runtime.pollDesc</code></a> indirectly via <a href="https://github.com/golang/go/blob/go1.24.0/src/internal/poll/fd_poll_runtime.go#L32-L34"><code class="language-plaintext highlighter-rouge">poll.pollDesc</code></a>, which is simply a wrapper.</li>
</ol>

<blockquote>
  <p>‚ö†Ô∏è Go does have problem with a single <code class="language-plaintext highlighter-rouge">epoll</code> instance as described in <a href="https://github.com/golang/go/issues/65064">this</a> open issue.
There are discussions <a href="https://github.com/golang/go/issues/65064#issuecomment-1896633168">whether Go should use a single or multiple <code class="language-plaintext highlighter-rouge">epoll</code> instances</a>, or even <a href="https://github.com/golang/go/issues/65064#issuecomment-1896633168">use another I/O multiplexing model like <code class="language-plaintext highlighter-rouge">io_uring</code></a>.</p>
</blockquote>

<p>Building on the success of this model for network I/O, Go also leverages <a href="https://man7.org/linux/man-pages/man7/epoll.7.html"><code class="language-plaintext highlighter-rouge">epoll</code></a> for file I/O.
Once a file is opened, <a href="https://github.com/golang/go/blob/go1.24.0/src/os/file_unix.go#L222-L222"><code class="language-plaintext highlighter-rouge">syscall.SetNonblock</code></a> function is called to enable non-blocking mode for the file descriptor.
Subsequently, <a href="https://github.com/golang/go/blob/go1.24.0/src/internal/poll/fd_unix.go#L17-L48"><code class="language-plaintext highlighter-rouge">poll.FD</code></a>, <a href="https://github.com/golang/go/blob/go1.24.0/src/internal/poll/fd_poll_runtime.go#L32-L34"><code class="language-plaintext highlighter-rouge">poll.pollDesc</code></a> and <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/netpoll.go#L72-L115"><code class="language-plaintext highlighter-rouge">runtime.pollDesc</code></a> instances are initialized to register the file descriptor with <a href="https://man7.org/linux/man-pages/man7/epoll.7.html"><code class="language-plaintext highlighter-rouge">epoll</code></a>‚Äôs interest list, allowing file I/O to be multiplexed as well.</p>

<p>The relationship between these descriptors is depicted in the figure below.
Meanwhile <a href="https://github.com/golang/go/blob/go1.24.0/src/net/fd_posix.go#L16-L27"><code class="language-plaintext highlighter-rouge">net.netFD</code></a>, <a href="https://github.com/golang/go/blob/go1.24.0/src/os/types.go#L15-L20"><code class="language-plaintext highlighter-rouge">os.File</code></a>, <a href="https://github.com/golang/go/blob/go1.24.0/src/internal/poll/fd_unix.go#L17-L48"><code class="language-plaintext highlighter-rouge">poll.FD</code></a>, and <a href="https://github.com/golang/go/blob/go1.24.0/src/internal/poll/fd_poll_runtime.go#L32-L34"><code class="language-plaintext highlighter-rouge">poll.pollDesc</code></a> are implemented in user Go code (specifically in the Go standard library), <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/netpoll.go#L72-L115"><code class="language-plaintext highlighter-rouge">runtime.pollDesc</code></a> resides within Go runtime itself.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center"><img src="/assets/2025-03-11-go-scheduling/netpoll_descriptors.png" /></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">Relationship of descriptors in Go</td>
    </tr>
  </tbody>
</table>

<h3 id="polling-file-descriptors">Polling File Descriptors</h3>

<p>When a goroutine reads from socket or file, it eventually invokes the <a href="https://github.com/golang/go/blob/go1.24.0/src/internal/poll/fd_unix.go#L141-L173"><code class="language-plaintext highlighter-rouge">Read</code></a> method of <a href="https://github.com/golang/go/blob/go1.24.0/src/internal/poll/fd_unix.go#L17-L48"><code class="language-plaintext highlighter-rouge">poll.FD</code></a>.
In this method, the goroutine makes <a href="https://man7.org/linux/man-pages/man2/read.2.html"><code class="language-plaintext highlighter-rouge">read</code></a> system call to get any available data from the file descriptor.
If the I/O data is not ready yet, i.e. <code class="language-plaintext highlighter-rouge">EAGAIN</code> error is returned, Go runtime invokes <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/netpoll.go#L336-L361"><code class="language-plaintext highlighter-rouge">poll_runtime_pollWait</code></a> method to <a href="#goroutine-parking-gopark">park the goroutine</a>.
The behavior is similar when a goroutine writes to a socket or file, with the main difference being that <a href="https://github.com/golang/go/blob/go1.24.0/src/internal/poll/fd_unix.go#L141-L173"><code class="language-plaintext highlighter-rouge">Read</code></a> is replaced by <a href="https://github.com/golang/go/blob/go1.24.0/src/net/net.go#L201-L211"><code class="language-plaintext highlighter-rouge">Write</code></a>, and the <a href="https://man7.org/linux/man-pages/man2/read.2.html"><code class="language-plaintext highlighter-rouge">read</code></a> system call is substituted with <a href="https://man7.org/linux/man-pages/man2/write.2.html"><code class="language-plaintext highlighter-rouge">write</code></a>.
Now that the goroutine is in <em>waiting</em> state, it is the responsibility of netpoll to present goroutine to the Go runtime when the goroutine‚Äôs file descriptor is ready for I/O so that it can be resumed.</p>

<p>In Go runtime, netpoll is nothing more than a function having the same name.
In <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/netpoll_epoll.go#L91-L176">netpoll</a> function, <a href="https://man7.org/linux/man-pages/man2/epoll_wait.2.html"><code class="language-plaintext highlighter-rouge">epoll_wait</code></a> system call is used to monitor up to 128 file descriptors in a specified amount of time.
This system call returns the <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/netpoll.go#L72-L115"><code class="language-plaintext highlighter-rouge">runtime.pollDesc</code></a> instances that were previously registered (as described in the previous section) for each file descriptor that becomes ready.
Finally, netpoll extracts the goroutine references from <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/netpoll.go#L72-L115"><code class="language-plaintext highlighter-rouge">runtime.pollDesc</code></a> and hands them off to the Go runtime.</p>

<p>But when is the netpoll function actually called?
It‚Äôs triggered when a thread looks for a runnable goroutine to execute, as outlined in <a href="#schedule-loop">schedule loop</a>.
According to <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/proc.go#L3267-L3646"><code class="language-plaintext highlighter-rouge">findRunnable</code></a> function, netpoll is only consulted by the Go runtime if there are no goroutines available in either the local run queue of the current <code class="language-plaintext highlighter-rouge">P</code> or the global run queue.
This means even if its file descriptor is ready for I/O, the goroutine is not necessarily woken up immediately.</p>

<p>As mentioned earlier, netpoll can block for a specified amount of time, and this is determined by the <code class="language-plaintext highlighter-rouge">delay</code> parameter.
If <code class="language-plaintext highlighter-rouge">delay</code> is positive, it blocks for the specified number of nanoseconds.
If <code class="language-plaintext highlighter-rouge">delay</code> is negative, it blocks until an I/O event becomes ready.
Otherwise, when <code class="language-plaintext highlighter-rouge">delay</code> is zero, it returns immediately with any I/O events that are currently ready.
In the <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/proc.go#L3267-L3646"><code class="language-plaintext highlighter-rouge">findRunnable</code></a> function, <code class="language-plaintext highlighter-rouge">delay</code> is passed with 0, which means that if one goroutine is waiting for I/O, another goroutine can be scheduled to run on the same kernel thread.</p>

<h3 id="unregistering-file-descriptors">Unregistering File Descriptors</h3>

<p>As mentioned above, <a href="https://man7.org/linux/man-pages/man7/epoll.7.html"><code class="language-plaintext highlighter-rouge">epoll</code></a> instance monitors up to 128 file descriptors.
Therefore, it‚Äôs important to unregister file descriptors when they are no longer needed otherwise some goroutines may be starved.
When file or network connection is no longer in used, we should close it by calling its <code class="language-plaintext highlighter-rouge">Close</code> method.</p>

<p>Under the hood, the <a href="https://github.com/golang/go/blob/go1.24.0/src/internal/poll/fd_unix.go#L75-L87"><code class="language-plaintext highlighter-rouge">destroy</code></a> method of <a href="https://github.com/golang/go/blob/go1.24.0/src/internal/poll/fd_unix.go#L75-L87"><code class="language-plaintext highlighter-rouge">poll.FD</code></a> is called.
This method eventually invokes the function <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/netpoll.go#L280-L295"><code class="language-plaintext highlighter-rouge">poll_runtime_pollClose</code></a> in Go runtime to make <a href="https://man7.org/linux/man-pages/man2/epoll_ctl.2.html"><code class="language-plaintext highlighter-rouge">epoll_ctl</code></a> with <code class="language-plaintext highlighter-rouge">EPOLL_CTL_DEL</code> operation.
This unregisters the file descriptor from the <a href="https://man7.org/linux/man-pages/man7/epoll.7.html"><code class="language-plaintext highlighter-rouge">epoll</code></a>‚Äôs interest list.</p>

<h3 id="putting-it-all-together-1">Putting It All Together</h3>

<p>The figure below illustrates the entire process of how netpoll works in Go runtime with file I/O.
The process for network I/O is similar, but with the addition of a TCP listener that accepts connection and connection is closed.
For simplicity purpose, other components in such as <code class="language-plaintext highlighter-rouge">sysmon</code> and other idle processors <code class="language-plaintext highlighter-rouge">P</code> are omitted.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center"><img src="/assets/2025-03-11-go-scheduling/netpoll_in_gmp_model.png" width="350" /></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">How netpoll works in GMP model</td>
    </tr>
  </tbody>
</table>

<h2 id="garbage-collector">Garbage Collector</h2>

<p>You may know that Go includes a garbage collector (GC) to automatically reclaim memory from unused objects.
However, as mentioned in the <a href="#program-bootstrap">Program Bootstrap</a> section, when the program starts, there are no threads initially available to run the GC.
So where does the GC actually run?</p>

<p>Before we answer that question, let‚Äôs take a quick look at how garbage collection works.
Go uses a tracing garbage collector, which identifies live and dead objects by traversing the allocated object graph starting from a set of root references.
Objects that are reachable from the roots are considered live; those that are not are considered dead and eligible for reclamation.</p>

<p>Go‚Äôs GC implements a <a href="https://en.wikipedia.org/wiki/Tracing_garbage_collection#Tri-color_marking">tri-color marking algorithm</a> with support for <a href="https://learn.microsoft.com/en-us/dotnet/standard/garbage-collection/weak-references">weak references</a>.
This design allows the garbage collector to run concurrently with the program, significantly reducing stop-the-world (STW) pauses and improving overall performance.</p>

<p>A Go garbage collection cycle can be divided into 4 stages:</p>
<ol>
  <li><strong>First STW</strong>: The process is paused so that all processors <code class="language-plaintext highlighter-rouge">P</code> can enter the safe point.</li>
  <li><strong>Marking phase</strong>: GC goroutines takes processor <code class="language-plaintext highlighter-rouge">P</code> shortly to mark reachable objects.</li>
  <li><strong>Second STW</strong>: The process is paused again to allow the GC to finalize the marking phase.</li>
  <li><strong>Sweeping phase</strong>: Unpause the process and reclaim memory for unreachable objects in background.</li>
</ol>

<p>Note that in step 2, garbage collection worker goroutine runs concurrently with regular goroutines on the same processor <code class="language-plaintext highlighter-rouge">P</code>.
The <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/proc.go#L3267-L3646"><code class="language-plaintext highlighter-rouge">findRunnable</code></a> function (mentioned in <a href="#finding-a-runnable-goroutine">Finding a Runnable Goroutine</a> section) not only looks for regular goroutines but also for GC goroutines (step 1 and 2).</p>

<h2 id="common-functions">Common Functions</h2>

<h3 id="getting-goroutine-getg">Getting Goroutine: <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/stubs.go#L28-L31"><code class="language-plaintext highlighter-rouge">getg</code></a></h3>

<p>In Go runtime, there is a common function that is used to retrieve the running goroutine in current kernel thread: <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/stubs.go#L28-L31"><code class="language-plaintext highlighter-rouge">getg()</code></a>.
Taking a glance at the source code, you can see no implementation for this function.
That‚Äôs because upon compiling, the compiler rewrites calls to this function into instructions that fetch the goroutine from <a href="https://en.wikipedia.org/wiki/Thread-local_storage">thread-local storage</a> (TLS) or from registers.</p>

<p>But when is the current goroutine stored in thread-local storage so it can be retrieved later?
This happens during a goroutine context switch in the <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/asm_amd64.s#L411-L413"><code class="language-plaintext highlighter-rouge">gogo</code></a> function, which is called by <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/proc.go#L3221-L3265"><code class="language-plaintext highlighter-rouge">execute</code></a>.
It also takes place when a signal handler is invoked, in the <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/signal_unix.go#L420-L495"><code class="language-plaintext highlighter-rouge">sigtrampgo</code></a> function.</p>

<h3 id="goroutine-parking-gopark">Goroutine Parking: <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/proc.go#L390-L436"><code class="language-plaintext highlighter-rouge">gopark</code></a></h3>

<p>This is a commonly used procedure in Go runtime for transitioning the current goroutine into a <em>waiting</em> state and scheduling another goroutine to run.
The snippet below highlights some of its key aspects.</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">gopark</span><span class="p">(</span><span class="n">unlockf</span> <span class="k">func</span><span class="p">(</span><span class="o">*</span><span class="n">g</span><span class="p">,</span> <span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span><span class="p">)</span> <span class="kt">bool</span><span class="p">,</span> <span class="o">...</span><span class="p">)</span> <span class="p">{</span>
    <span class="o">...</span>
    <span class="n">mp</span><span class="o">.</span><span class="n">waitunlockf</span> <span class="o">=</span> <span class="n">unlockf</span>
    <span class="o">...</span>
    <span class="n">releasem</span><span class="p">(</span><span class="n">mp</span><span class="p">)</span>
    <span class="o">...</span>
    <span class="n">mcall</span><span class="p">(</span><span class="n">park_m</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Inside <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/runtime1.go#L612-L619"><code class="language-plaintext highlighter-rouge">releasem</code></a> function, the goroutine‚Äôs <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/runtime2.go#L405-L405"><code class="language-plaintext highlighter-rouge">stackguard0</code></a> is set to <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/stack.go#L128-L130"><code class="language-plaintext highlighter-rouge">stackPreempt</code></a> to trigger an eventual cooperative preemption.
The control is then transferred to the <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/runtime2.go#L529"><code class="language-plaintext highlighter-rouge">g0</code></a> system goroutine, which belongs to the same thread currently running the goroutine, to invoke the <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/proc.go#L4089-L4142"><code class="language-plaintext highlighter-rouge">park_m</code></a> function.</p>

<p>Inside <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/proc.go#L4089-L4142"><code class="language-plaintext highlighter-rouge">park_m</code></a>, the goroutine state is set to <em>waiting</em> and the association between the goroutine and thread <code class="language-plaintext highlighter-rouge">M</code> is dropped.
Additionally, <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/proc.go#L390-L436"><code class="language-plaintext highlighter-rouge">gopark</code></a> receives an <code class="language-plaintext highlighter-rouge">unlockf</code> callback function, which is executed in <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/proc.go#L4089-L4142"><code class="language-plaintext highlighter-rouge">park_m</code></a>.
If <code class="language-plaintext highlighter-rouge">unlockf</code> returns <code class="language-plaintext highlighter-rouge">false</code>, the parked goroutine is immediately made runnable again and rescheduled on the same thread <code class="language-plaintext highlighter-rouge">M</code> using <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/proc.go#L3221-L3265"><code class="language-plaintext highlighter-rouge">execute</code></a>.
Otherwise, <code class="language-plaintext highlighter-rouge">M</code> enters the <a href="#schedule-loop">schedule loop</a> to pick a goroutine and execute it.</p>

<h3 id="start-thread-startm">Start Thread: <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/proc.go#L2917-L3025"><code class="language-plaintext highlighter-rouge">startm</code></a></h3>

<p>This function is responsible for scheduling a thread <code class="language-plaintext highlighter-rouge">M</code> to run a given processor <code class="language-plaintext highlighter-rouge">P</code>.
The diagram below illustrates the flow of this function, in which <code class="language-plaintext highlighter-rouge">M1</code> thread is the parent of <code class="language-plaintext highlighter-rouge">M2</code> thread.</p>

<table>
    <thead>
        <tr>
            <td>
                <pre class="mermaid" style="margin: unset">

flowchart LR
    subgraph M2
    direction LR
        mstart["mstart()"] ==&gt; mstart0["mstart0()"]
        mstart0 ==&gt; mstart1["mstart1()"]
        mstart1 ==&gt; schedule["schedule()"]
    end
    subgraph M1
        direction LR
        start((Start)) ==&gt; check_p{P == nil?}
        check_p ==&gt; |Yes|check_idle_p{Is there any idle P?}
        check_idle_p ==&gt; |No|_end(((End)))
        check_idle_p ==&gt; |Yes|assign_p[P = idle P]
        check_p ==&gt; |No|check_idle_m{Is there any idle M?}
        assign_p ==&gt; check_idle_m
        check_idle_m ==&gt; |Yes|wakeup_m[Wake up M]
        wakeup_m ==&gt; _end
        check_idle_m ==&gt; |No|newm["newm()"]
        newm ==&gt; newm1["newm1()"]
        newm1 ==&gt; newosproc["newosproc()"]
        newosproc ==&gt; clone["clone() with entry point mstart, result in M2 thread"]
        clone ==&gt; _end
    end

                </pre>
            </td>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td style="text-align: center">
                The <code>startm</code> function
            </td>
        </tr>
    </tbody>
</table>

<p>If <code class="language-plaintext highlighter-rouge">P</code> is <code class="language-plaintext highlighter-rouge">nil</code>, it attempts to retrieve an idle processor from the global idle list.
If no idle processor is available, the function simply returns‚Äîindicating that the maximum number of active processors is already in use and no additional thread <code class="language-plaintext highlighter-rouge">M</code> can be created or reactivated.
If an idle processor is found (or <code class="language-plaintext highlighter-rouge">P</code> was already provided), the function either creates a new thread <code class="language-plaintext highlighter-rouge">M1</code> (if none is idle) or wakes up an existing idle one to run <code class="language-plaintext highlighter-rouge">P</code>.</p>

<p>Once awakened, the existing thread <code class="language-plaintext highlighter-rouge">M</code> continues in the <a href="#schedule-loop">schedule loop</a>.
If a new thread is created, it‚Äôs done via the <a href="https://man7.org/linux/man-pages/man2/clone.2.html"><code class="language-plaintext highlighter-rouge">clone</code></a> system call, with <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/os_linux.go#L186-L187"><code class="language-plaintext highlighter-rouge">mstart</code></a> as the entry point.
The <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/proc.go#L1769-L1771"><code class="language-plaintext highlighter-rouge">mstart</code></a> function then transitions into the <a href="#schedule-loop">schedule loop</a>, where it looks for a runnable goroutine to execute.</p>

<h3 id="stop-thread-stopm">Stop Thread: <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/proc.go#L2889-L2910"><code class="language-plaintext highlighter-rouge">stopm</code></a></h3>

<p>This function adds thread <code class="language-plaintext highlighter-rouge">M</code> into the idle list and put it into sleep.
<a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/proc.go#L2889-L2910"><code class="language-plaintext highlighter-rouge">stopm</code></a> doesn‚Äôt return until <code class="language-plaintext highlighter-rouge">M</code> is woken up by another thread, typically when a new goroutine is created, as mentioned in <a href="#waking-up-processor">Waking Up Processor</a> section.
This is achieved by <a href="https://linux.die.net/man/2/futex"><code class="language-plaintext highlighter-rouge">futex</code></a> system call, making <code class="language-plaintext highlighter-rouge">M</code> not eating CPU cycles while waiting.</p>

<h3 id="processor-handoff-handoffp">Processor Handoff: <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/proc.go#L3026-L3096"><code class="language-plaintext highlighter-rouge">handoffp</code></a></h3>

<p><a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/proc.go#L3026-L3096"><code class="language-plaintext highlighter-rouge">handoffp</code></a> is responsible for transferring the ownership of a processor <code class="language-plaintext highlighter-rouge">P</code> from a thread <code class="language-plaintext highlighter-rouge">M</code>s that is blocking in a system call to another thread <code class="language-plaintext highlighter-rouge">M1</code>.
<code class="language-plaintext highlighter-rouge">P</code> will be associated with <code class="language-plaintext highlighter-rouge">M1</code> to make progress by calling <a href="#start-thread-startm"><code class="language-plaintext highlighter-rouge">startm</code></a> under certain conditions: if the global run queue is not empty, if its local run queue is not empty, if there is tracing work or garbage collection work to do, or if no thread is currently handling netpoll.
If none of these conditions is met, <code class="language-plaintext highlighter-rouge">P</code> is returned to the processor idle list.</p>

<h2 id="runtime-apis">Runtime APIs</h2>

<p>Go runtime provides several APIs to interact with the scheduler and goroutines.
It also allows Go programmers to tune the scheduler and other components like garbage collector for their application specific needs.</p>

<h3 id="gomaxprocs"><a href="https://pkg.go.dev/runtime#GOMAXPROCS"><code class="language-plaintext highlighter-rouge">GOMAXPROCS</code></a></h3>

<p>This function sets the maximum number of processors <code class="language-plaintext highlighter-rouge">P</code> in Go runtime, thus controlling the level of parallelism in a Go program.
Some I/O bound programs may benefit from a higher number of processors <code class="language-plaintext highlighter-rouge">P</code> than the default.
For example, <a href="https://github.com/hypermodeinc/dgraph/blob/v24.1.2/dgraph/main.go#L36">Dgraph</a> database hardcodes <a href="https://pkg.go.dev/runtime#GOMAXPROCS"><code class="language-plaintext highlighter-rouge">GOMAXPROCS</code></a> to 128.</p>

<h3 id="goexit"><a href="https://pkg.go.dev/runtime#Goexit"><code class="language-plaintext highlighter-rouge">Goexit</code></a></h3>

<p>This function gracefully terminates the current goroutine.
All deferred calls run before terminating the goroutine.
The program continues execution of other goroutines.
If all other goroutines exit, the program crashes.
<a href="https://pkg.go.dev/runtime#Goexit"><code class="language-plaintext highlighter-rouge">Goexit</code></a> should be used testing rather than real-world application, where you want to abort the test case early (for example, if preconditions aren‚Äôt met), but you still want deferred cleanup to run.</p>

<h2 id="conclusion">Conclusion</h2>

<p>The Go scheduler is a powerful and efficient system that enables lightweight concurrency through goroutines.
In this blog, we explored its evolution‚Äîfrom the primitive model to the GMP architecture‚Äîand key components like goroutine creation, preemption, syscall handling, and netpoll integration.</p>

<p>Hope you will find this knowledge useful in writing more efficient and reliable Go programs! üòÑ</p>

<h2 id="references">References</h2>

<ul>
  <li>kelche.co. <a href="https://www.kelche.co/blog/go/golang-scheduling"><em>Go Scheduling</em></a>.</li>
  <li>unskilled.blog. <a href="https://unskilled.blog/posts/preemption-in-go-an-introduction/"><em>Preemption in Go</em></a>.</li>
  <li>Ian Lance Taylor. <a href="https://groups.google.com/g/golang-nuts/c/JCKWH8fap9o"><em>What is system stack?</em></a></li>
  <li>[6], [7] Michael Kerrisk. <a href="https://man7.org/tlpi/"><em>The Linux Programming Interface</em></a>.</li>
  <li>[8], [9], [10] W. Richard Stevens. <a href="https://www.amazon.com/UNIX-Network-Programming-Richard-Stevens/dp/0139498761"><em>Unix Network Programming</em></a>.</li>
  <li>zhuanlan.zhihu.com. <a href="https://zhuanlan.zhihu.com/p/436925356"><em>Golang program startup process analysis</em></a>.</li>
  <li>Madhav Jivrajani. <a href="https://www.youtube.com/watch?v=wQpC99Xu1U4&amp;t=2375s&amp;ab_channel=GopherAcademy"><em>GopherCon 2021: Queues, Fairness, and The Go Scheduler</em></a>.</li>
  <li>
    <div><span id="ref-1" /><span id="ref-2" /><span id="ref-3" />[1], [2], [3] Abraham Silberschatz, Peter B. Galvin, Greg Gagne. <a href="https://www.amazon.com/Operating-System-Concepts-Abraham-Silberschatz/dp/1119800366/ref=zg-te-pba_d_sccl_3_1/138-7692107-2007040"><i>Operating System Concepts.</i></a></div>
  </li>
</ul>

<div class="giscus" id="reaction"></div>


<script src="https://unpkg.com/medium-zoom@1.1.0/dist/medium-zoom.min.js"></script>
<script>
    document.addEventListener('DOMContentLoaded', function () {
        mediumZoom('img'); // Zooms all images
    });
</script>

<script>
    // Show button when scrolling down
    window.onscroll = function () {
        const scrollTopBtn = document.getElementById("scrollTop");
        if (document.body.scrollTop > 300 || document.documentElement.scrollTop > 300) {
            scrollTopBtn.style.display = "block";
        } else {
            scrollTopBtn.style.display = "none";
        }

        const scrollBottomBtn = document.getElementById("scrollBottom");
        const scrollTop = document.documentElement.scrollTop || document.body.scrollTop;
        const windowHeight = window.innerHeight;
        const docHeight = document.documentElement.scrollHeight;

        // Show button if we're not near the bottom
        if (docHeight - (scrollTop + windowHeight) > 300) {
            scrollBottomBtn.style.display = "block";
        } else {
            scrollBottomBtn.style.display = "none";
        }
    };

    // Scroll to top when button is clicked
    document.getElementById("scrollTop").addEventListener("click", function () {
        window.scrollTo({ top: 0, behavior: 'smooth' });
    });

    // Scroll to bottom when button is clicked
    document.getElementById("scrollBottom").addEventListener("click", function () {
        window.scrollTo({ top: document.body.scrollHeight, behavior: 'smooth' });
    });
</script>

<script src="https://giscus.app/client.js"
        data-repo="nghiant3223/nghiant3223.github.io"
        data-repo-id="R_kgDOJ-uLAQ"
        data-category="General"
        data-category-id="DIC_kwDOJ-uLAc4CqGrC"
        data-mapping="title"
        data-strict="0"
        data-reactions-enabled="1"
        data-emit-metadata="1"
        data-input-position="top"
        data-theme="light"
        data-lang="en"
        data-loading="lazy"
        crossorigin="anonymous">
</script>
      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">Melatoni</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">nghiant3223@gmail.com</li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>Writings about software engineering</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
