<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.10.0">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2025-05-13T14:17:54+07:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Melatoni</title><subtitle>Writings about programming</subtitle><author><name>nghiant3223@gmail.com</name></author><entry><title type="html">Go Scheduler</title><link href="http://localhost:4000/2025/04/15/go-scheduler.html" rel="alternate" type="text/html" title="Go Scheduler" /><published>2025-04-15T00:00:00+07:00</published><updated>2025-04-15T00:00:00+07:00</updated><id>http://localhost:4000/2025/04/15/go-scheduler</id><content type="html" xml:base="http://localhost:4000/2025/04/15/go-scheduler.html"><![CDATA[<h1 id="go-scheduler">Go Scheduler</h1>

<h2 id="disclaimer">Disclaimer</h2>

<p>This blog post primarily focuses on <a href="https://tip.golang.org/doc/go1.24">Go 1.24</a> programming language for <a href="https://en.wikipedia.org/wiki/Linux">Linux</a> on <a href="https://en.wikipedia.org/wiki/ARM_architecture_family">ARM</a> architecture.
It may not cover platform-specific details for other operating systems or architectures.</p>

<p>The content is based on other sources and my own understanding of Go, so it might not be entirely accurate.
Feel free to correct me or give suggestions in the comment section üòÑ.</p>

<h2 id="introduction">Introduction</h2>

<blockquote>
  <p>This post assumes that you already have a basic understanding of Go concurrency (goroutines, channels, etc.).
If you‚Äôre new to these concepts, consider reviewing them before continuing.</p>
</blockquote>

<p>Go, introduced in 2009, has steadily grown in popularity as a programming language for building concurrent applications.
It is designed to be simple, efficient, and easy to use, with a focus on concurrency programming.</p>

<p>Go‚Äôs concurrency model is built around the concept goroutines, which are lightweight user threads managed by the Go runtime on user space.
Go offers useful primitives for synchronization, such as channels and mutexes, to help developers write concurrent code easily.
Go also uses non-trivial techniques to make I/O bound programs efficient.</p>

<p>Understanding the Go scheduler is crucial for Go programmer to write efficient concurrent programs.
It also helps us better at troubleshooting performance issues or tuning the performance of your Go programs.
In this post, we will explore how Go scheduler evolved over time, and how the Go code we write happens under the hood.</p>

<h2 id="compilation-and-go-runtime">Compilation and Go Runtime</h2>

<p>This post covers a lot of source code walkthrough, so it is better to have a basic understanding of how Go code is compiled and executed first.
When a Go program is built, there are three stages:</p>
<ul>
  <li><strong>Compilation</strong>: Go source files (<code class="language-plaintext highlighter-rouge">*.go</code>) are compiled into assembly files (<code class="language-plaintext highlighter-rouge">*.s</code>).</li>
  <li><strong>Assembling</strong>: The assembly files (<code class="language-plaintext highlighter-rouge">*.s</code>) are then assembled into object files (<code class="language-plaintext highlighter-rouge">*.o</code>).</li>
  <li><strong>Linking</strong>: The object files (<code class="language-plaintext highlighter-rouge">*.o</code>) are linked together to produce a single executable binary file.</li>
</ul>

<table>
    <thead>
        <tr>
            <td>
                <pre class="mermaid" style="margin: unset">

flowchart LR
start((Start)) ==&gt; |*.go files|compiler[Compiler]
compiler ==&gt; |*.s files|assembler[Assembler]
assembler ==&gt; |*.o files|linker[Linker]
linker ==&gt; |Executable binary file|_end(((End)))

                </pre>
            </td>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td style="text-align: center">
                How Go code is transformed into an executable binary file
            </td>
        </tr>
    </tbody>
</table>

<p>Go runtime is the core of the Go programming language, providing essential functionalities such as scheduling, memory managements, and data structures.
To understand Go scheduler, you have to understand Go runtime first.
The implementation of Go runtime can be found at <a href="https://github.com/golang/go/tree/go1.24.0/src/runtime">runtime</a> package.
Go runtime is written in a combination of Go and assembly code, with the assembly code primarily used for low-level operations such as dealing with registers.</p>

<p>Upon compiling, Go compiler replaces some keywords and built-in functions with Go runtime‚Äôs function calls.
For example, the <code class="language-plaintext highlighter-rouge">go</code> keyword‚Äîused to spawn a new goroutine‚Äîis substituted with a call to <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/proc.go#L5014-L5030"><code class="language-plaintext highlighter-rouge">runtime.newproc</code></a>, or the <code class="language-plaintext highlighter-rouge">new</code> function‚Äîused to allocate a new object‚Äîis replaced with a call to <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/malloc.go#L1710-L1715"><code class="language-plaintext highlighter-rouge">runtime.newobject</code></a>.</p>

<p>You might be surprised to learn that some functions in the Go runtime have no Go implementation at all.
For example, functions like <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/stubs.go#L28-L31"><code class="language-plaintext highlighter-rouge">getg</code></a> are recognized by the Go compiler and replaced with low-level assembly code during compilation.
Other function, such as <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/stubs.go#L214-L214"><code class="language-plaintext highlighter-rouge">gogo</code></a>, are platform-specific and implemented entirely in assembly.
It is the responsibility of the Go linker to connect these assembly implementations with their Go declarations.</p>

<p>In some cases, a function appears to have no implementation in its package, but is actually linked to a definition in the Go runtime using the <a href="https://pkg.go.dev/cmd/compile#hdr-Linkname_Directive"><code class="language-plaintext highlighter-rouge">//go:linkname</code></a> compiler directive.
For instance, the commonly used <a href="https://github.com/golang/go/blob/go1.24.0/src/time/sleep.go#L12-L14"><code class="language-plaintext highlighter-rouge">time.Sleep</code></a> function  is linked to its actual implementation at <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/time.go#L297-L340"><code class="language-plaintext highlighter-rouge">runtime.timeSleep</code></a></p>

<h2 id="primitive-scheduler">Primitive Scheduler</h2>

<blockquote>
  <p>‚ö†Ô∏è The Go scheduler isn‚Äôt a standalone object, but rather a collection of functions that facilitate the scheduling.
Additionally, it doesn‚Äôt run on a dedicated thread; instead, it runs on the same threads that goroutines run on.
These concepts will become clearer as you read through the rest of the post.</p>
</blockquote>

<p>If you‚Äôve ever worked in concurrency programming, you might be familiar with multithreading models.
It specifies how user-space threads (coroutines in Kotlin, Lua or goroutines in Go) are multiplexed onto single or multiple kernel threads.
Typically, there are three models: many-to-one (N:1), one-to-one (1:1), and many-to-many (M:N).</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center"><img src="/assets/2025-03-11-go-scheduling/n_to_1_multithreading_model.png" /></th>
      <th style="text-align: center"><img src="/assets/2025-03-11-go-scheduling/1_to_1_multithreading_model.png" /></th>
      <th style="text-align: center"><img src="/assets/2025-03-11-go-scheduling/m_to_n_multithreading_model.png" /></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">Many-to-one<br />multithreading model<sup>1</sup></td>
      <td style="text-align: center">One-to-one<br />multithreading model<sup>2</sup></td>
      <td style="text-align: center">Many-to-many<br />multithreading model<sup>3</sup></td>
    </tr>
  </tbody>
</table>

<p>Go opts for the many-to-many (M:N) threading model, which allows multiple goroutines to be multiplexed onto multiple kernel threads.
This approach sacrifices complexity to take advantage of multicore system and make Go program efficient with system calls, addressing the problems of both N:1 and 1:1 models.
As kernel doesn‚Äôt know what goroutine is and only offers thread as concurrency unit to user-space application, it is the kernel thread that runs scheduling logic, executes goroutine code, and makes system call on behalf of goroutines.</p>

<p>In the early days, particularly before version 1.1, Go implemented the M:N multithreading model in a naive way.
There were only two entities: goroutines (<code class="language-plaintext highlighter-rouge">G</code>) and kernel threads (<code class="language-plaintext highlighter-rouge">M</code>, or <em>machines</em>).
A single global run queue was used to store all runnable goroutines and guarded with lock to prevent race condition.
The scheduler‚Äîrunning on every thread <code class="language-plaintext highlighter-rouge">M</code>‚Äîwas responsible for selecting a goroutine from the global run queue and executing it.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center"><img src="/assets/2025-03-11-go-scheduling/primitive_scheduler.png" width="500" /></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">Go‚Äôs primitive scheduler</td>
    </tr>
  </tbody>
</table>

<p>Nowadays, Go is famous for its performant concurrency model. 
But that‚Äôs not the case for the early Go.
Dmitry Vyukov‚Äîa Go contributor‚Äîpointed out multiple issues with this implementation in his famous <a href="https://docs.google.com/document/d/1TTj4T2JO42uD5ID9e89oa0sLKhJYD0Y_kqxDv3I3XMw">Scalable Go Scheduler Design</a>: ‚ÄúIn general, the scheduler may inhibit users from using idiomatic fine-grained concurrency where performance is critical.‚Äù
Let me explain in more detail what he meant.</p>

<p>Firstly, the global run queue was a bottleneck for performance.
When a goroutine was created, threads had to acquire a lock to put it into the global run queue.
Similarly, when threads wanted to pick up a goroutine from the global run queue, they also had to acquire the lock.
You may know that locking is not free, it does have overhead with lock contention.
Lock contention leads to performance degradation, especially in high-concurrency scenarios.</p>

<p>Secondly, threads frequently handoff its associated goroutine to another thread.
This cause poor locality and excessive context switch overhead.
Child goroutine usually wants to communicate with its parent goroutine.
Therefore, making child goroutine run on the same thread as its parent goroutine is more performant.</p>

<p>Thirdly, as Go‚Äôs been using <a href="https://google.github.io/tcmalloc/design.html">Thread-caching Malloc</a>, every thread <code class="language-plaintext highlighter-rouge">M</code> has a thread-local cache <code class="language-plaintext highlighter-rouge">mcache</code> so that it can use for allocation or to hold free memory.
While <code class="language-plaintext highlighter-rouge">mcache</code> is only used by <code class="language-plaintext highlighter-rouge">M</code>s executing Go code, it is even attached with <code class="language-plaintext highlighter-rouge">M</code>s blocking in a system call, which don‚Äôt use <code class="language-plaintext highlighter-rouge">mcache</code> at all.
An <code class="language-plaintext highlighter-rouge">mcache</code> can take up to 2MB of memory, and it is not freed until the thread <code class="language-plaintext highlighter-rouge">M</code> is destroyed.
Because the ratio between <code class="language-plaintext highlighter-rouge">M</code>s running Go code and all <code class="language-plaintext highlighter-rouge">M</code>s can be as high as 1:100 (too many threads are blocking in system call), this could lead to excessive resource consumption and poor data locality.</p>

<h2 id="scheduler-enhancement">Scheduler Enhancement</h2>

<p>Now that you have a understanding of the issues with early Go scheduler, let‚Äôs examine some of the enhancement proposals to see how Go team addressed these issues so that we have a performant scheduler today.</p>

<h3 id="proposal-1-introduction-of-local-run-queue">Proposal 1: Introduction of Local Run Queue</h3>

<p>Each thread <code class="language-plaintext highlighter-rouge">M</code> is equipped with a local run queue to store runnable goroutines.
When a running goroutine <code class="language-plaintext highlighter-rouge">G</code> on thread <code class="language-plaintext highlighter-rouge">M</code> spawns a new goroutine <code class="language-plaintext highlighter-rouge">G1</code> using the <code class="language-plaintext highlighter-rouge">go</code> keyword, <code class="language-plaintext highlighter-rouge">G1</code> is added to <code class="language-plaintext highlighter-rouge">M</code>‚Äôs local run queue.
If the local queue is full, <code class="language-plaintext highlighter-rouge">G1</code> is instead placed in the global run queue.
When selecting a goroutine to execute, <code class="language-plaintext highlighter-rouge">M</code> first checks its local run queue before consulting the global run queue.
Thus, this proposal addresses the first and second issues as described in the last section.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center"><img src="/assets/2025-03-11-go-scheduling/proposal_1.png" width="500" /></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">Proposal 1 for scheduler enhancement</td>
    </tr>
  </tbody>
</table>

<p>However, it can‚Äôt resolve the third issue.
When many threads <code class="language-plaintext highlighter-rouge">M</code> are blocked in system calls, their <code class="language-plaintext highlighter-rouge">mcache</code> stays attached, causing high memory usage by the Go scheduler itself, not to mention the memory usage of the program that we‚ÄîGo programmers‚Äîwrite.</p>

<p>It also introduces another performance problem.
In order to avoid starving goroutines in a blocked <code class="language-plaintext highlighter-rouge">M</code>‚Äôs local run queue like <code class="language-plaintext highlighter-rouge">M1</code> in the figure above, the scheduler should allow other threads to <em>steal</em> goroutine from it.
However, with a large number of blocked threads, scanning all of them to find a non-empty run queue becomes expensive.</p>

<h3 id="proposal-2-introduction-of-logical-processor">Proposal 2: Introduction of Logical Processor</h3>

<p>This proposal is described in <a href="https://docs.google.com/document/d/1TTj4T2JO42uD5ID9e89oa0sLKhJYD0Y_kqxDv3I3XMw">Scalable Go Scheduler Design</a>, where the notion of <em>logical</em> processor <code class="language-plaintext highlighter-rouge">P</code> is introduced.
By <em>logical</em>, it means that <code class="language-plaintext highlighter-rouge">P</code> pretends to execute goroutine code, but in practice, it is the thread <code class="language-plaintext highlighter-rouge">M</code> associated with <code class="language-plaintext highlighter-rouge">P</code> that actually performs the execution.
Thread‚Äôs local run queue and <code class="language-plaintext highlighter-rouge">mcache</code> are now owned by <code class="language-plaintext highlighter-rouge">P</code>.</p>

<p>This proposal effectively addresses open issues in the last section.
As <code class="language-plaintext highlighter-rouge">mcache</code> is now attached to <code class="language-plaintext highlighter-rouge">P</code> instead of <code class="language-plaintext highlighter-rouge">M</code> and <code class="language-plaintext highlighter-rouge">M</code> is detached from <code class="language-plaintext highlighter-rouge">P</code> when <code class="language-plaintext highlighter-rouge">G</code> makes system call, the memory consumption stays low when there are a large number of <code class="language-plaintext highlighter-rouge">M</code>s entering system calls.
Also, as the number of <code class="language-plaintext highlighter-rouge">P</code> is limited, the <em>stealing</em> mechanism is efficient.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center"><img src="/assets/2025-03-11-go-scheduling/proposal_2.png" width="500" /></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">Proposal 2 for scheduler enhancement</td>
    </tr>
  </tbody>
</table>

<p>With the introduction of logical processors, the multithreading model remains M:N.
But in Go, it is specifically referred to as the GMP model as there are three kinds of entities: goroutine, thread and processor.</p>

<h2 id="gmp-model">GMP Model</h2>

<h3 id="goroutine-g">Goroutine: <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/runtime2.go#L396-L508"><code class="language-plaintext highlighter-rouge">g</code></a></h3>

<p>When the <code class="language-plaintext highlighter-rouge">go</code> keyword is followed by a function call, a new instance of <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/runtime2.go#L396-L508"><code class="language-plaintext highlighter-rouge">g</code></a>, referred to as <code class="language-plaintext highlighter-rouge">G</code>, is created.
<code class="language-plaintext highlighter-rouge">G</code> is an object that represents a goroutine, containing metadata such as its execution state, stack, and a program counter pointing to the associated function.
Executing a goroutine simply means running the function that <code class="language-plaintext highlighter-rouge">G</code> references.</p>

<p>When a goroutine finishes execution, it isn‚Äôt destroyed; instead, it becomes <em>dead</em> and is placed into the free list of the current processor <code class="language-plaintext highlighter-rouge">P</code> .
If <code class="language-plaintext highlighter-rouge">P</code>‚Äôs free list is full, the dead goroutine is moved to the global free list.
When a new goroutine is created, the scheduler first attempts to reuse one from the free list before allocating a new one from scratch.
This recycling mechanism makes goroutine creation significantly cheaper than creating a new thread.</p>

<p>The figure and table below described the state machine of goroutines in the GMP model.
Some states and transitions are omitted for simplicity.
The actions that trigger state transitions will be described along the post.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">State</th>
      <th>¬†¬†¬† Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center"><a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/runtime2.go#L36-L39">Idle</a></td>
      <td>Has just been created, and not yet initialized</td>
    </tr>
    <tr>
      <td style="text-align: center"><a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/runtime2.go#L40-L42">Runnable</a></td>
      <td>Currently in run queue, and about to execute code</td>
    </tr>
    <tr>
      <td style="text-align: center"><a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/runtime2.go#L44-L47">Running</a></td>
      <td>Not in a run queue, and executing code</td>
    </tr>
    <tr>
      <td style="text-align: center"><a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/runtime2.go#L49-L52">Syscall</a></td>
      <td>Executing system call, and not executing code</td>
    </tr>
    <tr>
      <td style="text-align: center"><a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/runtime2.go#L54-L62">Waiting</a></td>
      <td>Not executing code, and not in a run queue, e.g. waiting for channel</td>
    </tr>
    <tr>
      <td style="text-align: center"><a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/runtime2.go#L68-L74">Dead</a></td>
      <td>Currently in a free list, just exited, or just  beiging initialized</td>
    </tr>
  </tbody>
</table>

<table>
  <thead>
    <tr>
      <th style="text-align: center"><img src="/assets/2025-03-11-go-scheduling/goroutine_state_machine.png" width="400" /></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">State machine of goroutines in GMP model</td>
    </tr>
  </tbody>
</table>

<h3 id="thread-m">Thread: <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/runtime2.go#L528-L630"><code class="language-plaintext highlighter-rouge">m</code></a></h3>

<p>All Go code‚Äîwhether it‚Äôs user code, the scheduler, or the garbage collector‚Äîruns on threads that are managed by the operating system kernel.
In order for the Go scheduler to make threads work well in GMP model, <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/runtime2.go#L528-L630"><code class="language-plaintext highlighter-rouge">m</code></a> struct representing threads is introduced, and an instance of <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/runtime2.go#L528-L630"><code class="language-plaintext highlighter-rouge">m</code></a> is called <code class="language-plaintext highlighter-rouge">M</code>.</p>

<p><code class="language-plaintext highlighter-rouge">M</code> maintains reference to the current goroutine <code class="language-plaintext highlighter-rouge">G</code>, the current processor <code class="language-plaintext highlighter-rouge">P</code> if <code class="language-plaintext highlighter-rouge">M</code> is executing Go code, the previous processor <code class="language-plaintext highlighter-rouge">P</code> if <code class="language-plaintext highlighter-rouge">M</code> is executing system call, and the next processor <code class="language-plaintext highlighter-rouge">P</code> if <code class="language-plaintext highlighter-rouge">M</code> is about to be created.</p>

<p>Each <code class="language-plaintext highlighter-rouge">M</code> also holds reference to a special goroutine called <code class="language-plaintext highlighter-rouge">g0</code>, which runs on the system stack‚Äîthe stack provided by the kernel to the thread.
Unlike the system stack, a regular goroutine‚Äôs stack is dynamically sized; it grows and shrinks as needed.
However, the operations for growing or shrinking a stack must themselves run on a valid stack. For this, the system stack is used.
When the scheduler‚Äîrunning on an <code class="language-plaintext highlighter-rouge">M</code>‚Äîneeds to perform stack management, it switches from the goroutine‚Äôs stack to the system stack.
In addition to stack growth and shrinkage, operations like garbage collection and <a href="#goroutine-parking-gopark">parking a goroutine</a> also require execution on the system stack.</p>

<p>Unlike goroutine, threads run scheduler code as soon as <code class="language-plaintext highlighter-rouge">M</code> is created, therefore the initial state of <code class="language-plaintext highlighter-rouge">M</code> is <em>running</em>.
When <code class="language-plaintext highlighter-rouge">M</code> is created or woken up, the scheduler guarantees that there is always an <em>idle</em> processor <code class="language-plaintext highlighter-rouge">P</code> so that it can be associated with <code class="language-plaintext highlighter-rouge">M</code> to run Go code.
If <code class="language-plaintext highlighter-rouge">M</code> is executing system call, it will be detached from <code class="language-plaintext highlighter-rouge">P</code> (will be described in <a href="#handling-system-calls">Handling System Calls</a> section) and <code class="language-plaintext highlighter-rouge">P</code> might be acquired by another thread <code class="language-plaintext highlighter-rouge">M1</code> to continues its work.
If <code class="language-plaintext highlighter-rouge">M</code> can‚Äôt find a runnable goroutine from its local run queue, the global run queue, or <code class="language-plaintext highlighter-rouge">netpoll</code> (will be described in <a href="#network-io-and-file-io">Network I/O and File I/O</a> section), it keeps spinning for stealing goroutines from other processors <code class="language-plaintext highlighter-rouge">P</code> and from the global run queue again.
Note that not all <code class="language-plaintext highlighter-rouge">M</code> enters spinning state, it does so only if the number of spinning threads is less than half of the number of busy processors.
When <code class="language-plaintext highlighter-rouge">M</code> has nothing to do, rather than being destroyed, it goes to sleep and waits to be acquired by a another processor <code class="language-plaintext highlighter-rouge">P1</code> later (described in <a href="#finding-a-runnable-goroutine">Finding a Runnable Goroutine</a>).</p>

<p>The figure and table below described the state machine of threads in the GMP model.
Some states and transitions are omitted for simplicity.
<em>Spinning</em> is a substate of <em>running</em>, in which thread consumes CPU cycles to solely execute Go runtime code that steals goroutine.
The actions that trigger state transitions will be described along the post.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">State</th>
      <th>¬†¬†¬† Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">Running</td>
      <td>Executing Go runtime code, or user Go code</td>
    </tr>
    <tr>
      <td style="text-align: center">Syscall</td>
      <td>Currently executing (blocking in) a system call</td>
    </tr>
    <tr>
      <td style="text-align: center">Spinning</td>
      <td>Stealing goroutine from other processors</td>
    </tr>
    <tr>
      <td style="text-align: center">Sleep</td>
      <td>Sleeping, not consuming CPU cycle</td>
    </tr>
  </tbody>
</table>

<table>
  <thead>
    <tr>
      <th style="text-align: center"><img src="/assets/2025-03-11-go-scheduling/thread_state_machine.png" width="500" /></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">State machine of threads in GMP model</td>
    </tr>
  </tbody>
</table>

<h3 id="processor-p">Processor: <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/runtime2.go#L632-L757"><code class="language-plaintext highlighter-rouge">p</code></a></h3>

<p><code class="language-plaintext highlighter-rouge">p</code> struct conceptually represents a physical processor to execute goroutines.
Instances of <code class="language-plaintext highlighter-rouge">p</code> are called <code class="language-plaintext highlighter-rouge">P</code>, and they are created during the program‚Äôs bootstrap phase.
While the number of threads created could be large (<a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/proc.go#L827-L827">10000</a> in Go 1.24), the number of processors is usually small and determined by the <a href="https://pkg.go.dev/runtime#GOMAXPROCS"><code class="language-plaintext highlighter-rouge">GOMAXPROCS</code></a>.
There are exactly <a href="https://pkg.go.dev/runtime#GOMAXPROCS"><code class="language-plaintext highlighter-rouge">GOMAXPROCS</code></a> processors, regardless of its state.</p>

<p>To minimize lock contention on the global run queue, each processor <code class="language-plaintext highlighter-rouge">P</code> in the Go runtime maintains a local run queue.
A local run queue is not just a queue but composed of two components: <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/runtime2.go#L655-L667"><code class="language-plaintext highlighter-rouge">runnext</code></a> which holds a single prioritized goroutine, and <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/runtime2.go#L654-L654"><code class="language-plaintext highlighter-rouge">runq</code></a> which is a queue of goroutines.
Both of these components serve as a source of runnable goroutines for <code class="language-plaintext highlighter-rouge">P</code>, but <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/runtime2.go#L655-L667"><code class="language-plaintext highlighter-rouge">runnext</code></a> exists specifically as a performance optimization.
The Go scheduler allows <code class="language-plaintext highlighter-rouge">P</code> to steal goroutines from other processors <code class="language-plaintext highlighter-rouge">P1</code>‚Äôs local run queue.
<code class="language-plaintext highlighter-rouge">P1</code>‚Äôs <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/runtime2.go#L655-L667"><code class="language-plaintext highlighter-rouge">runnext</code></a> in only consulted if the first three attempts stealing from its <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/runtime2.go#L654-L654"><code class="language-plaintext highlighter-rouge">runq</code></a> is unsuccessful.
Therefore, when <code class="language-plaintext highlighter-rouge">P</code> wants to execute a goroutine, there is less lock contention if it looks for a runnable goroutine from its <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/runtime2.go#L655-L667"><code class="language-plaintext highlighter-rouge">runnext</code></a> first.</p>

<p>The <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/runtime2.go#L654-L654"><code class="language-plaintext highlighter-rouge">runq</code></a> component of <code class="language-plaintext highlighter-rouge">P</code> is an array-based, fixed-size, and circular queue.
By array-based and fixed-size with 256 slots, it allows better cache locality and reduces memory allocation overhead.
Fixed-size is safe for <code class="language-plaintext highlighter-rouge">P</code>‚Äôs local run queues as we also have the global run queue as a backup.
By circular, it allows efficiently adding and removing goroutines without needing to shift elements around.</p>

<p>Each <code class="language-plaintext highlighter-rouge">P</code> instance also maintains references to some memory management data structures such as <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/mcache.go#L13-L55"><code class="language-plaintext highlighter-rouge">mcache</code></a> and <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/mpagecache.go#L14-L22"><code class="language-plaintext highlighter-rouge">pageCache</code></a>.
<a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/mcache.go#L13-L55"><code class="language-plaintext highlighter-rouge">mcache</code></a> serves as the front-end in <a href="https://google.github.io/tcmalloc/design.html">Thread-Caching Malloc</a> model and is used by <code class="language-plaintext highlighter-rouge">P</code> to allocate micro and small objects.
<a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/mpagecache.go#L14-L22"><code class="language-plaintext highlighter-rouge">pageCache</code></a>, on the other hand, enables the memory allocator to fetch memory pages without acquiring the <a href="https://www.ibm.com/docs/en/sdk-java-technology/8?topic=management-heap-allocation#the-allocator">heap lock</a>, thereby improving performance under high concurrency.</p>

<p>In order for a Go program to work well with <a href="https://pkg.go.dev/time#Sleep">sleeps</a>, <a href="https://pkg.go.dev/time#After">timeouts</a> or <a href="https://pkg.go.dev/time#Tick">intervals</a>, <code class="language-plaintext highlighter-rouge">P</code> also manages timers implemented by <a href="https://en.wikipedia.org/wiki/Heap_(data_structure)">min-heap</a> data structure.
When looking for a runnable goroutine, <code class="language-plaintext highlighter-rouge">P</code> also checks if there are any timers that have expired.
If so, <code class="language-plaintext highlighter-rouge">P</code> adds the corresponding goroutine with timer to <code class="language-plaintext highlighter-rouge">P</code>‚Äôs local run queue, waking up the goroutine.</p>

<p>The figure and table below described the state machine of processors in the GMP model.
Some states and transitions are omitted for simplicity.
The actions that trigger state transitions will be described along the post.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">State</th>
      <th>¬†¬†¬† Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center"><a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/runtime2.go#L113-L120">Idle</a></td>
      <td>Not executing Go runtime code or user Go code</td>
    </tr>
    <tr>
      <td style="text-align: center"><a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/runtime2.go#L122-L129">Running</a></td>
      <td>Associated with a <code class="language-plaintext highlighter-rouge">M</code> that is executing user Go code</td>
    </tr>
    <tr>
      <td style="text-align: center"><a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/runtime2.go#L131-L141">Syscall</a></td>
      <td>Associated with a <code class="language-plaintext highlighter-rouge">M</code> that is executing system call</td>
    </tr>
    <tr>
      <td style="text-align: center"><a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/runtime2.go#L143-L151">GCStop</a></td>
      <td>Associated with a <code class="language-plaintext highlighter-rouge">M</code> that is stopped-the-world for garbage collection</td>
    </tr>
    <tr>
      <td style="text-align: center"><a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/runtime2.go#L153-L157">Dead</a></td>
      <td>No longer in-used, waiting to be reused when <a href="https://pkg.go.dev/runtime#GOMAXPROCS">GOMAXPROCS</a> grows</td>
    </tr>
  </tbody>
</table>

<table>
  <thead>
    <tr>
      <th style="text-align: center"><img src="/assets/2025-03-11-go-scheduling/processor_state_machine.png" width="500" /></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">State machine of processors in GMP model</td>
    </tr>
  </tbody>
</table>

<p>At the early execution of a Go program, there are <a href="https://pkg.go.dev/runtime#GOMAXPROCS"><code class="language-plaintext highlighter-rouge">GOMAXPROCS</code></a> processors <code class="language-plaintext highlighter-rouge">P</code> in the <em>idle</em> state.
When a thread <code class="language-plaintext highlighter-rouge">M</code> acquires a processor to run user Go code, <code class="language-plaintext highlighter-rouge">P</code> transitions to the <em>running</em> state.
If the current goroutine <code class="language-plaintext highlighter-rouge">G</code> makes a system call, <code class="language-plaintext highlighter-rouge">P</code> is detached from <code class="language-plaintext highlighter-rouge">M</code> and enters the <em>syscall</em> state.
During the system call, if <code class="language-plaintext highlighter-rouge">P</code> is seized by <code class="language-plaintext highlighter-rouge">sysmon</code> (see <a href="#non-cooperative-preemption">Non-cooperative Preemption</a>), it first transitions to <em>idle</em>, then is handed off to another thread (<code class="language-plaintext highlighter-rouge">M1</code>) and enters the <em>running</em> state.
Otherwise, once the system call completes, <code class="language-plaintext highlighter-rouge">P</code> is reattached to last <code class="language-plaintext highlighter-rouge">M</code> and resumes the <em>running</em> state (see <a href="#handling-system-calls">Handling system calls</a>).
When a stop-the-world garbage collection occurs, <code class="language-plaintext highlighter-rouge">P</code> transitions to the <em>gcStop</em> state and returns to its previous state once start-the-world resumes.
If <a href="https://pkg.go.dev/runtime#GOMAXPROCS"><code class="language-plaintext highlighter-rouge">GOMAXPROCS</code></a> is decreased at runtime, redundant processors transition to the <em>dead</em> state and are reused if <a href="https://pkg.go.dev/runtime#GOMAXPROCS"><code class="language-plaintext highlighter-rouge">GOMAXPROCS</code></a> increases later.</p>

<h2 id="program-bootstrap">Program Bootstrap</h2>

<p>To enable the Go scheduler, it must be initialized during the program‚Äôs bootstrap.
This initialization is handled in assembly via the <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/asm_amd64.s#L159-L159"><code class="language-plaintext highlighter-rouge">runtime¬∑rt0_go</code></a> function.
During this phase, thread <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/proc.go#L117-L117"><code class="language-plaintext highlighter-rouge">M0</code></a> (representing the main thread) and goroutine <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/proc.go#L118-L118"><code class="language-plaintext highlighter-rouge">G0</code></a> (<a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/proc.go#L117-L117"><code class="language-plaintext highlighter-rouge">M0</code></a>‚Äôs system stack goroutine) are created.
<a href="https://en.wikipedia.org/wiki/Thread-local_storage">Thread-local storage</a> (TLS) for the main thread is also set up, and the address of <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/proc.go#L118-L118"><code class="language-plaintext highlighter-rouge">G0</code></a> is stored in this TLS, allowing it to be retrieved later via <a href="#getting-goroutine-getg"><code class="language-plaintext highlighter-rouge">getg</code></a>.</p>

<p>The bootstrap process then invokes the assembly function <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/asm_amd64.s#L349"><code class="language-plaintext highlighter-rouge">runtime¬∑schedinit</code></a>, whose Go implementation can be found at <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/proc.go#L790-L898"><code class="language-plaintext highlighter-rouge">runtime.schedinit</code></a>.
This function performs various initializations, most notably invoking <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/proc.go#L5719-L5868"><code class="language-plaintext highlighter-rouge">procresize</code></a>, which sets up to <a href="https://pkg.go.dev/runtime#GOMAXPROCS"><code class="language-plaintext highlighter-rouge">GOMAXPROCS</code></a> logical processors <code class="language-plaintext highlighter-rouge">P</code> in <em>idle</em> state.
The main thread <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/proc.go#L117-L117"><code class="language-plaintext highlighter-rouge">M0</code></a> is then associated with the first processors, transitioning its state from <em>idle</em> to <em>running</em> to execute goroutines.</p>

<p>Afterward, the main goroutine is created to run the <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/proc.go#L146-L148"><code class="language-plaintext highlighter-rouge">runtime.main</code></a> function, which serves as the Go runtime entry point.
Within <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/proc.go#L146-L148"><code class="language-plaintext highlighter-rouge">runtime.main</code></a> function, a dedicated thread is created to launch <code class="language-plaintext highlighter-rouge">sysmon</code>, which will be described in <a href="#non-cooperative-preemption">Non-cooperative Preemption</a> section.
Note that <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/proc.go#L146-L148"><code class="language-plaintext highlighter-rouge">runtime.main</code></a> is different from the <code class="language-plaintext highlighter-rouge">main</code> function we write; the latter appears in the runtime as <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/proc.go#L134-L135"><code class="language-plaintext highlighter-rouge">main_main</code></a>.</p>

<p>The main thread then calls <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/proc.go#L1769-L1769"><code class="language-plaintext highlighter-rouge">mstart</code></a> to begin execution on <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/proc.go#L117-L117"><code class="language-plaintext highlighter-rouge">M0</code></a>, starting the <a href="#schedule-loop">schedule loop</a> to pick up and execute the main goroutine.
In the <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/proc.go#L146-L148"><code class="language-plaintext highlighter-rouge">runtime.main</code></a>, after additional initialization steps, control is finally handed off to the user-defined <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/proc.go#L134-L135"><code class="language-plaintext highlighter-rouge">main_main</code></a> function, where the program begins executing Go code that we write.</p>

<p>It‚Äôs worth noting that the main thread, <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/proc.go#L117-L117"><code class="language-plaintext highlighter-rouge">M0</code></a>, is responsible not only for running the main goroutine but also for executing other goroutines.
Whenever the main goroutine is blocked‚Äîsuch as waiting for a system call or while waiting on a channel‚Äîthe main thread looks for another runnable goroutine and execute it.</p>

<p>Summing it up, when the program starts, there is one goroutine <code class="language-plaintext highlighter-rouge">G</code> executing the <code class="language-plaintext highlighter-rouge">main</code> function; two threads‚Äîone is the main thread <code class="language-plaintext highlighter-rouge">M0</code>, and the other is created to launch <code class="language-plaintext highlighter-rouge">sysmon</code>; one processor <code class="language-plaintext highlighter-rouge">P0</code> in <em>running</em> state, and <code class="language-plaintext highlighter-rouge">GOMAXPROCS‚àí1</code> processors in <em>idle</em> state.
The main thread <code class="language-plaintext highlighter-rouge">M0</code> is initially associated with processor <code class="language-plaintext highlighter-rouge">P0</code> to run the main goroutine <code class="language-plaintext highlighter-rouge">G</code>.</p>

<p>The figure below illustrates the program‚Äôs state at startup.
It assumes that <a href="https://pkg.go.dev/runtime#GOMAXPROCS"><code class="language-plaintext highlighter-rouge">GOMAXPROCS</code></a> is set to 2 and that the <code class="language-plaintext highlighter-rouge">main</code> function has just started.
Processor <code class="language-plaintext highlighter-rouge">P0</code> is executing the main goroutine and is therefore in <em>running</em> state.
Processor <code class="language-plaintext highlighter-rouge">P1</code> is not executing any goroutine and is in <em>idle</em> state.
While the main thread <code class="language-plaintext highlighter-rouge">M0</code> is associated with processor <code class="language-plaintext highlighter-rouge">P0</code> to execute main goroutine, another thread <code class="language-plaintext highlighter-rouge">M1</code> is created to run <code class="language-plaintext highlighter-rouge">sysmon</code>.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center"><img src="/assets/2025-03-11-go-scheduling/program_bootstrap.png" width="500" /></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">Program bootstrap in GMP model</td>
    </tr>
  </tbody>
</table>

<h2 id="creating-goroutine">Creating Goroutine</h2>

<p>Go offers us a simple API to start a concurrent execution unit: <code class="language-plaintext highlighter-rouge">go func() { ... } ()</code>.
Under the hood, Go runtime does a lot complicated work to make it happen.
The <code class="language-plaintext highlighter-rouge">go</code> keyword is just a syntactic sugar for Go runtime <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/proc.go#L5014-L5030"><code class="language-plaintext highlighter-rouge">newproc</code></a> function, which is responsible for scheduling a new goroutine.
This function essentially does 3 things: initialize the goroutine, put it into the run queue of the processor <code class="language-plaintext highlighter-rouge">P</code> which the caller goroutine is running on, wake up another processor <code class="language-plaintext highlighter-rouge">P1</code>.</p>

<h3 id="initializing-goroutine">Initializing Goroutine</h3>

<p>When <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/proc.go#L5014-L5030"><code class="language-plaintext highlighter-rouge">newproc</code></a> is called, it creates a new goroutine <code class="language-plaintext highlighter-rouge">G</code> only if there are no idle goroutines available.
Goroutines become idle after they return from execution.
The newly created goroutine <code class="language-plaintext highlighter-rouge">G</code> is initialized with a 2KB stack, as defined by the <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/stack.go#L75-L75"><code class="language-plaintext highlighter-rouge">stackMin</code></a> constant in Go runtime.
Additionally, <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/stubs.go#L281-L291"><code class="language-plaintext highlighter-rouge">goexit</code></a>‚Äîwhich handles cleanup logic and scheduling logic‚Äîis pushed onto <code class="language-plaintext highlighter-rouge">G</code>‚Äôs call stack to ensure it is executed when <code class="language-plaintext highlighter-rouge">G</code> returns.
After initialization, <code class="language-plaintext highlighter-rouge">G</code> transitions from <em>dead</em> state to <em>runnable</em> state, indicating that it‚Äôs ready to be scheduled for execution.</p>

<h3 id="putting-goroutine-into-queue">Putting Goroutine into Queue</h3>

<p>As mentioned earlier, each processor <code class="language-plaintext highlighter-rouge">P</code> has a run queue composed of two parts: <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/runtime2.go#L655-L667"><code class="language-plaintext highlighter-rouge">runnext</code></a> and <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/runtime2.go#L654-L654"><code class="language-plaintext highlighter-rouge">runq</code></a>.
When a new goroutine is created, it is placed in <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/runtime2.go#L655-L667"><code class="language-plaintext highlighter-rouge">runnext</code></a>.
If <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/runtime2.go#L655-L667"><code class="language-plaintext highlighter-rouge">runnext</code></a> already contains a goroutine <code class="language-plaintext highlighter-rouge">G1</code>, the thread attempts to move <code class="language-plaintext highlighter-rouge">G1</code> to <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/runtime2.go#L654-L654"><code class="language-plaintext highlighter-rouge">runq</code></a>‚Äîprovided <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/runtime2.go#L654-L654"><code class="language-plaintext highlighter-rouge">runq</code></a> is not full‚Äîand put <code class="language-plaintext highlighter-rouge">G</code> into <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/runtime2.go#L655-L667"><code class="language-plaintext highlighter-rouge">runnext</code></a>.
If <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/runtime2.go#L654-L654"><code class="language-plaintext highlighter-rouge">runq</code></a> is full, <code class="language-plaintext highlighter-rouge">G1</code> along with half of the goroutines in <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/runtime2.go#L654-L654"><code class="language-plaintext highlighter-rouge">runq</code></a> are moved to the global run queue to reduce the workload for <code class="language-plaintext highlighter-rouge">P</code>.</p>

<h3 id="waking-up-processor">Waking Up Processor</h3>

<p>When a new goroutine is created, and we aim to maximize program concurrency, the thread which goroutine is running on attempts to wake up another processor <code class="language-plaintext highlighter-rouge">P</code> by <a href="https://man7.org/linux/man-pages/man2/futex.2.html"><code class="language-plaintext highlighter-rouge">futex</code></a> system call. 
To do this, it first checks for any idle processors.
If an idle processor <code class="language-plaintext highlighter-rouge">P</code> is available, a new thread is either created or an existing one is woken up to enter the <a href="#schedule-loop">schedule loop</a>, where it will look for a runnable goroutine to execute.
The logic for creating or reusing thread is described in <a href="#start-thread-startm">Start Thread</a> section.</p>

<p>As previously mentioned, <a href="https://pkg.go.dev/runtime#GOMAXPROCS"><code class="language-plaintext highlighter-rouge">GOMAXPROCS</code></a>‚Äîthe number of active processors <code class="language-plaintext highlighter-rouge">P</code>‚Äîdictates how many goroutines can run concurrently.
If all processors are busy and new goroutines keep spawning, neither existing thread is woken up nor new thread is created.</p>

<h3 id="putting-it-all-together">Putting It All Together</h3>

<p>The figure below illustrates the process of how goroutines are created.
For simplicity, it assumes <a href="https://pkg.go.dev/runtime#GOMAXPROCS"><code class="language-plaintext highlighter-rouge">GOMAXPROCS</code></a> is set to 2, processor <code class="language-plaintext highlighter-rouge">P1</code> hasn‚Äôt entered the <a href="#schedule-loop">schedule loop</a> yet, and <code class="language-plaintext highlighter-rouge">main</code> function does nothing but keeps spawning new goroutines.
Since goroutines don‚Äôt execute system call (discussed in <a href="#handling-system-calls">Handling System Calls</a> section), there is exactly one additional thread <code class="language-plaintext highlighter-rouge">M2</code> is created to associate with processor <code class="language-plaintext highlighter-rouge">P1</code>.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center"><img src="/assets/2025-03-11-go-scheduling/creating_goroutine.png" /></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">How goroutines are created in GMP model</td>
    </tr>
  </tbody>
</table>

<h2 id="schedule-loop">Schedule Loop</h2>

<p>The <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/proc.go#L3986-L4068"><code class="language-plaintext highlighter-rouge">schedule</code></a> function in the Go runtime is responsible for finding and executing a runnable goroutine.
It is invoked in various scenarios: when a new thread is created, when <a href="https://pkg.go.dev/runtime#Gosched"><code class="language-plaintext highlighter-rouge">Gosched</code></a> is called, when a goroutine is parked or preempted, or after a goroutine completes a system call and returns.</p>

<p>The process of selecting a runnable goroutine is complex and will be detailed in the <a href="#finding-a-runnable-goroutine">Finding a Runnable Goroutine</a> section.
Once a goroutine is selected, it transitions from <em>runnable</em> to <em>running</em> state, signaling that it‚Äôs ready to run.
At this point, a kernel thread invokes the <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/stubs.go#L214-L214"><code class="language-plaintext highlighter-rouge">gogo</code></a> function to begin goroutine execution.</p>

<p>But why is it called a <em>loop</em>? As described in the <a href="#initializing-goroutine">Initializing Goroutine</a> section, when a goroutine completes, the <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/stubs.go#L281-L291"><code class="language-plaintext highlighter-rouge">goexit</code></a> function is invoked.
This function eventually leads to a call to <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/proc.go#L4307-L4310"><code class="language-plaintext highlighter-rouge">goexit0</code></a>, which performs cleanup for the terminating goroutine and re-enters the <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/proc.go#L3986-L4068"><code class="language-plaintext highlighter-rouge">schedule</code></a> function‚Äîbringing the <a href="#schedule-loop">schedule loop</a> back.</p>

<p>The following diagram illustrates the schedule loop in Go runtime, where <span style="color:#c71585">pink</span> blocks happen in user Go code and <span style="color:#ffd700">yellow</span> blocks happen in the Go runtime code.
Although the following may seem obvious, please note that the schedule loop is executed by thread.
That‚Äôs why it happens after thread initialization (the <span style="color:#0056b3">blue</span> block).</p>

<table>
    <thead>
        <tr>
            <td>
                <pre class="mermaid" style="margin: unset">

graph LR
    subgraph Thread_Init[&amp;nbsp]
    newm["newm()"] ==&gt; mstart["mstart()"]
    mstart ==&gt; mstart0["mstart0()"]
    mstart0 ==&gt; mstart1["mstart1()"]
    end
    mstart1 ==&gt; schedule["schedule()"]
    schedule ==&gt; findrunnable["findrunnable()<br />Find a runnable goroutine"]
    findrunnable ==&gt; execute["execute()"]
    execute ==&gt; gogo["gogo()<br />Execute a goroutine"]
    gogo ==&gt; |Goroutine executes code and returns|goexit["goexit()"]
    gogo ==&gt; |Goroutine executes<br />system call|entersyscall["entersyscall()"]
    entersyscall ==&gt; exitsyscall["exitsyscall()"]
    exitsyscall ==&gt; schedule
    goexit ==&gt; goexit1["goexit1()"]
    goexit1 ==&gt; goexit0["goexit0()"]
    goexit0 ==&gt; schedule
    style Thread_Init fill:#bfdfff

                </pre>
            </td>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td style="text-align: center">
                The schedule loop in Go runtime
            </td>
        </tr>
    </tbody>
</table>

<p>But if main thread is stuck in the scheduling loop, how can the process exit?
Just take a look at the <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/proc.go#L307-L307"><code class="language-plaintext highlighter-rouge">main</code></a> function in Go runtime, which is executed by main goroutine.
After <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/proc.go#L134-L135"><code class="language-plaintext highlighter-rouge">main_main</code></a>‚Äîalias of the <code class="language-plaintext highlighter-rouge">main</code> function that Go programmers write‚Äîreturns, <a href="https://man7.org/linux/man-pages/man3/exit.3.html"><code class="language-plaintext highlighter-rouge">exit</code></a> system call is invoked to terminate the process.
That‚Äôs how the process can exit and the reason why the main goroutine doesn‚Äôt wait for goroutines spawned by <code class="language-plaintext highlighter-rouge">go</code> keyword.</p>

<h2 id="finding-a-runnable-goroutine">Finding a Runnable Goroutine</h2>

<p>It is the thread <code class="language-plaintext highlighter-rouge">M</code>‚Äôs responsibility to find a suitable runnable goroutine so that goroutine starvation can be minimized.
This logic is implemented in the <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/proc.go#L3267-L3646"><code class="language-plaintext highlighter-rouge">findRunnable</code></a>, which is called by the <a href="#schedule-loop">schedule loop</a>.</p>

<p>The thread <code class="language-plaintext highlighter-rouge">M</code> looks for a runnable goroutine the following order, stop the chain if it finds one:</p>
<ol>
  <li>Check <a href="https://go.dev/blog/execution-traces-2024#trace-reader-api">trace reader</a> goroutine‚Äôs availability (used in <a href="#non-cooperative-preemption">Non-cooperative Preemption</a> section).</li>
  <li>Check garbage collection worker goroutine‚Äôs availability (described in <a href="#garbage-collector">Garbage Collector</a> section).</li>
  <li>1/61 of the time, check the global run queue.</li>
  <li>Check local run queue of the associated processor <code class="language-plaintext highlighter-rouge">P</code> if <code class="language-plaintext highlighter-rouge">M</code> is spinning.</li>
  <li>Check the global run queue again.</li>
  <li>Check netpoll for I/O ready goroutine (described in <a href="#network-io-and-file-io">Network I/O and File I/O</a> section).</li>
  <li>Steal from other processors <code class="language-plaintext highlighter-rouge">P1</code>‚Äôs local run queue.</li>
  <li>Check garbage collection worker goroutine‚Äôs availability again.</li>
  <li>Check the global run queue again if <code class="language-plaintext highlighter-rouge">M</code> is spinning.</li>
</ol>

<p>Step 1, 2 and 8 are for Go runtime internal use only.
In step 1, trace reader is used for tracing the execution of the program.
You will see how it‚Äôs used in the <a href="#goroutine-preemption">Goroutine Preemption</a> section later.
Meanwhile, step 2 and 8 allow the garbage collector to run concurrently with the regular goroutines.
Although these steps don‚Äôt contribute to ‚Äúuser-visible‚Äù progress, they are essential for the Go runtime to function properly.</p>

<p>Step 3, 5 and 9 don‚Äôt just take one goroutine but attempts to grab a batch for better efficiency.
The batch size is calculated as <code class="language-plaintext highlighter-rouge">(global_queue_size/number_of_processors)+1</code>, but it‚Äôs limited by several factors: it won‚Äôt exceed the specified maximum parameter, and won‚Äôt take more than half of the P‚Äôs local queue capacity.
After determining how many to take, it pops one goroutine to return directly (which will be run immediately) and puts the rest into the P‚Äôs local run queue.
This batching approach helps with load balancing across processors and reduces contention on the global queue lock, as processors don‚Äôt need to access the global queue as frequently.</p>

<p>Step 4 is a bit more tricky because the local run queue of <code class="language-plaintext highlighter-rouge">P</code> contains two parts: <code class="language-plaintext highlighter-rouge">runnext</code> and <code class="language-plaintext highlighter-rouge">runq</code>.
If <code class="language-plaintext highlighter-rouge">runnext</code> is not empty, it returns the goroutine in <code class="language-plaintext highlighter-rouge">runnext</code>.
Otherwise, it checks <code class="language-plaintext highlighter-rouge">runq</code> for any runnable goroutine and dequeue it.
Step 6 will be described in detail in <a href="#how-netpoll-works">How netpoll Works</a> section.</p>

<p>Step 7 is the most complex part of the process.
It attempts up to four times to steal work from another processor, referred to as <code class="language-plaintext highlighter-rouge">P1</code>.
During the first three attempts, it tries to steal goroutines only from <code class="language-plaintext highlighter-rouge">P1</code>‚Äôs <code class="language-plaintext highlighter-rouge">runq</code>. 
If successful, half of the goroutines from <code class="language-plaintext highlighter-rouge">P1</code>‚Äôs <code class="language-plaintext highlighter-rouge">runq</code> are transferred to the current processor <code class="language-plaintext highlighter-rouge">P</code>‚Äôs <code class="language-plaintext highlighter-rouge">runq</code>.
On the last attempt, it first tries to steal from <code class="language-plaintext highlighter-rouge">P1</code>‚Äôs <code class="language-plaintext highlighter-rouge">runnext</code> slot‚Äîif available‚Äîbefore falling back to <code class="language-plaintext highlighter-rouge">P1</code>‚Äôs <code class="language-plaintext highlighter-rouge">runq</code>.</p>

<p>Note that <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/proc.go#L3267-L3646"><code class="language-plaintext highlighter-rouge">findRunnable</code></a> not only finds a runnable goroutine but also wakes up goroutine that went into sleep before step 1 happens.
Once the goroutine wakes up, it‚Äôll be put into the local run queue of the processor <code class="language-plaintext highlighter-rouge">P</code> that was executing it, waiting to be picked up and executed by some thread <code class="language-plaintext highlighter-rouge">M</code>.</p>

<p>If no goroutine is found after step 9, the thread <code class="language-plaintext highlighter-rouge">M</code> waits on <code class="language-plaintext highlighter-rouge">netpoll</code> until the nearest <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/time.go#L35-L107">timer</a> expires‚Äîsuch as when a goroutine wakes up from sleep (since sleeping in Go internally creates a timer).
Why is <code class="language-plaintext highlighter-rouge">netpoll</code> involved with timers? This is because Go‚Äôs timer system heavily relies on <code class="language-plaintext highlighter-rouge">netpoll</code>, as noted in <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/time.go#L427-L427">this</a> code comment.
After <code class="language-plaintext highlighter-rouge">netpoll</code> returns, <code class="language-plaintext highlighter-rouge">M</code> re-enters the <a href="#schedule-loop">schedule loop</a> to search for a runnable goroutine again.</p>

<p>The previous two behaviors of <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/proc.go#L3267-L3646"><code class="language-plaintext highlighter-rouge">findRunnable</code></a> allows the Go scheduler to wake up asleep goroutines, allowing the program to continue executing.
They explain why every goroutine including the main one has chance to run after falling asleep.
Let‚Äôs see how it works in another post üòÑ.</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="s">"time"</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">go</span> <span class="k">func</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">time</span><span class="o">.</span><span class="n">Sleep</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">Second</span><span class="p">)</span>
    <span class="p">}()</span>
	
    <span class="n">time</span><span class="o">.</span><span class="n">Sleep</span><span class="p">(</span><span class="m">2</span><span class="o">*</span><span class="n">time</span><span class="o">.</span><span class="n">Second</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>If <code class="language-plaintext highlighter-rouge">P</code> has no <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/time.go#L35-L107">timer</a>, its corresponding thread <code class="language-plaintext highlighter-rouge">M</code> will go idle.
<code class="language-plaintext highlighter-rouge">P</code> is placed into idle list, <code class="language-plaintext highlighter-rouge">M</code> goes to sleep by calling the <a href="#stop-thread-stopm"><code class="language-plaintext highlighter-rouge">stopm</code></a> function.
It remains asleep until another <code class="language-plaintext highlighter-rouge">M1</code> thread  wakes it up, typically upon the creation of a new goroutine, as explained in <a href="#waking-up-processor">Waking Up Processor</a>.
Once awakened, <code class="language-plaintext highlighter-rouge">M</code> reenters the <a href="#schedule-loop">schedule loop</a> to search for and execute a runnable goroutine.</p>

<h2 id="goroutine-preemption">Goroutine Preemption</h2>

<p>Preemption is the act of temporarily interrupting a goroutine execution to allow other goroutines to run, preventing goroutine starvation.
There are two types of preemption in Go:</p>

<ul>
  <li>Non-cooperative preemption: a too long-running goroutine is forced to stop.</li>
  <li>Cooperative preemption: a goroutine voluntarily yields its processor <code class="language-plaintext highlighter-rouge">P</code>.</li>
</ul>

<p>Let‚Äôs see how these two types of preemption work in Go.</p>

<h3 id="non-cooperative-preemption">Non-cooperative Preemption</h3>

<p>Let‚Äôs take an example to understand how non-cooperative preemption works.
In this program, we have two goroutines that calculate the Fibonacci number, which is a tight loop with CPU intensive operations.
In order to make sure that only one goroutine can run at a time, we set the maximum number of logical processors to 1 using <a href="https://pkg.go.dev/runtime#GOMAXPROCS"><code class="language-plaintext highlighter-rouge">GOMAXPROCS</code></a> when running the program: <code class="language-plaintext highlighter-rouge">GOMAXPROCS=1 go run main.go</code>.</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="p">(</span>
    <span class="s">"runtime"</span>
    <span class="s">"time"</span>
<span class="p">)</span>

<span class="k">func</span> <span class="n">fibonacci</span><span class="p">(</span><span class="n">n</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="m">1</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">n</span>
    <span class="p">}</span>   
    <span class="n">previous</span><span class="p">,</span> <span class="n">current</span> <span class="o">:=</span> <span class="m">0</span><span class="p">,</span> <span class="m">1</span>
    <span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="m">2</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
        <span class="n">previous</span><span class="p">,</span> <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="p">,</span> <span class="n">previous</span><span class="o">+</span><span class="n">current</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">current</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">go</span> <span class="n">fibonacci</span><span class="p">(</span><span class="m">1</span><span class="n">_000_000_000</span><span class="p">)</span>
    <span class="k">go</span> <span class="n">fibonacci</span><span class="p">(</span><span class="m">2</span><span class="n">_000_000_000</span><span class="p">)</span>

    <span class="n">time</span><span class="o">.</span><span class="n">Sleep</span><span class="p">(</span><span class="m">3</span><span class="o">*</span><span class="n">time</span><span class="o">.</span><span class="n">Second</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Because there is exactly one processor <code class="language-plaintext highlighter-rouge">P</code>, there are many cases that could happen. 
One, neither goroutine runs because the main function has taken control of <code class="language-plaintext highlighter-rouge">P</code>.
Two, one goroutine runs while the other is starved of execution.
Three, somehow both goroutines run concurrently‚Äîalmost magically.</p>

<p>Fortunately, Go does support us to get the idea of what is happening with the scheduling.
The <a href="https://go.dev/pkg/runtime/trace">runtime/trace</a> package contains a powerful tool for understanding and troubleshooting Go programs.
To use it, we need to add instrument to the <code class="language-plaintext highlighter-rouge">main</code> method to export the traces to file.</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">file</span><span class="p">,</span> <span class="n">_</span> <span class="o">:=</span> <span class="n">os</span><span class="o">.</span><span class="n">Create</span><span class="p">(</span><span class="s">"trace.out"</span><span class="p">)</span>
    <span class="n">_</span> <span class="o">=</span> <span class="n">trace</span><span class="o">.</span><span class="n">Start</span><span class="p">(</span><span class="n">file</span><span class="p">)</span>
    <span class="k">defer</span> <span class="n">trace</span><span class="o">.</span><span class="n">Stop</span><span class="p">()</span>
    <span class="o">...</span>
<span class="p">}</span>
</code></pre></div></div>

<p>After the program finishes running, we use the command <code class="language-plaintext highlighter-rouge">go tool trace trace.out</code> to visualize the trace.
I have prepared the <code class="language-plaintext highlighter-rouge">trace.out</code> file <a href="/assets/2025-03-11-go-scheduling/non_cooperative_preempt_trace.out">here</a> just in case you want to play with it.
In the figure below, the horizontal axis represents which goroutine is running on <code class="language-plaintext highlighter-rouge">P</code> at a given time.
As expected, there is only one logical processor <code class="language-plaintext highlighter-rouge">P</code> named ‚ÄúProc 0‚Äù, resulted from <code class="language-plaintext highlighter-rouge">GOMAXPROCS=1</code>.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center"><img src="/assets/2025-03-11-go-scheduling/runtime_trace_start.png" /></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">Trace visualization when program starts</td>
    </tr>
  </tbody>
</table>

<p>By zooming in (pressing ‚ÄòW‚Äô) to the start of the timeline, you can see that the process begins with <code class="language-plaintext highlighter-rouge">main.main</code> (the <code class="language-plaintext highlighter-rouge">main</code> function in the <code class="language-plaintext highlighter-rouge">main</code> package), which runs on the main goroutine, G1.
After a few microseconds, still on Proc 0, goroutine G10 is scheduled to execute the <code class="language-plaintext highlighter-rouge">fibonacci</code> function, taking over the processor and preempting G1.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center"><img src="/assets/2025-03-11-go-scheduling/runtime_trace_preempt.png" /></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">Trace visualization when non-cooperative preemption happens</td>
    </tr>
  </tbody>
</table>

<p>By zooming out (pressing ‚ÄòS‚Äô) and scrolling slightly to the right, it can be observed that G10 is later replaced by another goroutine, G9, which is the next instance running the <code class="language-plaintext highlighter-rouge">fibonacci</code> function.
This goroutine is also executed on Proc 0. Pay attention to <code class="language-plaintext highlighter-rouge">runtime.asyncPreempt:47</code> in the figure, I will explain this in a moment.</p>

<p>From the demo, it can be concluded that the Go is capable of preempting goroutines that are CPU-bound.
But why is it possible because if a goroutines continuously taking up the CPU, how can it be preempted?
This is a hard problem and there was a long <a href="https://github.com/golang/go/issues/10958">discussion</a> on the Go issue tracker.
The problem was not addressed until Go 1.14, where asynchronous preemption was firstly introduced.</p>

<p>In Go runtime, there is a daemon running on a dedicated thread <code class="language-plaintext highlighter-rouge">M</code> without a <code class="language-plaintext highlighter-rouge">P</code>, called <code class="language-plaintext highlighter-rouge">sysmon</code> (i.e. system monitor). 
When <code class="language-plaintext highlighter-rouge">sysmon</code> finds a goroutine that has been using <code class="language-plaintext highlighter-rouge">P</code> for more than 10ms (<a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/proc.go#L6245-L6245"><code class="language-plaintext highlighter-rouge">forcePreemptNS</code></a> constant in Go runtime), it signals thread <code class="language-plaintext highlighter-rouge">M</code> by executing <a href="https://man7.org/linux/man-pages/man2/tkill.2.html"><code class="language-plaintext highlighter-rouge">tgkill</code></a> system call to forcefully preempt the running goroutine.
Yes, you didn‚Äôt read that wrong. According to the <a href="https://man7.org/linux/man-pages/man2/tkill.2.html">Linux manual page</a>, <a href="https://man7.org/linux/man-pages/man2/tkill.2.html"><code class="language-plaintext highlighter-rouge">tgkill</code></a> is used to send a signal to a thread, not to kill a thread.
The signal is <code class="language-plaintext highlighter-rouge">SIGURG</code>, and the reason it being chosen is described <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/signal_unix.go#L43-L73">here</a>.</p>

<p>Upon receiving <code class="language-plaintext highlighter-rouge">SIGURG</code>, the execution of the program is transferred to the signal handler, registered by a call of <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/proc.go#L1879-L1879"><code class="language-plaintext highlighter-rouge">initsig</code></a> function upon thread initialization.
Note that the signal handler can run concurrently with goroutines or the scheduling, as depicted in the figure below.
The execution switch from main program to signal handler is triggered by the kernel<a href="https://stackoverflow.com/questions/6949025/how-are-asynchronous-signal-handlers-executed-on-linux/"><sup>4,</sup></a><a href="https://unix.stackexchange.com/questions/733013/how-is-a-signal-delivered-in-linux"><sup>5</sup></a>.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center"><img src="/assets/2025-03-11-go-scheduling/signal_delivery_and_handler_execution.png" width="500" /></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">Signal delivery and handler execution<sup>6</sup></td>
    </tr>
  </tbody>
</table>

<p>In the signal handler, the program counter is set to the <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/preempt.go#L295-L299"><code class="language-plaintext highlighter-rouge">asyncPreempt</code></a> function, allowing the goroutine to be suspended and creating space for preemption.
<a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/preempt_arm64.s"><code class="language-plaintext highlighter-rouge">asyncPreempt</code></a> function, which is implemented in assembly, saves the goroutine‚Äôs registers and call <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/preempt.go#L302-L311"><code class="language-plaintext highlighter-rouge">asyncPreempt2</code></a> function at line <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/preempt_arm64.s#L47">47</a>.
That is reason for the appearance of <code class="language-plaintext highlighter-rouge">runtime.asyncPreempt:47</code> in the visualization.
In <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/preempt.go#L302-L311"><code class="language-plaintext highlighter-rouge">asyncPreempt2</code></a>, the goroutine <code class="language-plaintext highlighter-rouge">g0</code> of thread <code class="language-plaintext highlighter-rouge">M</code> will enter <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/proc.go#L4191-L4193"><code class="language-plaintext highlighter-rouge">gopreempt_m</code></a> to disassociate goroutine <code class="language-plaintext highlighter-rouge">G</code> from <code class="language-plaintext highlighter-rouge">M</code> and enqueue <code class="language-plaintext highlighter-rouge">G</code> into the global run queue.
The thread then continues with the <a href="#schedule-loop">schedule loop</a>, finding another runnable goroutine and execute it.</p>

<p>As preemption signal is triggered by <code class="language-plaintext highlighter-rouge">sysmon</code> but the actual preemption doesn‚Äôt happen until the thread receives preemption signal, this kind of preemption is asynchronous.
That‚Äôs why goroutines can actually run beyond the time limit 10ms, like goroutine G9 in the example.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center"><img src="/assets/2025-03-11-go-scheduling/non_cooperative_preemption.png" width="600" /></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">Non-cooperative preemption in GMP model</td>
    </tr>
  </tbody>
</table>

<h3 id="cooperative-preemption-in-early-go">Cooperative Preemption in Early Go</h3>

<p>In the early days of Go, Go runtime itself was not able to preempt a goroutines that have tight loop like the example above.
We, the programmers, had to tell the goroutine to cooperatively give up the processor <code class="language-plaintext highlighter-rouge">P</code> by calling <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/proc.go#L358-L365"><code class="language-plaintext highlighter-rouge">runtime.Gosched()</code></a> in the loop body.
There was a Stackoverflow <a href="https://stackoverflow.com/questions/13107958/what-exactly-does-runtime-gosched-do">question</a> that described an example and the behavior of <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/proc.go#L358-L365"><code class="language-plaintext highlighter-rouge">runtime.Gosched()</code></a>.</p>

<p>From the programmer‚Äôs point of view, this is very tedious and error-prone, and it did have some performance <a href="https://github.com/golang/go/issues/12553">issue</a> in actuality.
Therefore, the Go team has decided to implement a clever way to preempt the goroutine by the runtime itself.
This will be discussed in the next section.</p>

<h3 id="cooperative-preemption-since-go-114">Cooperative Preemption Since Go 1.14</h3>

<p>Do you wonder why I didn‚Äôt use <code class="language-plaintext highlighter-rouge">fmt.Printf</code> in each iteration and check the terminal to see whether both goroutines have chance to run?
That‚Äôs because if I had done that, it would have become a cooperative preemption, not a non-cooperative preemption anymore.</p>

<h4 id="disassemble-the-program">Disassemble the Program</h4>
<p>To better understand this, let‚Äôs compile the program and analyze its assembly code.
Since the Go compiler applies various optimizations that can make debugging more challenging, we need to disable them when building the program.
This can be done by <code class="language-plaintext highlighter-rouge">go build -gcflags="all=-N -l" -o fibonacci main.go</code>.</p>

<p>For easier debugging, I use <a href="https://github.com/go-delve/delve">Delve</a>, a powerful debugger for Go, to disassemble the <code class="language-plaintext highlighter-rouge">fibonacci</code> function: <code class="language-plaintext highlighter-rouge">dlv exec ./fibonacci</code>.
Once inside the debugger, I run the following command to view the assembly code of the <code class="language-plaintext highlighter-rouge">fibonacci</code> function: <code class="language-plaintext highlighter-rouge">disassemble -l main.fibonacci</code>.
You can find the assembly code of the original program <a href="/assets/2025-03-11-go-scheduling/non_cooperative_preempt.s">here</a>.
As I‚Äôm building the program on my local machine, which is darwin/arm64, the assembly code built on your machine could be different from mine.</p>

<p>That‚Äôs all set, let‚Äôs take a look at the assembly of the <code class="language-plaintext highlighter-rouge">fibonacci</code> function to see what it does.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>      main.go:11      0x1023e8890     900b40f9        MOVD 16(R28), R16
      main.go:11      0x1023e8894     f1c300d1        SUB $48, RSP, R17
      main.go:11      0x1023e8898     3f0210eb        CMP R16, R17
      main.go:11      0x1023e889c     090c0054        BLS 96(PC)
      ...
      main.go:17      0x1023e8910     6078fd97        CALL runtime.convT64(SB)
      ...
      main.go:17      0x1023e895c     4d78fd97        CALL runtime.convT64(SB)
      ...
      main.go:20      0x1023e8a18     c0035fd6        RET
      main.go:11      0x1023e8a1c     e00700f9        MOVD R0, 8(RSP)
      main.go:11      0x1023e8a20     e3031eaa        MOVD R30, R3
      main.go:11      0x1023e8a24     dbe7fe97        CALL runtime.morestack_noctxt(SB)
      main.go:11      0x1023e8a28     e00740f9        MOVD 8(RSP), R0
      main.go:11      0x1023e8a2c     99ffff17        JMP main.fibonacci(SB)
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">MOVD 16(R28), R16</code> loads the value at offset 16 from the register <code class="language-plaintext highlighter-rouge">R28</code>, which holds the goroutine data structure <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/runtime2.go#L396-L396"><code class="language-plaintext highlighter-rouge">g</code></a>, and store that value in register <code class="language-plaintext highlighter-rouge">R16</code>.
The loaded value is the <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/runtime2.go#L405-L405"><code class="language-plaintext highlighter-rouge">stackguard0</code></a> field, which serves as the stack guard for the current goroutine.
But what exactly is a stack guard? You may know that a goroutine‚Äôs stack is growable, but how does Go runtime determine when it needs to grow?
The stack guard is a special value placed at the end of the stack. When the stack pointer reaches this value, Go runtime detects that the stack is nearly full and needs to grow‚Äîthat‚Äôs exactly what the next three instructions do.</p>

<p><code class="language-plaintext highlighter-rouge">SUB $48, RSP, R17</code> loads the goroutine‚Äôs stack pointer from the register <code class="language-plaintext highlighter-rouge">RPS</code> to register <code class="language-plaintext highlighter-rouge">R17</code> and subtracts 48 from it.
<code class="language-plaintext highlighter-rouge">CMP R16, R17</code> compares the stack guard with the stack pointer, and <code class="language-plaintext highlighter-rouge">BLS 96(PC)</code> branches to the instruction located 96 instructions ahead in the program if the stack pointer is less than or equal to the stack guard.
Why less than or equal (‚â§) but not greater or equal (‚â•)?
Because stack grows downward, the stack pointer is always greater than the stack guard.</p>

<p>Have you ever wondered why these instructions don‚Äôt appear in the Go code but still show up in the assembly?
That‚Äôs because upon compiling, Go compiler automatically inserts these instructions in function <a href="https://en.wikipedia.org/wiki/Function_prologue_and_epilogue">prologue</a>.
This applies for every function like <code class="language-plaintext highlighter-rouge">fmt.Println</code>, not just our <code class="language-plaintext highlighter-rouge">fibonacci</code>.</p>

<p>After advancing 96 instructions, execution reaches the <code class="language-plaintext highlighter-rouge">MOVD R0, 8(RSP)</code> instruction and then proceeds to <code class="language-plaintext highlighter-rouge">CALL runtime.morestack_noctxt(SB)</code>.
<a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/asm_arm64.s#L348-L348"><code class="language-plaintext highlighter-rouge">runtime.morestack_noctxt</code></a> function will eventually call <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/stack.go#L966-L966"><code class="language-plaintext highlighter-rouge">newstack</code></a> to grow the stack and optionally enter <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/proc.go#L4191-L4193"><code class="language-plaintext highlighter-rouge">gopreempt_m</code></a> to trigger preemption as discussed in non-cooperative preemption.
The key point of cooperative preemption is the condition for entering <code class="language-plaintext highlighter-rouge">gopreempt_m</code>, which is <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/stack.go#L1025-L1025"><code class="language-plaintext highlighter-rouge">stackguard0 == stackPreempt</code></a>.
This means that whenever a goroutine wants to extend its stack, it will be preempted if its <code class="language-plaintext highlighter-rouge">stackguard0</code> was set to <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/stack.go#L128-L130"><code class="language-plaintext highlighter-rouge">stackPreempt</code></a> earlier.</p>

<p><a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/stack.go#L128-L130"><code class="language-plaintext highlighter-rouge">stackPreempt</code></a> can be set by the <code class="language-plaintext highlighter-rouge">sysmon</code> if a goroutine has been running for more than 10ms.
The goroutine will then be cooperatively preempted if it makes a function call or non-cooperatively preempted by the thread‚Äôs signal handler, whichever happens first.
It can also be set when the goroutine enters or exits a system call or during the tracing phase of the garbage collector.
See <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/proc.go#L6366-L6366">sysmon preemption</a>, <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/proc.go#L4525-L4525">syscall entry</a>/<a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/proc.go#L4663-L4663">exit</a>, <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/trace.go#L389-L389">garbage collector tracing</a>.</p>

<h4 id="trace-visualization">Trace Visualization</h4>

<p>Alright, let‚Äôs rerun the program‚Äîmake sure <code class="language-plaintext highlighter-rouge">GOMAXPROCS=1</code> is set‚Äîand then check out the trace.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center"><img src="/assets/2025-03-11-go-scheduling/runtime_trace_cooperative_preempt.png" /></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">Trace visualization when cooperative preemption happens</td>
    </tr>
  </tbody>
</table>

<p>You can clearly see that goroutines relinquish the logical processor after just tens of microseconds‚Äîunlike with non-cooperative preemption, where they might retain it for over 10 milliseconds.
Notably, G9‚Äôs stack trace ends at the <code class="language-plaintext highlighter-rouge">fmt.Printf</code> inside the loop body, demonstrating the stack guard check in function prologue.
This visualization precisely illustrates cooperative preemption, where goroutines <em>voluntarily</em> yield the processor.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center"><img src="/assets/2025-03-11-go-scheduling/cooperative_preemption.png" width="600" /></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">Cooperative preemption in GMP model</td>
    </tr>
  </tbody>
</table>

<h2 id="handling-system-calls">Handling System Calls</h2>

<p><a href="https://en.wikipedia.org/wiki/System_call">System calls</a> are services provided by the kernel that user-space applications access through an API.
These services include fundamental operations, for example, reading files, establishing connections, or allocating memory.
In Go, you rarely need to interact with system calls directly, as the standard library offers higher-level abstractions that simplify these tasks.</p>

<p>However, understanding how system calls work is crucial to gaining insight into Go runtime, standard library internals, as well as performance optimization.
Go‚Äôs runtime employs an M:N threading model, further optimized by the use of logical processors <code class="language-plaintext highlighter-rouge">P</code>, making its approach to handling system calls particularly interesting.</p>

<h3 id="system-call-classification">System Call Classification</h3>

<p>In Go runtime, there are two wrapper functions around kernel system calls: <a href="https://github.com/golang/go/blob/go1.24.0/src/syscall/syscall_linux.go#L54-L56"><code class="language-plaintext highlighter-rouge">RawSyscall</code></a> and <a href="https://github.com/golang/go/blob/go1.24.0/src/syscall/syscall_linux.go#L72-L89"><code class="language-plaintext highlighter-rouge">Syscall</code></a>.
The Go code we write uses these functions to invoke system calls. Each function accepts a system call number, its arguments, and returns values along with an error code.</p>

<p><a href="https://github.com/golang/go/blob/go1.24.0/src/syscall/syscall_linux.go#L72-L89"><code class="language-plaintext highlighter-rouge">Syscall</code></a> is typically used for operations with unpredictable durations, such as reading from a file or writing an HTTP response.
Since the duration of these operations is non-deterministic, Go runtime needs to account for them to ensure efficient use of resources.
The function coordinates goroutines <code class="language-plaintext highlighter-rouge">G</code>, threads <code class="language-plaintext highlighter-rouge">M</code>, and processors <code class="language-plaintext highlighter-rouge">P</code>, allowing the Go runtime to maintain performance and responsiveness during blocking system calls.</p>

<p>Nevertheless, not all system calls are unpredictable. For example, retrieving the process ID or getting the current time is usually quick and consistent. For these types of operations, <a href="https://github.com/golang/go/blob/go1.24.0/src/syscall/syscall_linux.go#L54-L56"><code class="language-plaintext highlighter-rouge">RawSyscall</code></a> is used.
Since no scheduling is involved, the association between goroutines <code class="language-plaintext highlighter-rouge">G</code>, threads <code class="language-plaintext highlighter-rouge">M</code>, and processors <code class="language-plaintext highlighter-rouge">P</code> remains intact when raw system calls are made.</p>

<p>Internally, <a href="https://github.com/golang/go/blob/go1.24.0/src/syscall/syscall_linux.go#L72-L89"><code class="language-plaintext highlighter-rouge">Syscall</code></a> delegates to <a href="https://github.com/golang/go/blob/go1.24.0/src/syscall/syscall_linux.go#L54-L56"><code class="language-plaintext highlighter-rouge">RawSyscall</code></a> to perform the actual system call, but wraps it with additional scheduling logic, which will be described in detail in the next section.</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">Syscall</span><span class="p">(</span><span class="n">trap</span><span class="p">,</span> <span class="n">a1</span><span class="p">,</span> <span class="n">a2</span><span class="p">,</span> <span class="n">a3</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="p">(</span><span class="n">r1</span><span class="p">,</span> <span class="n">r2</span> <span class="kt">uintptr</span><span class="p">,</span> <span class="n">err</span> <span class="n">Errno</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">runtime_entersyscall</span><span class="p">()</span>
    <span class="n">r1</span><span class="p">,</span> <span class="n">r2</span><span class="p">,</span> <span class="n">err</span> <span class="o">=</span> <span class="n">RawSyscall6</span><span class="p">(</span><span class="n">trap</span><span class="p">,</span> <span class="n">a1</span><span class="p">,</span> <span class="n">a2</span><span class="p">,</span> <span class="n">a3</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="m">0</span><span class="p">)</span>
    <span class="n">runtime_exitsyscall</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="scheduling-in-syscall">Scheduling in <code class="language-plaintext highlighter-rouge">Syscall</code></h3>

<p>The scheduling logic is implemented in <a href="https://github.com/golang/go/blob/go1.24.0/src/syscall/syscall_linux.go#L28-L29"><code class="language-plaintext highlighter-rouge">runtime_entersyscall</code></a> function and <a href="https://github.com/golang/go/blob/go1.24.0/src/syscall/syscall_linux.go#L31-L32"><code class="language-plaintext highlighter-rouge">runtime_exitsyscall</code></a> function, respectively before and after actual system call is made.
Under the hood, these functions are actually <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/proc.go#L4512-L4532"><code class="language-plaintext highlighter-rouge">runtime.entersyscall</code></a> and <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/proc.go#L4644-L4747"><code class="language-plaintext highlighter-rouge">runtime.exitsyscall</code></a>.
This association are created at compile time.</p>

<p>Before an actual system call is made, Go runtime records that the invoking goroutine is no longer using the CPU.
The goroutine <code class="language-plaintext highlighter-rouge">G</code> transitions from <em>running</em> state to <em>syscall</em> state, and its stack pointer, program counter, and frame pointer are saved for later restoration.
The association between thread <code class="language-plaintext highlighter-rouge">M</code> and processor <code class="language-plaintext highlighter-rouge">P</code> is temporarily detached, and <code class="language-plaintext highlighter-rouge">P</code> transitions to <em>syscall</em> state.
This logic is implemented in the <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/proc.go#L4413-L4510"><code class="language-plaintext highlighter-rouge">runtime.reentersyscall</code></a>, which is invoked by <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/proc.go#L4512-L4532"><code class="language-plaintext highlighter-rouge">runtime.entersyscall</code></a>.</p>

<p>Interestingly, the <code class="language-plaintext highlighter-rouge">sysmon</code> (as mentioned in the <a href="#non-cooperative-preemption">Non-cooperative Preemption</a> section) monitors not only processors running goroutine code (where <code class="language-plaintext highlighter-rouge">P</code> is in <em>running</em> state), but also those making system calls (where <code class="language-plaintext highlighter-rouge">P</code> is in <em>syscall</em> state).
If a <code class="language-plaintext highlighter-rouge">P</code> remains in <em>syscall</em> state for more than 10ms, instead of non-cooperatively preempting the running goroutine, a <a href="#processor-handoff-handoffp">processor handoff</a> takes place.
This keeps the association between goroutine <code class="language-plaintext highlighter-rouge">G</code> and thread <code class="language-plaintext highlighter-rouge">M</code>, and attaches another  thread <code class="language-plaintext highlighter-rouge">M1</code> to this <code class="language-plaintext highlighter-rouge">P</code>, allowing runnable goroutines to run on that <code class="language-plaintext highlighter-rouge">M1</code> thread.
Apparently, as <code class="language-plaintext highlighter-rouge">P</code> is now executing code, its status is running rather than syscall as before.</p>

<p>Note that while system call is still in progress and whether <code class="language-plaintext highlighter-rouge">sysmon</code> happens to seize <code class="language-plaintext highlighter-rouge">P</code> or not, the association between goroutine <code class="language-plaintext highlighter-rouge">G</code> and thread <code class="language-plaintext highlighter-rouge">M</code> still remains.
Why? Because the Go program (including Go runtime and Go code we write) are just user-space process.
The only mean of execution that kernel provides user-space process is thread.
It is the responsibility of thread to run Go runtime code, user Go code and make system call.
A thread <code class="language-plaintext highlighter-rouge">M</code> makes system call on behalf of some goroutine <code class="language-plaintext highlighter-rouge">G</code>, that‚Äôs why the association between them is maintained as-is.
Therefore, even if <code class="language-plaintext highlighter-rouge">P</code> is seized by <code class="language-plaintext highlighter-rouge">sysmon</code>, <code class="language-plaintext highlighter-rouge">M</code> remains blocked, waiting for the system call to complete before it can invoke the <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/proc.go#L4644-L4747"><code class="language-plaintext highlighter-rouge">runtime.exitsyscall</code></a> function.</p>

<p>Another important point is that whenever a processor <code class="language-plaintext highlighter-rouge">P</code> is in <em>syscall</em> state, <u>it can't be taken up by another thread M to execute code</u> until <code class="language-plaintext highlighter-rouge">sysmon</code> happens to seize it or until the system call is completed.
Therefore, in case there are multiple system calls happening at the same time, the program (excluding system calls) doesn‚Äôt make any progress.
That‚Äôs why <a href="https://docs.hypermode.com/dgraph/overview">Dgraph</a> database hardcodes <a href="https://pkg.go.dev/runtime#GOMAXPROCS"><code class="language-plaintext highlighter-rouge">GOMAXPROCS</code></a> to 128 to <a href="https://github.com/hypermodeinc/dgraph/blob/v24.1.2/dgraph/main.go#L33-L36">‚Äúallow more disk I/O calls to be scheduled‚Äù</a>.</p>

<p>As described in <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/proc.go#L4644-L4747"><code class="language-plaintext highlighter-rouge">runtime.exitsyscall</code></a>, there are two paths the scheduler can take after the syscall is finished: fast path and slow path.
The latter only takes place if the former is not possible.</p>

<p>The fast path occurs when if is a processor <code class="language-plaintext highlighter-rouge">P</code> available to execute the goroutine <code class="language-plaintext highlighter-rouge">G</code> that has just completed its system call.
This <code class="language-plaintext highlighter-rouge">P</code> can either be the same one that previously executed <code class="language-plaintext highlighter-rouge">G</code>, if it is still in the <em>syscall</em> state (i.e., it hasn‚Äôt been seized by <code class="language-plaintext highlighter-rouge">sysmon</code>), or any other processor <code class="language-plaintext highlighter-rouge">P1</code> currently in the <em>idle</em> state‚Äîwhichever is found first.<br />
Note that when system call completes, the previous process <code class="language-plaintext highlighter-rouge">P</code> might not be in <em>syscall</em> state anymore bcause <code class="language-plaintext highlighter-rouge">sysmon</code> has seized it.
Before the fast path exits, <code class="language-plaintext highlighter-rouge">G</code> transition from <em>syscall</em> state to <em>running</em> state.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center"><img src="/assets/2025-03-11-go-scheduling/syscall_fast_path_1.png" width="300" /></th>
      <th style="text-align: center"><img src="/assets/2025-03-11-go-scheduling/syscall_fast_path_2.png" width="500" /></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">System call fast path when <br /> <code class="language-plaintext highlighter-rouge">sysmon</code> doesn‚Äôt seize processor <code class="language-plaintext highlighter-rouge">P</code></td>
      <td style="text-align: center">System call fast path when <br /> <code class="language-plaintext highlighter-rouge">sysmon</code> seizes processor <code class="language-plaintext highlighter-rouge">P</code></td>
    </tr>
  </tbody>
</table>

<p>In the slow path, the scheduler tries retrieving any idle processor <code class="language-plaintext highlighter-rouge">P</code> once again.
If found, the goroutine <code class="language-plaintext highlighter-rouge">G</code> is scheduled to run on that <code class="language-plaintext highlighter-rouge">P</code>.
Otherwise, <code class="language-plaintext highlighter-rouge">G</code> is enqueued into the global run queue and the associated thread <code class="language-plaintext highlighter-rouge">M</code> is stopped by <a href="#stop-thread-stopm"><code class="language-plaintext highlighter-rouge">stopm</code></a> function, waiting to be woken up to continue the <a href="#schedule-loop">schedule loop</a>.</p>

<h2 id="network-io-and-file-io">Network I/O and File I/O</h2>

<p>This <a href="https://go.dev/blog/survey2024h2/what.svg">survey</a> shows that 75% of Go uses cases are web services and 45% are static websites.
It‚Äôs not a coincidence, Go is designed to be efficient for I/O operations to solve the notorious problem‚Äî<a href="https://en.wikipedia.org/wiki/C10k_problem">C10K</a>.
To see how Go solves it, let‚Äôs take a look at how Go handles I/O operations under the hood.</p>

<h3 id="http-server-under-the-hood">HTTP Server Under the Hood</h3>

<p>In Go, it‚Äôs incredibly straightforward to start an HTTP server. For example:</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="s">"net/http"</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">http</span><span class="o">.</span><span class="n">HandleFunc</span><span class="p">(</span><span class="s">"/"</span><span class="p">,</span> <span class="k">func</span><span class="p">(</span><span class="n">w</span> <span class="n">http</span><span class="o">.</span><span class="n">ResponseWriter</span><span class="p">,</span> <span class="n">r</span> <span class="o">*</span><span class="n">http</span><span class="o">.</span><span class="n">Request</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">w</span><span class="o">.</span><span class="n">WriteHeader</span><span class="p">(</span><span class="m">200</span><span class="p">)</span>
    <span class="p">})</span>
	
    <span class="n">http</span><span class="o">.</span><span class="n">ListenAndServe</span><span class="p">(</span><span class="s">":80"</span><span class="p">,</span> <span class="no">nil</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Functions like <code class="language-plaintext highlighter-rouge">http.ListenAndServe()</code> and <code class="language-plaintext highlighter-rouge">http.HandleFunc()</code> might seem deceptively simple‚Äîbut under the hood, they abstract away a lot of low-level networking complexity.
Go relies on fundamental <a href="https://en.wikipedia.org/wiki/Unix_domain_socket">socket</a> operations (depicted in the figure below) to manage network communication.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center"><img src="/assets/2025-03-11-go-scheduling/socket_system_calls_in_http_server.png" width="300" /></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">Overview of system calls used with stream sockets<sup>7</sup></td>
    </tr>
  </tbody>
</table>

<p>Specifically, <code class="language-plaintext highlighter-rouge">http.ListenAndServe()</code> leverages the following system calls: <a href="https://man7.org/linux/man-pages/man2/socket.2.html"><code class="language-plaintext highlighter-rouge">socket()</code></a>, <a href="https://man7.org/linux/man-pages/man2/bind.2.html"><code class="language-plaintext highlighter-rouge">bind()</code></a>, <a href="https://man7.org/linux/man-pages/man2/listen.2.html"><code class="language-plaintext highlighter-rouge">listen()</code></a>, <a href="https://man7.org/linux/man-pages/man2/accept.2.html"><code class="language-plaintext highlighter-rouge">accept()</code></a> to create TCP sockets, which are essentially <a href="https://en.wikipedia.org/wiki/File_descriptor">file descriptors</a>.
It binds the listening socket to the specified address and port, listens for incoming connections, and creates a new connected socket to handle client requests.
This is achieved without requiring you to write any socket-handling code.
Similarly, <code class="language-plaintext highlighter-rouge">http.HandleFunc()</code> registers your handler functions, abstracting away the lower-level details like using <a href="https://man7.org/linux/man-pages/man2/read.2.html"><code class="language-plaintext highlighter-rouge">read()</code></a> system call to read data, and <a href="https://man7.org/linux/man-pages/man2/write.2.html"><code class="language-plaintext highlighter-rouge">write()</code></a> system call to write data to the network socket.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center"><img src="/assets/2025-03-11-go-scheduling/go_http_server_meme.jpg" width="300" /></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">Go abstracts system calls to provide simple interface for HTTP server</td>
    </tr>
  </tbody>
</table>

<p>However, it‚Äôs not that simple for an HTTP server to handle tens of thousands of concurrent requests efficiently.
Go employs several techniques to achieve this. Let‚Äôs take a closer look at some notable I/O models in Linux and how Go takes advantage of them.</p>

<h3 id="blocking-io-non-blocking-io-and-io-multiplexing">Blocking I/O, Non-blocking I/O and I/O Multiplexing</h3>

<p>An I/O operation can be either blocking or non-blocking.
When a thread issues a blocking system call, its execution is suspended until the system call completes with the requested data.
In contrast, non-blocking I/O doesn‚Äôt suspend the thread; instead, it returns the requested data if available, or an error (<a href="https://man7.org/linux/man-pages/man3/errno.3.html#:~:text=POSIX.1%2D2001\).-,EAGAIN,-Resource%20temporarily%20unavailable"><code class="language-plaintext highlighter-rouge">EAGAIN</code></a> or <a href="https://man7.org/linux/man-pages/man3/errno.3.html#:~:text=POSIX.1%2D2001\).-,EAGAIN,-Resource%20temporarily%20unavailable"><code class="language-plaintext highlighter-rouge">EWOULDBLOCK</code></a>) if the data is not yet ready.
Blocking I/O is simpler to implement but inefficient, as it requires the application to spawn N threads for N connections.
In contrast, non-blocking I/O is more complex, but when implemented correctly, it enables significantly better resource utilization.
See the figures below for a visual comparison of these two models.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center"><img src="/assets/2025-03-11-go-scheduling/blocking_io.png" width="300" /></th>
      <th style="text-align: center"><img src="/assets/2025-03-11-go-scheduling/non_blocking_io.png" width="300" /></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">Blocking I/O model<sup>8</sup></td>
      <td style="text-align: center">Non-blocking I/O model<sup>9</sup></td>
    </tr>
  </tbody>
</table>

<p>Another I/O model worth mentioning is I/O multiplexing, in which <a href="https://man7.org/linux/man-pages/man2/select.2.html"><code class="language-plaintext highlighter-rouge">select</code></a>, or <a href="https://man7.org/linux/man-pages/man2/poll.2.html"><code class="language-plaintext highlighter-rouge">poll</code></a> system call is used to wait for one of a set of file descriptors to become ready to perform I/O.
In this model, the application blocks on one of these system calls, rather than on the actual I/O system calls, such as <a href="https://man7.org/linux/man-pages/man2/recv.2.html"><code class="language-plaintext highlighter-rouge">recvfrom</code></a> shown in the figures above.
When <a href="https://man7.org/linux/man-pages/man2/select.2.html"><code class="language-plaintext highlighter-rouge">select</code></a> returns that the socket is readable, the application calls <a href="https://man7.org/linux/man-pages/man2/recv.2.html"><code class="language-plaintext highlighter-rouge">recvfrom</code></a> to copy requested data to application buffer in user space.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center"><img src="/assets/2025-03-11-go-scheduling/io_multiplexing.png" width="500" /></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">I/O multiplexing model<sup>10</sup></td>
    </tr>
  </tbody>
</table>

<h2 id="io-model-in-go">I/O Model in Go</h2>

<p>Go uses a combination of non-blocking I/O and I/O multiplexing to handle I/O operations efficiently.
Due to the performance limitations of <a href="https://man7.org/linux/man-pages/man2/select.2.html"><code class="language-plaintext highlighter-rouge">select</code></a> and <a href="https://man7.org/linux/man-pages/man2/poll.2.html"><code class="language-plaintext highlighter-rouge">poll</code></a>  ‚Äîas explained in this <a href="https://jvns.ca/blog/2017/06/03/async-io-on-linux--select--poll--and-epoll/#why-don-t-we-use-poll-and-select">blog</a>‚ÄîGo avoids them in favor of more scalable alternatives: <a href="https://man7.org/linux/man-pages/man7/epoll.7.html">epoll</a> on Linux, <a href="https://man.freebsd.org/cgi/man.cgi?kqueue">kqueue</a> on Darwin, and <a href="https://learn.microsoft.com/en-us/windows/win32/fileio/i-o-completion-ports">IOCP</a> on Windows.
Go introduces netpoll, a function that abstracts these alternatives, to provide a unified interface for I/O multiplexing across different OS.</p>

<h2 id="how-netpoll-works">How netpoll Works</h2>

<p>Working with netpoll requires 4 steps: creating an <a href="https://man7.org/linux/man-pages/man7/epoll.7.html"><code class="language-plaintext highlighter-rouge">epoll</code></a> instance in kernel space, registering file descriptors with the <a href="https://man7.org/linux/man-pages/man7/epoll.7.html"><code class="language-plaintext highlighter-rouge">epoll</code></a> instance, <a href="https://man7.org/linux/man-pages/man7/epoll.7.html"><code class="language-plaintext highlighter-rouge">epoll</code></a> polls for I/O on file descriptors, and unregistering file descriptors from the <a href="https://man7.org/linux/man-pages/man7/epoll.7.html"><code class="language-plaintext highlighter-rouge">epoll</code></a> instance.
Let‚Äôs see how Go implements these steps.</p>

<h3 id="creating-epoll-instance-and-registering-goroutine">Creating epoll Instance and Registering Goroutine</h3>

<p>When a TCP listener <a href="https://github.com/golang/go/blob/go1.24.0/src/net/tcpsock.go#L374-L385">accepts</a> a connection, it uses <a href="https://man7.org/linux/man-pages/man2/accept.2.html"><code class="language-plaintext highlighter-rouge">accept4</code></a> system call is invoked with <a href="https://man7.org/linux/man-pages/man2/socket.2.html#:~:text=of%0A%20%20%20%20%20%20%20socket()%3A-,SOCK_NONBLOCK,-Set%20the%20O_NONBLOCK"><code class="language-plaintext highlighter-rouge">SOCK_NONBLOCK</code></a> flag to set the socket‚Äôs file descriptor of the socket to non-blocking mode.
Following this, several descriptors are created to integrate with Go runtime‚Äôs netpoll.</p>

<ol>
  <li>An instance of <a href="https://github.com/golang/go/blob/go1.24.0/src/net/fd_posix.go#L16-L27"><code class="language-plaintext highlighter-rouge">net.netFD</code></a> is created to wrap the socket‚Äôs file descriptor.
This struct provides a higher-level abstraction for performing network operations on the underlying file descriptor.
When <a href="https://github.com/golang/go/blob/go1.24.0/src/net/fd_posix.go#L16-L27"><code class="language-plaintext highlighter-rouge">net.netFD</code></a> is initialized, <a href="https://man7.org/linux/man-pages/man2/epoll_create.2.html"><code class="language-plaintext highlighter-rouge">epoll_create</code></a> system call is invoked to create a <strong>single global</strong> <a href="https://man7.org/linux/man-pages/man7/epoll.7.html"><code class="language-plaintext highlighter-rouge">epoll</code></a> instance, which is used throughout the lifetime of the process.
This is performed in <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/netpoll.go#L213-L216"><code class="language-plaintext highlighter-rouge">poll_runtime_pollServerInit</code></a> function, and only runs once as being wrapped in a <a href="https://pkg.go.dev/sync#Once"><code class="language-plaintext highlighter-rouge">sync.Once</code></a>.</li>
  <li>Inside <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/netpoll.go#L243-L278"><code class="language-plaintext highlighter-rouge">poll_runtime_pollOpen</code></a>, Go runtime allocates a <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/netpoll.go#L72-L115"><code class="language-plaintext highlighter-rouge">runtime.pollDesc</code></a> instance, which contains scheduling metadata and <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/netpoll.go#L98-L101">references</a> to the goroutines involved in I/O.
The socket‚Äôs file descriptor is then registered with the interest list of <a href="https://man7.org/linux/man-pages/man7/epoll.7.html"><code class="language-plaintext highlighter-rouge">epoll</code></a> using <a href="https://man7.org/linux/man-pages/man2/epoll_ctl.2.html"><code class="language-plaintext highlighter-rouge">epoll_ctl</code></a> system call with <a href="https://man7.org/linux/man-pages/man2/epoll_ctl.2.html#:~:text=op%20argument%20are%3A-,EPOLL_CTL_ADD,-Add%20an%20entry"><code class="language-plaintext highlighter-rouge">EPOLL_CTL_ADD</code></a> operation.
As <a href="(https://man7.org/linux/man-pages/man7/epoll.7.html)"><code class="language-plaintext highlighter-rouge">epoll</code></a> monitors file descriptors rather than goroutines, <a href="https://man7.org/linux/man-pages/man2/epoll_ctl.2.html"><code class="language-plaintext highlighter-rouge">epoll_ctl</code></a> also associates the file descriptor with an instance of <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/netpoll.go#L72-L115"><code class="language-plaintext highlighter-rouge">runtime.pollDesc</code></a>, allowing the Go scheduler to identify which goroutine should be resumed when I/O readiness is reported.</li>
  <li>An instance of <a href="https://github.com/golang/go/blob/go1.24.0/src/internal/poll/fd_unix.go#L17-L48"><code class="language-plaintext highlighter-rouge">poll.FD</code></a> is created to manage read and write operations with polling support.
It holds a reference to a <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/netpoll.go#L72-L115"><code class="language-plaintext highlighter-rouge">runtime.pollDesc</code></a> indirectly via <a href="https://github.com/golang/go/blob/go1.24.0/src/internal/poll/fd_poll_runtime.go#L32-L34"><code class="language-plaintext highlighter-rouge">poll.pollDesc</code></a>, which is simply a wrapper.</li>
</ol>

<blockquote>
  <p>‚ö†Ô∏è Go does have problem with a single <code class="language-plaintext highlighter-rouge">epoll</code> instance as described in <a href="https://github.com/golang/go/issues/65064">this</a> open issue.
There are discussions <a href="https://github.com/golang/go/issues/65064#issuecomment-1896633168">whether Go should use a single or multiple <code class="language-plaintext highlighter-rouge">epoll</code> instances</a>, or even <a href="https://github.com/golang/go/issues/65064#issuecomment-1896633168">use another I/O multiplexing model like <code class="language-plaintext highlighter-rouge">io_uring</code></a>.</p>
</blockquote>

<p>Building on the success of this model for network I/O, Go also leverages <a href="https://man7.org/linux/man-pages/man7/epoll.7.html"><code class="language-plaintext highlighter-rouge">epoll</code></a> for file I/O.
Once a file is opened, <a href="https://github.com/golang/go/blob/go1.24.0/src/os/file_unix.go#L222-L222"><code class="language-plaintext highlighter-rouge">syscall.SetNonblock</code></a> function is called to enable non-blocking mode for the file descriptor.
Subsequently, <a href="https://github.com/golang/go/blob/go1.24.0/src/internal/poll/fd_unix.go#L17-L48"><code class="language-plaintext highlighter-rouge">poll.FD</code></a>, <a href="https://github.com/golang/go/blob/go1.24.0/src/internal/poll/fd_poll_runtime.go#L32-L34"><code class="language-plaintext highlighter-rouge">poll.pollDesc</code></a> and <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/netpoll.go#L72-L115"><code class="language-plaintext highlighter-rouge">runtime.pollDesc</code></a> are initialized to register the file descriptor with <a href="https://man7.org/linux/man-pages/man7/epoll.7.html"><code class="language-plaintext highlighter-rouge">epoll</code></a>‚Äôs interest list, allowing file I/O to be multiplexed as well.</p>

<p>The relationship between these descriptors is depicted in the figure below.
Meanwhile <a href="https://github.com/golang/go/blob/go1.24.0/src/net/fd_posix.go#L16-L27"><code class="language-plaintext highlighter-rouge">net.netFD</code></a>, <a href="https://github.com/golang/go/blob/go1.24.0/src/os/types.go#L15-L20"><code class="language-plaintext highlighter-rouge">os.File</code></a>, <a href="https://github.com/golang/go/blob/go1.24.0/src/internal/poll/fd_unix.go#L17-L48"><code class="language-plaintext highlighter-rouge">poll.FD</code></a>, and <a href="https://github.com/golang/go/blob/go1.24.0/src/internal/poll/fd_poll_runtime.go#L32-L34"><code class="language-plaintext highlighter-rouge">poll.pollDesc</code></a> are implemented in user Go code (specifically in Go standard library), <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/netpoll.go#L72-L115"><code class="language-plaintext highlighter-rouge">runtime.pollDesc</code></a> resides within Go runtime itself.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center"><img src="/assets/2025-03-11-go-scheduling/netpoll_descriptors.png" /></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">Relationship of descriptors in Go</td>
    </tr>
  </tbody>
</table>

<h3 id="polling-file-descriptors">Polling File Descriptors</h3>

<p>When a goroutine reads from socket or file, it eventually invokes the <a href="https://github.com/golang/go/blob/go1.24.0/src/internal/poll/fd_unix.go#L141-L173"><code class="language-plaintext highlighter-rouge">Read</code></a> method of <a href="https://github.com/golang/go/blob/go1.24.0/src/internal/poll/fd_unix.go#L17-L48"><code class="language-plaintext highlighter-rouge">poll.FD</code></a>.
In this method, the goroutine makes <a href="https://man7.org/linux/man-pages/man2/read.2.html"><code class="language-plaintext highlighter-rouge">read</code></a> system call to get any available data from the file descriptor.
If the I/O data is not ready yet, i.e. <code class="language-plaintext highlighter-rouge">EAGAIN</code> error is returned, Go runtime invokes <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/netpoll.go#L336-L361"><code class="language-plaintext highlighter-rouge">poll_runtime_pollWait</code></a> method to <a href="#goroutine-parking-gopark">park the goroutine</a>.
The behavior is similar when a goroutine writes to a socket or file, with the main difference being that <a href="https://github.com/golang/go/blob/go1.24.0/src/internal/poll/fd_unix.go#L141-L173"><code class="language-plaintext highlighter-rouge">Read</code></a> is replaced by <a href="https://github.com/golang/go/blob/go1.24.0/src/net/net.go#L201-L211"><code class="language-plaintext highlighter-rouge">Write</code></a>, and the <a href="https://man7.org/linux/man-pages/man2/read.2.html"><code class="language-plaintext highlighter-rouge">read</code></a> system call is substituted with <a href="https://man7.org/linux/man-pages/man2/write.2.html"><code class="language-plaintext highlighter-rouge">write</code></a>.
Now that the goroutine is in <em>waiting</em> state, it is the responsibility of netpoll to present goroutine to the Go runtime when the goroutine‚Äôs file descriptor is ready for I/O so that it can be resumed.</p>

<p>In Go runtime, netpoll is nothing more than a function having the same name.
In <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/netpoll_epoll.go#L91-L176">netpoll</a> function, <a href="https://man7.org/linux/man-pages/man2/epoll_wait.2.html"><code class="language-plaintext highlighter-rouge">epoll_wait</code></a> system call is used to monitor up to 128 file descriptors in a specified amount of time.
This system call returns the <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/netpoll.go#L72-L115"><code class="language-plaintext highlighter-rouge">runtime.pollDesc</code></a> instances that were previously registered (as described in the previous section) for each file descriptor that becomes ready.
Finally, netpoll extracts the goroutine references from <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/netpoll.go#L72-L115"><code class="language-plaintext highlighter-rouge">runtime.pollDesc</code></a> and hands them off to the Go runtime.</p>

<p>But when is the netpoll function actually called?
It‚Äôs triggered when a thread looks for a runnable goroutine to execute, as outlined in <a href="#schedule-loop">schedule loop</a>.
According to <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/proc.go#L3267-L3646"><code class="language-plaintext highlighter-rouge">findRunnable</code></a> function, netpoll is only consulted by the Go runtime if there are no goroutines available in either the local run queue of the current <code class="language-plaintext highlighter-rouge">P</code> or the global run queue.
This means even if its file descriptor is ready for I/O, the goroutine is not necessarily woken up immediately.</p>

<p>As mentioned earlier, netpoll can block for a specified amount of time, and this is determined by the <code class="language-plaintext highlighter-rouge">delay</code> parameter.
If <code class="language-plaintext highlighter-rouge">delay</code> is positive, it blocks for the specified number of nanoseconds.
If <code class="language-plaintext highlighter-rouge">delay</code> is negative, it blocks until an I/O event becomes ready.
Otherwise, when <code class="language-plaintext highlighter-rouge">delay</code> is zero, it returns immediately with any I/O events that are currently ready.
In the <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/proc.go#L3267-L3646"><code class="language-plaintext highlighter-rouge">findRunnable</code></a> function, <code class="language-plaintext highlighter-rouge">delay</code> is passed with 0, which means that if one goroutine is waiting for I/O, another goroutine can be scheduled to run on the same kernel thread.</p>

<h3 id="unregistering-file-descriptors">Unregistering File Descriptors</h3>

<p>As mentioned above, <a href="https://man7.org/linux/man-pages/man7/epoll.7.html"><code class="language-plaintext highlighter-rouge">epoll</code></a> instance monitors up to 128 file descriptors.
Therefore, it‚Äôs important to unregister file descriptors when they are no longer needed otherwise some goroutines may be starved.
When file or network connection is no longer in used, we should close it by calling its <code class="language-plaintext highlighter-rouge">Close</code> method.</p>

<p>Under the hood, the <a href="https://github.com/golang/go/blob/go1.24.0/src/internal/poll/fd_unix.go#L75-L87"><code class="language-plaintext highlighter-rouge">destroy</code></a> method of <a href="https://github.com/golang/go/blob/go1.24.0/src/internal/poll/fd_unix.go#L75-L87"><code class="language-plaintext highlighter-rouge">poll.FD</code></a> is called.
This method eventually invokes the function <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/netpoll.go#L280-L295"><code class="language-plaintext highlighter-rouge">poll_runtime_pollClose</code></a> in Go runtime to make <a href="https://man7.org/linux/man-pages/man2/epoll_ctl.2.html"><code class="language-plaintext highlighter-rouge">epoll_ctl</code></a> with <code class="language-plaintext highlighter-rouge">EPOLL_CTL_DEL</code> operation.
This unregisters the file descriptor from the <a href="https://man7.org/linux/man-pages/man7/epoll.7.html"><code class="language-plaintext highlighter-rouge">epoll</code></a>‚Äôs interest list.</p>

<h3 id="putting-it-all-together-1">Putting It All Together</h3>

<p>The figure below illustrates the entire process of how netpoll works in Go runtime with file I/O.
The process for network I/O is similar, but with the addition of a TCP listener that accepts connection and connection is closed.
For simplicity purpose, other components in such as <code class="language-plaintext highlighter-rouge">sysmon</code> and other idle processors <code class="language-plaintext highlighter-rouge">P</code> are omitted.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center"><img src="/assets/2025-03-11-go-scheduling/netpoll_in_gmp_model.png" width="350" /></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">How netpoll works in GMP model</td>
    </tr>
  </tbody>
</table>

<h2 id="garbage-collector">Garbage Collector</h2>

<p>You may know that Go includes a garbage collector (GC) to automatically reclaim memory from unused objects.
However, as mentioned in the <a href="#program-bootstrap">Program Bootstrap</a> section, when the program starts, there are no threads initially available to run the GC.
So where does the GC actually run?</p>

<p>Before we answer that question, let‚Äôs take a quick look at how garbage collection works.
Go uses a tracing garbage collector, which identifies live and dead objects by traversing the allocated object graph starting from a set of root references.
Objects that are reachable from the roots are considered live; those that are not are considered dead and eligible for reclamation.</p>

<p>Go‚Äôs GC implements a <a href="https://en.wikipedia.org/wiki/Tracing_garbage_collection#Tri-color_marking">tri-color marking algorithm</a> with support for <a href="https://learn.microsoft.com/en-us/dotnet/standard/garbage-collection/weak-references">weak references</a>.
This design allows the garbage collector to run concurrently with the program, significantly reducing stop-the-world (STW) pauses and improving overall performance.</p>

<p>A Go garbage collection cycle can be divided into 4 stages:</p>
<ol>
  <li><strong>First STW</strong>: The process is paused so that all processors <code class="language-plaintext highlighter-rouge">P</code> can enter the safe point.</li>
  <li><strong>Marking phase</strong>: GC goroutines takes processor <code class="language-plaintext highlighter-rouge">P</code> shortly to mark reachable objects.</li>
  <li><strong>Second STW</strong>: The process is paused again to allow the GC to finalize the marking phase.</li>
  <li><strong>Sweeping phase</strong>: Unpause the process and reclaim memory for unreachable objects in background.</li>
</ol>

<p>Note that in step 2, garbage collection worker goroutine runs concurrently with regular goroutines on the same processor <code class="language-plaintext highlighter-rouge">P</code>.
The <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/proc.go#L3267-L3646"><code class="language-plaintext highlighter-rouge">findRunnable</code></a> function (mentioned in <a href="#finding-a-runnable-goroutine">Finding a Runnable Goroutine</a> section) not only looks for regular goroutines but also for GC goroutines (step 1 and 2).</p>

<h2 id="scheduling-common-functions">Scheduling Common Functions</h2>

<h3 id="getting-goroutine-getg">Getting Goroutine: <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/stubs.go#L28-L31"><code class="language-plaintext highlighter-rouge">getg</code></a></h3>

<p>In Go runtime, there is a common function that is used to retrieve the running goroutine in current kernel thread: <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/stubs.go#L28-L31"><code class="language-plaintext highlighter-rouge">getg()</code></a>.
Taking a glance at the source code, you can see no implementation for this function.
That‚Äôs because upon compiling, the compiler rewrites calls to this function into instructions that fetch the goroutine from <a href="https://en.wikipedia.org/wiki/Thread-local_storage">thread-local storage</a> (TLS) or from registers.</p>

<p>But when is the current goroutine stored in thread-local storage so it can be retrieved later?
This happens during a goroutine context switch in the <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/asm_amd64.s#L411-L413"><code class="language-plaintext highlighter-rouge">gogo</code></a> function, which is called by <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/proc.go#L3221-L3265"><code class="language-plaintext highlighter-rouge">execute</code></a>.
It also occurs when a signal handler is invoked, in the <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/signal_unix.go#L420-L495"><code class="language-plaintext highlighter-rouge">sigtrampgo</code></a> function.</p>

<h3 id="goroutine-parking-gopark">Goroutine Parking: <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/proc.go#L390-L436"><code class="language-plaintext highlighter-rouge">gopark</code></a></h3>

<p>This is a commonly used procedure in Go runtime for transitioning the current goroutine into a <em>waiting</em> state and scheduling another goroutine to run.
The snippet below highlights some of its key aspects.</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">gopark</span><span class="p">(</span><span class="n">unlockf</span> <span class="k">func</span><span class="p">(</span><span class="o">*</span><span class="n">g</span><span class="p">,</span> <span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span><span class="p">)</span> <span class="kt">bool</span><span class="p">,</span> <span class="o">...</span><span class="p">)</span> <span class="p">{</span>
    <span class="o">...</span>
    <span class="n">mp</span><span class="o">.</span><span class="n">waitunlockf</span> <span class="o">=</span> <span class="n">unlockf</span>
    <span class="o">...</span>
    <span class="n">releasem</span><span class="p">(</span><span class="n">mp</span><span class="p">)</span>
    <span class="o">...</span>
    <span class="n">mcall</span><span class="p">(</span><span class="n">park_m</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Inside <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/runtime1.go#L612-L619"><code class="language-plaintext highlighter-rouge">releasem</code></a> function, the goroutine‚Äôs <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/runtime2.go#L405-L405"><code class="language-plaintext highlighter-rouge">stackguard0</code></a> is set to <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/stack.go#L128-L130"><code class="language-plaintext highlighter-rouge">stackPreempt</code></a> to trigger an eventual cooperative preemption.
The control is then transferred to the <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/runtime2.go#L529"><code class="language-plaintext highlighter-rouge">g0</code></a> system goroutine, which belongs to the same thread currently running the goroutine, to invoke the <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/proc.go#L4089-L4142"><code class="language-plaintext highlighter-rouge">park_m</code></a> function.</p>

<p>Inside <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/proc.go#L4089-L4142"><code class="language-plaintext highlighter-rouge">park_m</code></a>, the goroutine state is set to <em>waiting</em> and the association between the goroutine and the thread <code class="language-plaintext highlighter-rouge">M</code> is dropped.
Additionally, <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/proc.go#L390-L436"><code class="language-plaintext highlighter-rouge">gopark</code></a> receives an <code class="language-plaintext highlighter-rouge">unlockf</code> callback function, which is executed in <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/proc.go#L4089-L4142"><code class="language-plaintext highlighter-rouge">park_m</code></a>.
If <code class="language-plaintext highlighter-rouge">unlockf</code> returns <code class="language-plaintext highlighter-rouge">false</code>, the parked goroutine is immediately made runnable again and rescheduled on the same thread <code class="language-plaintext highlighter-rouge">M</code> using <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/proc.go#L3221-L3265"><code class="language-plaintext highlighter-rouge">execute</code></a>.
Otherwise, <code class="language-plaintext highlighter-rouge">M</code> enters the <a href="#schedule-loop">schedule loop</a> to pick a goroutine and execute it.</p>

<h3 id="start-thread-startm">Start Thread: <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/proc.go#L2917-L3025"><code class="language-plaintext highlighter-rouge">startm</code></a></h3>

<p>This function is responsible for scheduling a thread <code class="language-plaintext highlighter-rouge">M</code> to run a given processor <code class="language-plaintext highlighter-rouge">P</code>.
The diagram below illustrates the flow of this function, in which <code class="language-plaintext highlighter-rouge">M1</code> thread is the parent of <code class="language-plaintext highlighter-rouge">M2</code> thread.</p>

<table>
    <thead>
        <tr>
            <td>
                <pre class="mermaid" style="margin: unset">

flowchart LR
    subgraph M2
    direction LR
        mstart["mstart()"] ==&gt; mstart0["mstart0()"]
        mstart0 ==&gt; mstart1["mstart1()"]
        mstart1 ==&gt; schedule["schedule()"]
    end
    subgraph M1
        direction LR
        start((Start)) ==&gt; check_p{P == nil?}
        check_p ==&gt; |Yes|check_idle_p{Is there any idle P?}
        check_idle_p ==&gt; |No|_end(((End)))
        check_idle_p ==&gt; |Yes|assign_p[P = idle P]
        check_p ==&gt; |No|check_idle_m{Is there any idle M?}
        assign_p ==&gt; check_idle_m
        check_idle_m ==&gt; |Yes|wakeup_m[Wake up M]
        wakeup_m ==&gt; _end
        check_idle_m ==&gt; |No|newm["newm()"]
        newm ==&gt; newm1["newm1()"]
        newm1 ==&gt; newosproc["newosproc()"]
        newosproc ==&gt; clone["clone() with entry point mstart, result in M2 thread"]
        clone ==&gt; _end
    end

                </pre>
            </td>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td style="text-align: center">
                The <code>startm</code> function
            </td>
        </tr>
    </tbody>
</table>

<p>If <code class="language-plaintext highlighter-rouge">P</code> is <code class="language-plaintext highlighter-rouge">nil</code>, it attempts to retrieve an idle processor from the global idle list.
If no idle processor is available, the function simply returns‚Äîindicating that the maximum number of active processors is already in use and no additional thread <code class="language-plaintext highlighter-rouge">M</code> can be created or reactivated.
If an idle processor is found (or <code class="language-plaintext highlighter-rouge">P</code> was already provided), the function either creates a new thread <code class="language-plaintext highlighter-rouge">M1</code> (if none is idle) or wakes up an existing idle one to run <code class="language-plaintext highlighter-rouge">P</code>.</p>

<p>Once awakened, the existing thread <code class="language-plaintext highlighter-rouge">M</code> continues in the <a href="#schedule-loop">schedule loop</a>.
If a new thread is created, it‚Äôs done via the <a href="https://man7.org/linux/man-pages/man2/clone.2.html"><code class="language-plaintext highlighter-rouge">clone</code></a> system call, with <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/os_linux.go#L186-L187"><code class="language-plaintext highlighter-rouge">mstart</code></a> as the entry point.
The <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/proc.go#L1769-L1771"><code class="language-plaintext highlighter-rouge">mstart</code></a> function then transitions into the <a href="#schedule-loop">schedule loop</a>, where it looks for a runnable goroutine to execute.</p>

<h3 id="stop-thread-stopm">Stop Thread: <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/proc.go#L2889-L2910"><code class="language-plaintext highlighter-rouge">stopm</code></a></h3>

<p>This function adds thread <code class="language-plaintext highlighter-rouge">M</code> into the idle list and put it into sleep.
<a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/proc.go#L2889-L2910"><code class="language-plaintext highlighter-rouge">stopm</code></a> doesn‚Äôt return until <code class="language-plaintext highlighter-rouge">M</code> is woken up by another thread, typically when a new goroutine is created, as mentioned in <a href="#waking-up-processor">Waking Up Processor</a> section.
This is achieved by <a href="https://linux.die.net/man/2/futex"><code class="language-plaintext highlighter-rouge">futex</code></a> system call, making <code class="language-plaintext highlighter-rouge">M</code> not eating CPU cycles while waiting.</p>

<h3 id="processor-handoff-handoffp">Processor Handoff: <a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/proc.go#L3026-L3096"><code class="language-plaintext highlighter-rouge">handoffp</code></a></h3>

<p><a href="https://github.com/golang/go/blob/go1.24.0/src/runtime/proc.go#L3026-L3096"><code class="language-plaintext highlighter-rouge">handoffp</code></a> is responsible for transferring the ownership of a processor <code class="language-plaintext highlighter-rouge">P</code> from a thread <code class="language-plaintext highlighter-rouge">M</code>s that is blocking in a system call to another thread <code class="language-plaintext highlighter-rouge">M1</code>.
<code class="language-plaintext highlighter-rouge">P</code> will be associated with <code class="language-plaintext highlighter-rouge">M1</code> to make progress by calling <a href="#start-thread-startm"><code class="language-plaintext highlighter-rouge">startm</code></a> under certain conditions: if the global run queue is not empty, if its local run queue is not empty, if there is tracing or garbage collection work to do, or if no thread is currently handling netpoll.
If none of these conditions is met, <code class="language-plaintext highlighter-rouge">P</code> is returned to the processor idle list.</p>

<h2 id="runtime-apis">Runtime APIs</h2>

<p>Go runtime provides several APIs to interact with the scheduler and goroutines.
It also allows Go programmers to tune the scheduler and other components like garbage collector for their application specific needs.</p>

<h3 id="gomaxprocs"><a href="https://pkg.go.dev/runtime#GOMAXPROCS"><code class="language-plaintext highlighter-rouge">GOMAXPROCS</code></a></h3>

<p>This function sets the maximum number of processors <code class="language-plaintext highlighter-rouge">P</code> in Go runtime, thus controlling the level of parallelism in a Go program.
Some I/O bound programs may benefit from a higher number of processors <code class="language-plaintext highlighter-rouge">P</code> than the default.
For example, <a href="https://github.com/hypermodeinc/dgraph/blob/v24.1.2/dgraph/main.go#L36">Dgraph</a> database hardcodes <a href="https://pkg.go.dev/runtime#GOMAXPROCS"><code class="language-plaintext highlighter-rouge">GOMAXPROCS</code></a> to 128.</p>

<h3 id="goexit"><a href="https://pkg.go.dev/runtime#Goexit"><code class="language-plaintext highlighter-rouge">Goexit</code></a></h3>

<p>This function gracefully terminates the current goroutine.
All deferred calls run before terminating the goroutine.
The program continues execution of other goroutines.
If all other goroutines exit, the program crashes.
<a href="https://pkg.go.dev/runtime#Goexit"><code class="language-plaintext highlighter-rouge">Goexit</code></a> should be used testing rather than real-world application, where you want to abort the test case early (for example, if preconditions aren‚Äôt met), but you still want deferred cleanup to run.</p>

<h2 id="references">References</h2>

<ul>
  <li>kelche.co. <a href="https://www.kelche.co/blog/go/golang-scheduling"><em>Go Scheduling</em></a>.</li>
  <li>unskilled.blog. <a href="https://unskilled.blog/posts/preemption-in-go-an-introduction/"><em>Preemption in Go</em></a>.</li>
  <li>Ian Lance Taylor. <a href="https://groups.google.com/g/golang-nuts/c/JCKWH8fap9o"><em>What is system stack?</em></a></li>
  <li>[6], [7] Michael Kerrisk. <a href="https://man7.org/tlpi/"><em>The Linux Programming Interface</em></a>.</li>
  <li>[8], [9], [10] W. Richard Stevens. <a href="https://www.amazon.com/UNIX-Network-Programming-Richard-Stevens/dp/0139498761"><em>Unix Network Programming</em></a>.</li>
  <li>zhuanlan.zhihu.com. <a href="https://zhuanlan.zhihu.com/p/436925356">Golang program startup process analysis</a>.</li>
  <li>Madhav Jivrajani. <a href="https://www.youtube.com/watch?v=wQpC99Xu1U4&amp;t=2375s&amp;ab_channel=GopherAcademy">GopherCon 2021: Queues, Fairness, and The Go Scheduler</a>.</li>
  <li>[1], [2], [3] Abraham Silberschatz, Peter B. Galvin, Greg Gagne. <a href="https://www.amazon.com/Operating-System-Concepts-Abraham-Silberschatz/dp/1119800366/ref=zg-te-pba_d_sccl_3_1/138-7692107-2007040"><em>Operating System Concepts</em></a>.</li>
</ul>]]></content><author><name>nghiant3223@gmail.com</name></author><summary type="html"><![CDATA[Go Scheduler]]></summary></entry><entry><title type="html">Deadlock In MySQL</title><link href="http://localhost:4000/2024/03/09/deadlock_in_mysql.html" rel="alternate" type="text/html" title="Deadlock In MySQL" /><published>2024-03-09T00:00:00+07:00</published><updated>2024-03-09T00:00:00+07:00</updated><id>http://localhost:4000/2024/03/09/deadlock_in_mysql</id><content type="html" xml:base="http://localhost:4000/2024/03/09/deadlock_in_mysql.html"><![CDATA[<h1 id="deadlock-in-mysql">Deadlock In MySQL</h1>

<h2 id="introduction">Introduction</h2>

<p>Deadlocks in MySQL can be a significant challenge for database administrators and developers alike. A deadlock occurs when two or more transactions are each waiting for a resource locked by the other, resulting in a circular waiting pattern that halts progress. Understanding how deadlocks happen, their implications, and strategies to mitigate them is crucial for maintaining the stability and performance of MySQL databases.</p>

<p>In this blog, we will delve into the intricacies of deadlocks in MySQL. We will explore common scenarios that lead to deadlocks, discuss the impact they can have on application performance, and provide practical approaches to prevent and manage them effectively.</p>

<h2 id="demonstration">Demonstration</h2>

<p>To illustrate the occurrence and resolution of deadlocks in MySQL, let‚Äôs walk through a practical demonstration. In this scenario, we‚Äôll create a simple database schema and perform transactions that can potentially lead to deadlocks. We‚Äôll then analyze the deadlock situation and implement strategies to mitigate and resolve it.</p>

<p>Please note that the demonstration below is conducted using MySQL 8.0.32.</p>

<h2 id="preparation">Preparation</h2>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">CREATE</span> <span class="k">SCHEMA</span> <span class="n">IF</span> <span class="k">NOT</span> <span class="k">EXISTS</span> <span class="nv">`deadlock_playground`</span><span class="p">;</span>

<span class="n">USE</span> <span class="nv">`deadlock_playground`</span><span class="p">;</span>

<span class="k">CREATE</span> <span class="k">TABLE</span> <span class="nv">`t`</span>
<span class="p">(</span>
    <span class="nv">`id`</span> <span class="nb">INT</span> <span class="k">NOT</span> <span class="k">NULL</span> <span class="n">AUTO_INCREMENT</span><span class="p">,</span>
    <span class="nv">`a`</span>  <span class="nb">INT</span><span class="p">,</span>
    <span class="nv">`b`</span>  <span class="nb">INT</span><span class="p">,</span>
    <span class="k">PRIMARY</span> <span class="k">KEY</span> <span class="p">(</span><span class="nv">`id`</span><span class="p">),</span>
    <span class="k">UNIQUE</span> <span class="k">INDEX</span> <span class="n">uq_a</span> <span class="p">(</span><span class="nv">`a`</span><span class="p">)</span>
<span class="p">);</span>

<span class="k">INSERT</span> <span class="k">INTO</span> <span class="nv">`t`</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="k">VALUES</span> <span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span> <span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="mi">20</span><span class="p">),</span> <span class="p">(</span><span class="mi">30</span><span class="p">,</span> <span class="mi">30</span><span class="p">),</span> <span class="p">(</span><span class="mi">40</span><span class="p">,</span> <span class="mi">40</span><span class="p">),</span> <span class="p">(</span><span class="mi">50</span><span class="p">,</span> <span class="mi">50</span><span class="p">);</span>
</code></pre></div></div>

<h2 id="scenario-1-insert-the-same-primary-key">Scenario 1: Insert The Same Primary Key</h2>

<p>Different sessions attempting to <code class="language-plaintext highlighter-rouge">INSERT</code> records with the same primary key at the same time can cause deadlock at every isolation level. This also applies to the <code class="language-plaintext highlighter-rouge">INSERT ... ON DUPLICATE KEY ...</code> statement.</p>

<p>Below is an example results in deadlock, in which isolation level SERIALIZABLE is used.</p>

<table>
  <thead>
    <tr>
      <th>Timestamp</th>
      <th>Session 1</th>
      <th>Session 2</th>
      <th>Session 3</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>T1</td>
      <td>SET SESSION TRANSACTION ISOLATION LEVEL SERIALIZABLE;<br /><br />START TRANSACTION;<br />// transaction ID 1934<br /><br />INSERT INTO t(id,a,b) VALUES (45,45,1) ON DUPLICATE KEY UPDATE b=-1;</td>
      <td>¬†</td>
      <td>¬†</td>
    </tr>
    <tr>
      <td>T2</td>
      <td>¬†</td>
      <td>SET SESSION TRANSACTION ISOLATION LEVEL SERIALIZABLE;<br /><br />START TRANSACTION;<br />// transaction ID 1935<br /><br />INSERT INTO t(id,a,b) VALUES (45,45,2) ON DUPLICATE KEY UPDATE b=-1;</td>
      <td>¬†</td>
    </tr>
    <tr>
      <td>T3</td>
      <td>¬†</td>
      <td>¬†</td>
      <td>SET SESSION TRANSACTION ISOLATION LEVEL SERIALIZABLE;<br /><br />START TRANSACTION;<br />// transaction ID 1936<br /><br />INSERT INTO t(id,a,b) VALUES (45,45,3) ON DUPLICATE KEY UPDATE b=-1;</td>
    </tr>
    <tr>
      <td>T4</td>
      <td>ROLLBACK;</td>
      <td>¬†</td>
      <td>¬†</td>
    </tr>
    <tr>
      <td>T5</td>
      <td>¬†</td>
      <td>1 rows affected</td>
      <td>Deadlock found when trying to get lock; try restarting transaction</td>
    </tr>
  </tbody>
</table>

<p>After T3, lock data are as below:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mysql&gt; SELECT ENGINE_TRANSACTION_ID, INDEX_NAME, LOCK_TYPE, LOCK_MODE, LOCK_STATUS, LOCK_DATA FROM performance_schema.data_locks WHERE OBJECT_NAME='t';
+-----------------------+------------+-----------+---------------+-------------+-----------+
| ENGINE_TRANSACTION_ID | INDEX_NAME | LOCK_TYPE | LOCK_MODE     | LOCK_STATUS | LOCK_DATA |
+-----------------------+------------+-----------+---------------+-------------+-----------+
|                  1936 | NULL       | TABLE     | IX            | GRANTED     | NULL      |
|                  1936 | PRIMARY    | RECORD    | X,REC_NOT_GAP | WAITING     | 45        |
|                  1935 | NULL       | TABLE     | IX            | GRANTED     | NULL      |
|                  1935 | PRIMARY    | RECORD    | X,REC_NOT_GAP | WAITING     | 45        |
|                  1934 | NULL       | TABLE     | IX            | GRANTED     | NULL      |
|                  1934 | PRIMARY    | RECORD    | X,REC_NOT_GAP | GRANTED     | 45        |
+-----------------------+------------+-----------+---------------+-------------+-----------+
</code></pre></div></div>

<p>After T4, lock data are as below:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mysql&gt; SELECT ENGINE_TRANSACTION_ID, INDEX_NAME, LOCK_TYPE, LOCK_MODE, LOCK_STATUS, LOCK_DATA FROM performance_schema.data_locks WHERE OBJECT_NAME='t';
+-----------------------+------------+-----------+------------------------+-------------+-----------+
| ENGINE_TRANSACTION_ID | INDEX_NAME | LOCK_TYPE | LOCK_MODE              | LOCK_STATUS | LOCK_DATA |
+-----------------------+------------+-----------+------------------------+-------------+-----------+
|                  1935 | NULL       | TABLE     | IX                     | GRANTED     | NULL      |
|                  1935 | PRIMARY    | RECORD    | X,GAP                  | GRANTED     | 45        |
|                  1935 | PRIMARY    | RECORD    | X,GAP                  | GRANTED     | 50        |
|                  1935 | PRIMARY    | RECORD    | X,GAP,INSERT_INTENTION | GRANTED     | 50        |
+-----------------------+------------+-----------+------------------------+-------------+-----------+
</code></pre></div></div>

<p>After T4, deadlock information are as below:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>------------------------
LATEST DETECTED DEADLOCK
------------------------
2024-03-09 10:11:14 281472264068992
*** (1) TRANSACTION:
TRANSACTION 1935, ACTIVE 16 sec inserting
mysql tables in use 1, locked 1
LOCK WAIT 4 lock struct(s), heap size 1128, 2 row lock(s)
MySQL thread id 20, OS thread handle 281472569147264, query id 2771 192.168.214.1 root update
/* ApplicationName=GoLand 2023.1.1 */ INSERT INTO `t`(id, `a`, `b`) VALUES (45,45,2) ON DUPLICATE KEY UPDATE `b` = -1

*** (1) HOLDS THE LOCK(S):
RECORD LOCKS space id 2 page no 4 n bits 80 index PRIMARY of table `deadlock_playground`.`t` trx id 1935 lock_mode X locks gap before rec
Record lock, heap no 7 PHYSICAL RECORD: n_fields 5; compact format; info bits 0
 0: len 4; hex 80000032; asc    2;;
 1: len 6; hex 00000000076f; asc      o;;
 2: len 7; hex 810000009a012a; asc       *;;
 3: len 4; hex 80000032; asc    2;;
 4: len 4; hex 80000032; asc    2;;


*** (1) WAITING FOR THIS LOCK TO BE GRANTED:
RECORD LOCKS space id 2 page no 4 n bits 80 index PRIMARY of table `deadlock_playground`.`t` trx id 1935 lock_mode X locks gap before rec insert intention waiting
Record lock, heap no 7 PHYSICAL RECORD: n_fields 5; compact format; info bits 0
 0: len 4; hex 80000032; asc    2;;
 1: len 6; hex 00000000076f; asc      o;;
 2: len 7; hex 810000009a012a; asc       *;;
 3: len 4; hex 80000032; asc    2;;
 4: len 4; hex 80000032; asc    2;;


*** (2) TRANSACTION:
TRANSACTION 1936, ACTIVE 4 sec inserting
mysql tables in use 1, locked 1
LOCK WAIT 4 lock struct(s), heap size 1128, 2 row lock(s)
MySQL thread id 22, OS thread handle 281472568090496, query id 2802 192.168.214.1 root update
/* ApplicationName=GoLand 2023.1.1 */ INSERT INTO `t`(id, `a`, `b`) VALUES (45,45,3) ON DUPLICATE KEY UPDATE `b` = -1

*** (2) HOLDS THE LOCK(S):
RECORD LOCKS space id 2 page no 4 n bits 80 index PRIMARY of table `deadlock_playground`.`t` trx id 1936 lock_mode X locks gap before rec
Record lock, heap no 7 PHYSICAL RECORD: n_fields 5; compact format; info bits 0
 0: len 4; hex 80000032; asc    2;;
 1: len 6; hex 00000000076f; asc      o;;
 2: len 7; hex 810000009a012a; asc       *;;
 3: len 4; hex 80000032; asc    2;;
 4: len 4; hex 80000032; asc    2;;


*** (2) WAITING FOR THIS LOCK TO BE GRANTED:
RECORD LOCKS space id 2 page no 4 n bits 80 index PRIMARY of table `deadlock_playground`.`t` trx id 1936 lock_mode X locks gap before rec insert intention waiting
Record lock, heap no 7 PHYSICAL RECORD: n_fields 5; compact format; info bits 0
 0: len 4; hex 80000032; asc    2;;
 1: len 6; hex 00000000076f; asc      o;;
 2: len 7; hex 810000009a012a; asc       *;;
 3: len 4; hex 80000032; asc    2;;
 4: len 4; hex 80000032; asc    2;;

*** WE ROLL BACK TRANSACTION (2)
</code></pre></div></div>

<p>One may wonder, ‚ÄúWhy does deadlock happen even for the highest isolation level, i.e., <code class="language-plaintext highlighter-rouge">SERIALIZABLE</code>?‚Äù.</p>

<p>Let‚Äôs refer to the MySQL <a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-transaction-isolation-levels.html#:~:text=READ%20COMMITTED.-,SERIALIZABLE,-This%20level%20is">documentation</a>:</p>
<blockquote>
  <p>SERIALIZABLE: This level is like REPEATABLE READ, but InnoDB implicitly converts all plain SELECT statements to SELECT ‚Ä¶ FOR SHARE if autocommit is disabled. If autocommit is enabled, the SELECT is its own transaction. It therefore is known to be read-only and can be serialized if performed as a consistent (nonlocking) read and need not block for other transactions.</p>
</blockquote>

<p>We can see that the <code class="language-plaintext highlighter-rouge">SERIALIZABLE</code> isolation level has nothing to do with the <code class="language-plaintext highlighter-rouge">INSERT</code> statement. Therefore, deadlock could definitely happen in the <code class="language-plaintext highlighter-rouge">SERIALIZABLE</code> isolation level.</p>

<h2 id="references">References</h2>

<ul>
  <li>https://cloud.tencent.com/developer/article/2326843</li>
</ul>]]></content><author><name>nghiant3223@gmail.com</name></author><summary type="html"><![CDATA[Deadlock In MySQL]]></summary></entry><entry><title type="html">Prepared Statement in MySQL and Go</title><link href="http://localhost:4000/2023/07/23/prepared_statement_in_mysql_and_go.html" rel="alternate" type="text/html" title="Prepared Statement in MySQL and Go" /><published>2023-07-23T00:00:00+07:00</published><updated>2023-07-23T00:00:00+07:00</updated><id>http://localhost:4000/2023/07/23/prepared_statement_in_mysql_and_go</id><content type="html" xml:base="http://localhost:4000/2023/07/23/prepared_statement_in_mysql_and_go.html"><![CDATA[<h1 id="prepared-statement-in-mysql-and-go">Prepared Statement in MySQL and Go</h1>

<h1 id="what-is-prepared-statement">What is Prepared Statement?</h1>

<p>In a database management system (DBMS) like MySQL, a prepared statement is a mechanism in which the DBMS server precompiles the SQL statement separately from the data, stores the compiled result, and later applies the data to the compiled result to get final result.</p>

<p>In DBMS, a prepared statement offers several benefits:</p>

<ul>
  <li>Security: Prepared statements are resistant to SQL injection attacks. By separating the SQL statement from the data and handling them as separate entities, prepared statements provide an extra layer of security. This helps prevent malicious users from manipulating the SQL code by injecting malicious commands or unauthorized data into the query.</li>
  <li>Efficiency: Prepared statements avoid the need for repetitive recompilation of the SQL statement. When a prepared statement is executed multiple times, the DBMS server only needs to compile the SQL statement once. Subsequent executions of the prepared statement can reuse the compiled result, resulting in improved performance and reduced overhead.</li>
  <li>Convenience: Prepared statements are data type agnostic. This means that the data passed to the prepared statement does not require explicit data type conversions or validations. The DBMS automatically handles the data binding process, ensuring compatibility between the data and the SQL statement. This convenience simplifies the programming process and reduces the risk of errors related to data type mismatches.</li>
</ul>

<p>Working with prepared statements is relatively straightforward. To utilize a prepared statement, you send the statement to the server, which includes placeholders (<code class="language-plaintext highlighter-rouge">?</code> in MySQL, <code class="language-plaintext highlighter-rouge">$1</code> in PostgreSQL, <code class="language-plaintext highlighter-rouge">:col</code> in Oracle) for the values you want to provide. Once you have sent the prepared statement to the server, you can request the database to execute the statement, providing the necessary arguments. These arguments correspond to the placeholders in the prepared statement and are typically passed as parameters to the execution command.</p>

<p>Although a prepared statement might seem as simple as telling a joke, if we‚Äôre not careful, unexpected incidents could turn it into a comedy of errors. Let‚Äôs see how the incident occurred.</p>

<h1 id="using-prepared-statement-the-wrong-way">Using Prepared Statement the Wrong Way</h1>

<p>Presented below is the block of code from company X that has recently encountered an incident related to a prepared statement. To respect the non-disclosure agreement, I have made some modifications to the code while preserving its core idea.</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// newDB returns an instance of connection pool.</span>
<span class="k">func</span> <span class="n">newDB</span><span class="p">()</span> <span class="p">(</span><span class="o">*</span><span class="n">sql</span><span class="o">.</span><span class="n">DB</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">db</span><span class="p">,</span> <span class="n">err</span> <span class="o">:=</span> <span class="n">sql</span><span class="o">.</span><span class="n">Open</span><span class="p">(</span><span class="s">"mysql"</span><span class="p">,</span> <span class="s">"root:password@tcp(127.0.0.1:3306)/demo?charset=utf8mb4&amp;parseTime=True"</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">err</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
    <span class="k">return</span> <span class="no">nil</span><span class="p">,</span> <span class="n">err</span>
  <span class="p">}</span>

  <span class="n">db</span><span class="o">.</span><span class="n">SetMaxOpenConns</span><span class="p">(</span><span class="m">10</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">db</span><span class="p">,</span> <span class="no">nil</span>
<span class="p">}</span>

<span class="c">// findUsers returns a list of user whose id in `userIDs` input.</span>
<span class="k">func</span> <span class="n">findUsers</span><span class="p">(</span><span class="n">db</span> <span class="o">*</span><span class="n">sql</span><span class="o">.</span><span class="n">DB</span><span class="p">,</span> <span class="n">userIDs</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="p">([]</span><span class="o">*</span><span class="n">User</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">userIDs</span><span class="p">)</span> <span class="o">==</span> <span class="m">0</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">[]</span><span class="o">*</span><span class="n">User</span><span class="p">{},</span> <span class="no">nil</span>
  <span class="p">}</span>

  <span class="n">argUserIDs</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="k">interface</span><span class="p">{},</span> <span class="nb">len</span><span class="p">(</span><span class="n">userIDs</span><span class="p">))</span>
  <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">id</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">userIDs</span> <span class="p">{</span>
    <span class="n">argUserIDs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">id</span>
  <span class="p">}</span>

  <span class="k">var</span> <span class="n">placeholders</span> <span class="kt">string</span>
  <span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">userIDs</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
    <span class="n">placeholders</span> <span class="o">+=</span> <span class="s">"?"</span>
    <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">userIDs</span><span class="p">)</span><span class="o">-</span><span class="m">1</span> <span class="p">{</span>
      <span class="n">placeholders</span> <span class="o">+=</span> <span class="s">","</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="n">query</span> <span class="o">:=</span> <span class="n">fmt</span><span class="o">.</span><span class="n">Sprintf</span><span class="p">(</span><span class="s">"SELECT * FROM users WHERE id IN (%s)"</span><span class="p">,</span> <span class="n">placeholders</span><span class="p">)</span>
  <span class="n">stmt</span><span class="p">,</span> <span class="n">err</span> <span class="o">:=</span> <span class="n">db</span><span class="o">.</span><span class="n">Prepare</span><span class="p">(</span><span class="n">query</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">err</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
    <span class="k">return</span> <span class="no">nil</span><span class="p">,</span> <span class="n">err</span>
  <span class="p">}</span>

  <span class="n">rows</span><span class="p">,</span> <span class="n">err</span> <span class="o">:=</span> <span class="n">stmt</span><span class="o">.</span><span class="n">Query</span><span class="p">(</span><span class="n">argUserIDs</span><span class="o">...</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">err</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
    <span class="k">return</span> <span class="no">nil</span><span class="p">,</span> <span class="n">err</span>
  <span class="p">}</span>
  <span class="k">defer</span> <span class="n">rows</span><span class="o">.</span><span class="n">Close</span><span class="p">()</span>

  <span class="k">var</span> <span class="n">users</span> <span class="p">[]</span><span class="o">*</span><span class="n">User</span>
  <span class="k">for</span> <span class="n">rows</span><span class="o">.</span><span class="n">Next</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">var</span> <span class="n">user</span> <span class="n">User</span>
    <span class="k">if</span> <span class="n">err</span> <span class="o">:=</span> <span class="n">rows</span><span class="o">.</span><span class="n">Scan</span><span class="p">(</span><span class="o">&amp;</span><span class="n">user</span><span class="o">.</span><span class="n">ID</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">user</span><span class="o">.</span><span class="n">Username</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">user</span><span class="o">.</span><span class="n">Age</span><span class="p">);</span> <span class="n">err</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
      <span class="k">return</span> <span class="no">nil</span><span class="p">,</span> <span class="n">err</span>
    <span class="p">}</span>
    <span class="n">users</span> <span class="o">=</span> <span class="nb">append</span><span class="p">(</span><span class="n">users</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">user</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">users</span><span class="p">,</span> <span class="no">nil</span>
<span class="p">}</span>
</code></pre></div></div>

<p>When the incident occurred, the system continuously logged the following error message: <code class="language-plaintext highlighter-rouge">Error - 1461: Can't create more than max_prepared_stmt_count statements (current value: 16382)</code>. As a result of this error, every <code class="language-plaintext highlighter-rouge">CREATE</code>, <code class="language-plaintext highlighter-rouge">SELECT</code>, <code class="language-plaintext highlighter-rouge">UPDATE</code>, and <code class="language-plaintext highlighter-rouge">DELETE</code> command failed with the error mentioned earlier, rendering the service unavailable for several hours.</p>

<p>Just to provide you with some background information, MySQL incorporates a system variable known as <a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_max_prepared_stmt_count"><code class="language-plaintext highlighter-rouge">max_prepared_stmt_count</code></a>. This variable establishes a threshold for the maximum number of prepared statements permitted on the server, encompassing all connections. If the limit is reached and the client persists in requesting the server to prepare additional statements, the server will issue an error message: <code class="language-plaintext highlighter-rouge">Error 1461: Can't create more than max_prepared_stmt_count statements (current value: ...)</code>. Notably, the default value assigned to this variable is 16382, as indicated in the previously mentioned error message.</p>

<p>But why did the incident take place? Let‚Äôs examine the function <code class="language-plaintext highlighter-rouge">findUsers</code> more closely. In <code class="language-plaintext highlighter-rouge">findUsers</code>, different value placeholders are created for varying lengths of <code class="language-plaintext highlighter-rouge">userIDs</code>, causing the database to generate distinct prepared statements. The error mentioned above occurs when there are more than 16382 unique prepared statements.</p>

<p>So, is the prepared statement solely responsible for the incident? I don‚Äôt think so. Before drawing any conclusions, it‚Äôs wise to understand how prepared statements function.</p>

<h1 id="understanding-prepared-statement">Understanding Prepared Statement</h1>

<p>When a client submits a SQL statement containing parameter placeholders and their corresponding arguments, several message exchanges take place behind the scenes:</p>

<ol>
  <li>The client sends a SQL statement with placeholders to the server for preparation.</li>
  <li>The server prepares (compiles) the statement and responses the client with a statement ID.</li>
  <li>The client sends the statement ID along with the corresponding arguments to the server.</li>
  <li>The server executes the statement and responses the client with a result.</li>
  <li>The clients can <strong>optionally</strong> request the server to deallocate the prepared statement.</li>
</ol>

<p>As you can see, there are two additional roundtrips (step 3 + step 4, and step 5) compared to the case where a prepared statement is not applied. To achieve both security, convenience and efficiency (efficiency the right way üòÑ), you have to sacrifice additional roundtrips.</p>

<p>In Go, there are at least 3 different approaches to work with SQL prepared statements:</p>

<ul>
  <li><strong>Explicit prepared statement</strong> and <strong>implicit prepared statement</strong> **using <a href="https://github.com/golang/go/tree/master/src/database/sql">standard library</a></li>
  <li><strong>Implicit prepared statement</strong> using <a href="https://gorm.io/">GORM</a></li>
</ul>

<h2 id="explicit-prepared-statement-in-standard-library">Explicit Prepared Statement in Standard Library</h2>

<p><strong>TL;DR</strong>: The client uses <code class="language-plaintext highlighter-rouge">db.Prepare</code> to request the server to prepare a statement, sending the <a href="https://dev.mysql.com/doc/dev/mysql-server/latest/page_protocol_com_stmt_prepare.html"><code class="language-plaintext highlighter-rouge">COM_STMT_PREPARE</code></a> command. In response, the server provides a statement ID. Subsequently, the client employs <code class="language-plaintext highlighter-rouge">stmt.QueryRow</code> to send the <a href="https://dev.mysql.com/doc/dev/mysql-server/latest/page_protocol_com_stmt_execute.html">COM_STMT_EXECUTE</a> command, requesting the server to execute the statement. Lastly, the client uses <code class="language-plaintext highlighter-rouge">stmt.Close</code> to send the <a href="https://dev.mysql.com/doc/dev/mysql-server/latest/page_protocol_com_stmt_close.html">COM_STMT_CLOSE</a> command, asking the server to close the prepared statement.</p>

<p>This is an code snippet that describes how you can use explicit prepared statement:</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="m">1</span>   <span class="n">db</span><span class="p">,</span> <span class="n">err</span> <span class="o">:=</span> <span class="n">sql</span><span class="o">.</span><span class="n">Open</span><span class="p">(</span><span class="s">"mysql"</span><span class="p">,</span> <span class="s">"mysql://user:pass@localhost:3306/dbname"</span><span class="p">)</span>
<span class="m">2</span>   <span class="k">if</span> <span class="n">err</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
<span class="m">3</span>     <span class="n">log</span><span class="o">.</span><span class="n">Fatal</span><span class="p">(</span><span class="n">err</span><span class="p">)</span>
<span class="m">4</span>   <span class="p">}</span>
<span class="m">5</span>
<span class="m">6</span>   <span class="n">stmt</span><span class="p">,</span> <span class="n">err</span> <span class="o">:=</span> <span class="n">db</span><span class="o">.</span><span class="n">Prepare</span><span class="p">(</span><span class="s">"SELECT * FROM album WHERE id = ?"</span><span class="p">)</span>
<span class="m">7</span>   <span class="k">if</span> <span class="n">err</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
<span class="m">8</span>	   <span class="n">log</span><span class="o">.</span><span class="n">Fatal</span><span class="p">(</span><span class="n">err</span><span class="p">)</span>
<span class="m">9</span>   <span class="p">}</span>
<span class="m">10</span>  <span class="k">defer</span> <span class="n">stmt</span><span class="o">.</span><span class="n">Close</span><span class="p">()</span>
<span class="m">11</span> 
<span class="m">12</span>  <span class="k">var</span> <span class="n">album</span> <span class="n">Album</span>
<span class="m">13</span>  <span class="n">rows</span><span class="p">,</span><span class="n">err</span> <span class="o">:=</span> <span class="n">stmt</span><span class="o">.</span><span class="n">QueryRow</span><span class="p">(</span><span class="n">id</span><span class="p">)</span><span class="o">.</span><span class="n">Scan</span><span class="p">(</span><span class="o">&amp;</span><span class="n">album</span><span class="o">.</span><span class="n">ID</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">album</span><span class="o">.</span><span class="n">Title</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">album</span><span class="o">.</span><span class="n">Artist</span><span class="p">)</span>
<span class="m">14</span>  <span class="k">if</span> <span class="n">err</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
<span class="m">14</span>    <span class="n">log</span><span class="o">.</span><span class="n">Fatal</span><span class="p">(</span><span class="n">err</span><span class="p">)</span>
<span class="m">15</span>  <span class="p">}</span>
<span class="m">16</span>  <span class="k">defer</span> <span class="n">rows</span><span class="o">.</span><span class="n">Close</span><span class="p">()</span>
</code></pre></div></div>

<p>In <a href="Prepared%20Statement%20in%20MySQL%20and%20Go%207a81af3563ee4ad69cfcff80ac65fa49.md">Figure 1</a>, the method <code class="language-plaintext highlighter-rouge">Prepare</code> at line 6 tells server to prepare the statement <code class="language-plaintext highlighter-rouge">SELECT * FROM album WHERE id = ?</code>. Internally, <code class="language-plaintext highlighter-rouge">db.Prepare</code> will eventually invokes the method <code class="language-plaintext highlighter-rouge">Prepare</code> of <code class="language-plaintext highlighter-rouge">*mysqlConn</code>, which resides in package <a href="https://github.com/go-sql-driver/mysql">github.com/go-sql-driver/mysql</a>, as shown in <a href="Prepared%20Statement%20in%20MySQL%20and%20Go%207a81af3563ee4ad69cfcff80ac65fa49.md">Figure 2</a>.</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="m">1</span>  <span class="k">package</span> <span class="n">mysql</span>
 <span class="m">2</span>  
 <span class="m">3</span>  <span class="k">func</span> <span class="p">(</span><span class="n">mc</span> <span class="o">*</span><span class="n">mysqlConn</span><span class="p">)</span> <span class="n">Prepare</span><span class="p">(</span><span class="n">query</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="n">driver</span><span class="o">.</span><span class="n">Stmt</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
 <span class="m">4</span>    <span class="o">...</span>
 <span class="m">5</span>    <span class="c">// Send command</span>
 <span class="m">6</span>    <span class="n">err</span> <span class="o">:=</span> <span class="n">mc</span><span class="o">.</span><span class="n">writeCommandPacketStr</span><span class="p">(</span><span class="n">comStmtPrepare</span><span class="p">,</span> <span class="n">query</span><span class="p">)</span>
 <span class="m">7</span>    <span class="o">...</span>
 <span class="m">8</span>    <span class="c">// Read Result</span>
 <span class="m">9</span>    <span class="n">columnCount</span><span class="p">,</span> <span class="n">err</span> <span class="o">:=</span> <span class="n">stmt</span><span class="o">.</span><span class="n">readPrepareResultPacket</span><span class="p">()</span>
<span class="m">10</span>    <span class="o">...</span>
<span class="m">11</span>  <span class="p">}</span>
</code></pre></div></div>

<p>Let‚Äôs analyze <a href="Prepared%20Statement%20in%20MySQL%20and%20Go%207a81af3563ee4ad69cfcff80ac65fa49.md">Figure 2</a>. In this figure, we can see that at line 6, the method <code class="language-plaintext highlighter-rouge">writeCommandPacketStr</code> sends command <a href="https://dev.mysql.com/doc/dev/mysql-server/latest/page_protocol_com_stmt_prepare.html"><code class="language-plaintext highlighter-rouge">COM_STMT_PREPARE</code></a> to the server. Then, at line 9, the client reads the <a href="https://dev.mysql.com/doc/dev/mysql-server/latest/page_protocol_com_stmt_prepare.html#sect_protocol_com_stmt_prepare_response"><code class="language-plaintext highlighter-rouge">COM_STMT_PREPARE</code> response</a> to extract the statement ID that server has prepared and saves it to the variable <code class="language-plaintext highlighter-rouge">stmt</code> (more details can be found <a href="https://github.com/go-sql-driver/mysql/blob/v1.7.1/packets.go#L838">here</a>).</p>

<p>Back to <a href="Prepared%20Statement%20in%20MySQL%20and%20Go%207a81af3563ee4ad69cfcff80ac65fa49.md">Figure 1</a>, the client sends statement ID along with corresponding arguments to the server by <code class="language-plaintext highlighter-rouge">stmt.QueryRow(id)</code>. Note that the parameter <code class="language-plaintext highlighter-rouge">id</code> here is the ID of the <code class="language-plaintext highlighter-rouge">Album</code> in question, not the statement ID. Internally, <code class="language-plaintext highlighter-rouge">QueryRow</code> will eventually invoke the method <code class="language-plaintext highlighter-rouge">query</code> of <code class="language-plaintext highlighter-rouge">*mysqlStmt</code> as in <a href="Prepared%20Statement%20in%20MySQL%20and%20Go%207a81af3563ee4ad69cfcff80ac65fa49.md">Figure 3</a>. The method <code class="language-plaintext highlighter-rouge">writeExecutePacket</code> sends command <a href="https://dev.mysql.com/doc/dev/mysql-server/latest/page_protocol_com_stmt_execute.html">COM_STMT_EXECUTE</a> to the server. This command instructs the server to execute a prepared statement based on the statement ID provided. After that, in the method <code class="language-plaintext highlighter-rouge">readResultSetHeaderPacket</code>, the clients read the <a href="https://dev.mysql.com/doc/dev/mysql-server/latest/page_protocol_com_stmt_execute_response.html">COM_STMT_EXECUTE response</a> to extract the result set and convert it to an instance of <code class="language-plaintext highlighter-rouge">binaryRows</code>.</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="m">1</span>  <span class="k">package</span> <span class="n">mysql</span>
 <span class="m">2</span>  
 <span class="m">3</span>  <span class="k">func</span> <span class="p">(</span><span class="n">stmt</span> <span class="o">*</span><span class="n">mysqlStmt</span><span class="p">)</span> <span class="n">query</span><span class="p">(</span><span class="n">args</span> <span class="p">[]</span><span class="n">driver</span><span class="o">.</span><span class="n">Value</span><span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="n">binaryRows</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
 <span class="m">4</span>    <span class="o">...</span>
 <span class="m">5</span>    <span class="c">// Send command</span>
 <span class="m">6</span>    <span class="n">err</span> <span class="o">:=</span> <span class="n">stmt</span><span class="o">.</span><span class="n">writeExecutePacket</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
 <span class="m">7</span>    <span class="k">if</span> <span class="n">err</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
 <span class="m">8</span>      <span class="k">return</span> <span class="no">nil</span><span class="p">,</span> <span class="n">stmt</span><span class="o">.</span><span class="n">mc</span><span class="o">.</span><span class="n">markBadConn</span><span class="p">(</span><span class="n">err</span><span class="p">)</span>
 <span class="m">9</span>    <span class="p">}</span>
<span class="m">10</span>    <span class="o">...</span>
<span class="m">11</span>    <span class="c">// Read Result</span>
<span class="m">12</span>    <span class="n">resLen</span><span class="p">,</span> <span class="n">err</span> <span class="o">:=</span> <span class="n">mc</span><span class="o">.</span><span class="n">readResultSetHeaderPacket</span><span class="p">()</span>
<span class="m">13</span>    <span class="k">if</span> <span class="n">err</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
<span class="m">14</span>      <span class="k">return</span> <span class="no">nil</span><span class="p">,</span> <span class="n">err</span>
<span class="m">15</span>    <span class="p">}</span>
<span class="m">16</span>    <span class="o">...</span>
<span class="m">17</span>    <span class="k">if</span> <span class="n">resLen</span> <span class="o">&gt;</span> <span class="m">0</span> <span class="p">{</span>
<span class="m">18</span>      <span class="o">...</span>
<span class="m">19</span>      <span class="n">rows</span><span class="o">.</span><span class="n">rs</span><span class="o">.</span><span class="n">columns</span><span class="p">,</span> <span class="n">err</span> <span class="o">=</span> <span class="n">mc</span><span class="o">.</span><span class="n">readColumns</span><span class="p">(</span><span class="n">resLen</span><span class="p">)</span>
<span class="m">20</span>    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
<span class="m">21</span>      <span class="o">...</span>
<span class="m">22</span>    <span class="p">}</span>
<span class="m">23</span>    <span class="o">...</span>
<span class="m">24</span>  <span class="p">}</span>
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">Scan</code> method in <a href="Prepared%20Statement%20in%20MySQL%20and%20Go%207a81af3563ee4ad69cfcff80ac65fa49.md">Figure 1</a> will use this instance to scan an instance of <code class="language-plaintext highlighter-rouge">Album</code>. At the end of <a href="Prepared%20Statement%20in%20MySQL%20and%20Go%207a81af3563ee4ad69cfcff80ac65fa49.md">Figure 1</a>, <code class="language-plaintext highlighter-rouge">rows.Close()</code> is called, which will invoke the method <code class="language-plaintext highlighter-rouge">Close</code> of <code class="language-plaintext highlighter-rouge">*myStmt</code> as <a href="Prepared%20Statement%20in%20MySQL%20and%20Go%207a81af3563ee4ad69cfcff80ac65fa49.md">Figure 4</a>. In the method <code class="language-plaintext highlighter-rouge">writeCommandPacketUint32</code>, the client sends command <a href="https://dev.mysql.com/doc/dev/mysql-server/latest/page_protocol_com_stmt_close.html"><code class="language-plaintext highlighter-rouge">COM_STMT_CLOSE</code></a> to the server to make the prepared statement deallocated, ensuring no memory leak occurs.</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="m">1</span>  <span class="k">package</span> <span class="n">mysql</span>
 <span class="m">2</span>  
 <span class="m">3</span>  <span class="k">func</span> <span class="p">(</span><span class="n">stmt</span> <span class="o">*</span><span class="n">mysqlStmt</span><span class="p">)</span> <span class="n">Close</span><span class="p">()</span> <span class="kt">error</span> <span class="p">{</span>
 <span class="m">4</span>    <span class="o">...</span>
 <span class="m">5</span>    <span class="n">err</span> <span class="o">:=</span> <span class="n">stmt</span><span class="o">.</span><span class="n">mc</span><span class="o">.</span><span class="n">writeCommandPacketUint32</span><span class="p">(</span><span class="n">comStmtClose</span><span class="p">,</span> <span class="n">stmt</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>
 <span class="m">6</span>    <span class="o">...</span>
 <span class="m">7</span>  <span class="p">}</span>
</code></pre></div></div>

<h2 id="implicit-prepared-statement-in-standard-library">Implicit Prepared Statement in Standard Library</h2>

<p><strong>TL;DR</strong>: The client utilizes <code class="language-plaintext highlighter-rouge">db.Query</code> to send the <a href="https://dev.mysql.com/doc/dev/mysql-server/latest/page_protocol_com_stmt_prepare.html"><code class="language-plaintext highlighter-rouge">COM_STMT_PREPARE</code></a> and <a href="https://dev.mysql.com/doc/dev/mysql-server/latest/page_protocol_com_stmt_execute.html"><code class="language-plaintext highlighter-rouge">COM_STMT_EXECUTE</code></a> commands to the server, requesting it to prepare and execute a statement. Finally, the client employs <code class="language-plaintext highlighter-rouge">stmt.Close</code> to send the <a href="https://dev.mysql.com/doc/dev/mysql-server/latest/page_protocol_com_stmt_close.html"><code class="language-plaintext highlighter-rouge">COM_STMT_CLOSE</code></a> command to the server, asking it to close the prepared statement. If the <a href="https://github.com/go-sql-driver/mysql#interpolateparams"><code class="language-plaintext highlighter-rouge">InterpolateParams</code></a> configuration is enabled, the client will send command <a href="https://dev.mysql.com/doc/dev/mysql-server/latest/page_protocol_com_query.html"><code class="language-plaintext highlighter-rouge">COM_QUERY</code></a> and let the server execute the statement filled with interpolated arguments instead of using a prepared statement.</p>

<p>Working with implicit prepared statement is easier by passing prepared statement arguments (<code class="language-plaintext highlighter-rouge">id</code> in <a href="Prepared%20Statement%20in%20MySQL%20and%20Go%207a81af3563ee4ad69cfcff80ac65fa49.md">Figure 5</a>) to <code class="language-plaintext highlighter-rouge">db.Query</code> apart from the SQL statement as first argument. If there is no prepared statement argument, the client sends a non-prepared statement to the database server (i.e. the client sends command <a href="https://dev.mysql.com/doc/dev/mysql-server/latest/page_protocol_com_query.html"><code class="language-plaintext highlighter-rouge">COM_QUERY</code></a> instead of <a href="https://dev.mysql.com/doc/dev/mysql-server/latest/page_protocol_com_stmt_prepare.html"><code class="language-plaintext highlighter-rouge">COM_STMT_PREPARE</code></a> to the server).</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="m">1</span>   <span class="n">db</span><span class="p">,</span> <span class="n">err</span> <span class="o">:=</span> <span class="n">sql</span><span class="o">.</span><span class="n">Open</span><span class="p">(</span><span class="s">"mysql"</span><span class="p">,</span> <span class="s">"mysql://user:pass@localhost:3306/dbname"</span><span class="p">)</span>
 <span class="m">2</span>   <span class="k">if</span> <span class="n">err</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
 <span class="m">3</span>     <span class="n">log</span><span class="o">.</span><span class="n">Fatal</span><span class="p">(</span><span class="n">err</span><span class="p">)</span>
 <span class="m">4</span>   <span class="p">}</span>
 <span class="m">5</span> 
 <span class="m">6</span>   <span class="n">rows</span><span class="p">,</span> <span class="n">err</span> <span class="o">:=</span> <span class="n">db</span><span class="o">.</span><span class="n">Query</span><span class="p">(</span><span class="s">"SELECT * FROM album WHERE id = ?"</span><span class="p">,</span> <span class="n">id</span><span class="p">)</span>
 <span class="m">7</span>   <span class="k">if</span> <span class="n">err</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
 <span class="m">8</span>     <span class="n">log</span><span class="o">.</span><span class="n">Fatal</span><span class="p">(</span><span class="n">err</span><span class="p">)</span>
 <span class="m">9</span>   <span class="p">}</span>
<span class="m">10</span>   <span class="k">defer</span> <span class="n">rows</span><span class="o">.</span><span class="n">Close</span><span class="p">()</span>
<span class="m">11</span>  
<span class="m">12</span>   <span class="k">var</span> <span class="n">album</span> <span class="n">Album</span>
<span class="m">13</span>   <span class="n">err</span> <span class="o">=</span> <span class="n">rows</span><span class="o">.</span><span class="n">Scan</span><span class="p">(</span><span class="o">&amp;</span><span class="n">album</span><span class="o">.</span><span class="n">ID</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">album</span><span class="o">.</span><span class="n">Title</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">album</span><span class="o">.</span><span class="n">Artist</span><span class="p">)</span>
<span class="m">14</span>   <span class="k">if</span> <span class="n">err</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
<span class="m">15</span>     <span class="n">log</span><span class="o">.</span><span class="n">Fatal</span><span class="p">(</span><span class="n">err</span><span class="p">)</span>
<span class="m">16</span>   <span class="p">}</span>
</code></pre></div></div>

<p>Line 6 in <a href="Prepared%20Statement%20in%20MySQL%20and%20Go%207a81af3563ee4ad69cfcff80ac65fa49.md">Figure 5</a> tells the server to prepare the statement <code class="language-plaintext highlighter-rouge">SELECT * FROM album WHERE id = ?</code> and executes the statement with the argument <code class="language-plaintext highlighter-rouge">id</code>. All of those things happen in the method <code class="language-plaintext highlighter-rouge">db.Query</code>. Internally, <code class="language-plaintext highlighter-rouge">db.Query</code> invokes the method <code class="language-plaintext highlighter-rouge">queryDC</code>, which resides in package <code class="language-plaintext highlighter-rouge">database/sql</code>, as described in <a href="Prepared%20Statement%20in%20MySQL%20and%20Go%207a81af3563ee4ad69cfcff80ac65fa49.md">Figure 6</a>.</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="m">1</span>  <span class="k">package</span> <span class="n">sql</span>
 <span class="m">2</span>  
 <span class="m">3</span>  <span class="k">func</span> <span class="p">(</span><span class="n">db</span> <span class="o">*</span><span class="n">DB</span><span class="p">)</span> <span class="n">queryDC</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">txctx</span> <span class="n">context</span><span class="o">.</span><span class="n">Context</span><span class="p">,</span> <span class="n">dc</span> <span class="o">*</span><span class="n">driverConn</span><span class="p">,</span> <span class="n">releaseConn</span> <span class="k">func</span><span class="p">(</span><span class="kt">error</span><span class="p">),</span> <span class="n">query</span> <span class="kt">string</span><span class="p">,</span> <span class="n">args</span> <span class="p">[]</span><span class="n">any</span><span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="n">Rows</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
 <span class="m">4</span>    <span class="o">...</span>
 <span class="m">5</span>    <span class="n">withLock</span><span class="p">(</span><span class="n">dc</span><span class="p">,</span> <span class="k">func</span><span class="p">()</span> <span class="p">{</span>
 <span class="m">6</span>      <span class="n">nvdargs</span><span class="p">,</span> <span class="n">err</span> <span class="o">=</span> <span class="n">driverArgsConnLocked</span><span class="p">(</span><span class="n">dc</span><span class="o">.</span><span class="n">ci</span><span class="p">,</span> <span class="no">nil</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span>
 <span class="m">7</span>      <span class="k">if</span> <span class="n">err</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
 <span class="m">8</span>        <span class="k">return</span>
 <span class="m">9</span>      <span class="p">}</span>
<span class="m">10</span>      <span class="n">rowsi</span><span class="p">,</span> <span class="n">err</span> <span class="o">=</span> <span class="n">ctxDriverQuery</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">queryerCtx</span><span class="p">,</span> <span class="n">queryer</span><span class="p">,</span> <span class="n">query</span><span class="p">,</span> <span class="n">nvdargs</span><span class="p">)</span>
<span class="m">11</span>    <span class="p">})</span>
<span class="m">12</span>    <span class="k">if</span> <span class="n">err</span> <span class="o">!=</span> <span class="n">driver</span><span class="o">.</span><span class="n">ErrSkip</span> <span class="p">{</span>
<span class="m">13</span>      <span class="k">if</span> <span class="n">err</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
<span class="m">14</span>        <span class="n">releaseConn</span><span class="p">(</span><span class="n">err</span><span class="p">)</span>
<span class="m">15</span>        <span class="k">return</span> <span class="no">nil</span><span class="p">,</span> <span class="n">err</span>
<span class="m">16</span>      <span class="p">}</span>
<span class="m">17</span>      <span class="o">...</span>
<span class="m">18</span>      <span class="k">return</span> <span class="n">rows</span><span class="p">,</span> <span class="no">nil</span>
<span class="m">19</span>    <span class="p">}</span>
<span class="m">20</span>    <span class="o">...</span>
<span class="m">21</span>    <span class="n">withLock</span><span class="p">(</span><span class="n">dc</span><span class="p">,</span> <span class="k">func</span><span class="p">()</span> <span class="p">{</span>
<span class="m">22</span>      <span class="n">si</span><span class="p">,</span> <span class="n">err</span> <span class="o">=</span> <span class="n">ctxDriverPrepare</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">dc</span><span class="o">.</span><span class="n">ci</span><span class="p">,</span> <span class="n">query</span><span class="p">)</span>
<span class="m">23</span>    <span class="p">})</span>
<span class="m">24</span>    <span class="o">...</span>
<span class="m">25</span>    <span class="n">ds</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="n">driverStmt</span><span class="p">{</span><span class="n">Locker</span><span class="o">:</span> <span class="n">dc</span><span class="p">,</span> <span class="n">si</span><span class="o">:</span> <span class="n">si</span><span class="p">}</span>
<span class="m">26</span>    <span class="n">rowsi</span><span class="p">,</span> <span class="n">err</span> <span class="o">:=</span> <span class="n">rowsiFromStatement</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">dc</span><span class="o">.</span><span class="n">ci</span><span class="p">,</span> <span class="n">ds</span><span class="p">,</span> <span class="n">args</span><span class="o">...</span><span class="p">)</span>
<span class="m">27</span>    <span class="k">if</span> <span class="n">err</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
<span class="m">28</span>      <span class="n">ds</span><span class="o">.</span><span class="n">Close</span><span class="p">()</span>
<span class="m">29</span>      <span class="n">releaseConn</span><span class="p">(</span><span class="n">err</span><span class="p">)</span>
<span class="m">30</span>      <span class="k">return</span> <span class="no">nil</span><span class="p">,</span> <span class="n">err</span>
<span class="m">31</span>    <span class="p">}</span>
<span class="m">32</span>    <span class="o">...</span>
<span class="m">33</span>    <span class="n">rows</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="n">Rows</span><span class="p">{</span>
<span class="m">34</span>      <span class="n">dc</span><span class="o">:</span>          <span class="n">dc</span><span class="p">,</span>
<span class="m">35</span>      <span class="n">releaseConn</span><span class="o">:</span> <span class="n">releaseConn</span><span class="p">,</span>
<span class="m">36</span>      <span class="n">rowsi</span><span class="o">:</span>       <span class="n">rowsi</span><span class="p">,</span>
<span class="m">37</span>      <span class="n">closeStmt</span><span class="o">:</span>   <span class="n">ds</span><span class="p">,</span>
<span class="m">38</span>    <span class="p">}</span>
<span class="m">39</span>    <span class="n">rows</span><span class="o">.</span><span class="n">initContextClose</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">txctx</span><span class="p">)</span>
<span class="m">40</span>    <span class="k">return</span> <span class="n">rows</span><span class="p">,</span> <span class="no">nil</span>
<span class="m">41</span>  <span class="p">}</span>
</code></pre></div></div>

<p>In <a href="Prepared%20Statement%20in%20MySQL%20and%20Go%207a81af3563ee4ad69cfcff80ac65fa49.md">Figure 6</a>, <code class="language-plaintext highlighter-rouge">ctxDriverQuery</code> will invokes method <code class="language-plaintext highlighter-rouge">query</code> of <code class="language-plaintext highlighter-rouge">*mysqlConn</code> as shown <a href="Prepared%20Statement%20in%20MySQL%20and%20Go%207a81af3563ee4ad69cfcff80ac65fa49.md">Figure 7</a>. In the <code class="language-plaintext highlighter-rouge">query</code> method, the client first checks the flag <code class="language-plaintext highlighter-rouge">InterpolateParams</code> to decide whether or not to use a non-prepared statement. If this flag is <code class="language-plaintext highlighter-rouge">true</code> and there are at least one arguments then it will 1) interpolate parameters and feed them into the statement, 2) send the <a href="https://dev.mysql.com/doc/dev/mysql-server/latest/page_protocol_com_query.html"><code class="language-plaintext highlighter-rouge">COM_QUERY</code></a> to the database with the statement <code class="language-plaintext highlighter-rouge">SELECT * FROM album WHERE id = 322</code> for example, 3) read the <a href="https://dev.mysql.com/doc/dev/mysql-server/latest/page_protocol_com_query_response.html"><code class="language-plaintext highlighter-rouge">COM_QUERY</code> response</a> to extract the result set and 4) convert the response to an instance of <code class="language-plaintext highlighter-rouge">textRows</code>. Else, it returns <code class="language-plaintext highlighter-rouge">driver.ErrSkip</code> to the caller (i.e. <code class="language-plaintext highlighter-rouge">queryDC</code> in <a href="Prepared%20Statement%20in%20MySQL%20and%20Go%207a81af3563ee4ad69cfcff80ac65fa49.md">Figure 6</a>).</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="m">1</span>  <span class="k">package</span> <span class="n">mysql</span>
 <span class="m">2</span>  
 <span class="m">3</span>  <span class="k">func</span> <span class="p">(</span><span class="n">mc</span> <span class="o">*</span><span class="n">mysqlConn</span><span class="p">)</span> <span class="n">query</span><span class="p">(</span><span class="n">query</span> <span class="kt">string</span><span class="p">,</span> <span class="n">args</span> <span class="p">[]</span><span class="n">driver</span><span class="o">.</span><span class="n">Value</span><span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="n">textRows</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
 <span class="m">4</span>    <span class="o">...</span>
 <span class="m">5</span>    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">!=</span> <span class="m">0</span> <span class="p">{</span>
 <span class="m">6</span>      <span class="k">if</span> <span class="o">!</span><span class="n">mc</span><span class="o">.</span><span class="n">cfg</span><span class="o">.</span><span class="n">InterpolateParams</span> <span class="p">{</span>
 <span class="m">7</span>        <span class="k">return</span> <span class="no">nil</span><span class="p">,</span> <span class="n">driver</span><span class="o">.</span><span class="n">ErrSkip</span>
 <span class="m">8</span>      <span class="p">}</span>
 <span class="m">9</span>      <span class="c">// try client-side prepare to reduce roundtrip</span>
<span class="m">10</span>      <span class="n">prepared</span><span class="p">,</span> <span class="n">err</span> <span class="o">:=</span> <span class="n">mc</span><span class="o">.</span><span class="n">interpolateParams</span><span class="p">(</span><span class="n">query</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span>
<span class="m">11</span>      <span class="k">if</span> <span class="n">err</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
<span class="m">12</span>         <span class="k">return</span> <span class="no">nil</span><span class="p">,</span> <span class="n">err</span>
<span class="m">13</span>       <span class="p">}</span>
<span class="m">14</span>       <span class="n">query</span> <span class="o">=</span> <span class="n">prepared</span>
<span class="m">15</span>     <span class="p">}</span>
<span class="m">16</span>    <span class="c">// Send command</span>
<span class="m">17</span>    <span class="n">err</span> <span class="o">:=</span> <span class="n">mc</span><span class="o">.</span><span class="n">writeCommandPacketStr</span><span class="p">(</span><span class="n">comQuery</span><span class="p">,</span> <span class="n">query</span><span class="p">)</span>
<span class="m">18</span>    <span class="k">if</span> <span class="n">err</span> <span class="o">==</span> <span class="no">nil</span> <span class="p">{</span>
<span class="m">19</span>      <span class="c">// Read Result</span>
<span class="m">20</span>      <span class="k">var</span> <span class="n">resLen</span> <span class="kt">int</span>
<span class="m">21</span>      <span class="n">resLen</span><span class="p">,</span> <span class="n">err</span> <span class="o">=</span> <span class="n">mc</span><span class="o">.</span><span class="n">readResultSetHeaderPacket</span><span class="p">()</span>
<span class="m">22</span>      <span class="k">if</span> <span class="n">err</span> <span class="o">==</span> <span class="no">nil</span> <span class="p">{</span>
<span class="m">23</span>        <span class="o">...</span>
<span class="m">24</span>        <span class="c">// Columns</span>
<span class="m">25</span>        <span class="n">rows</span><span class="o">.</span><span class="n">rs</span><span class="o">.</span><span class="n">columns</span><span class="p">,</span> <span class="n">err</span> <span class="o">=</span> <span class="n">mc</span><span class="o">.</span><span class="n">readColumns</span><span class="p">(</span><span class="n">resLen</span><span class="p">)</span>
<span class="m">26</span>        <span class="k">return</span> <span class="n">rows</span><span class="p">,</span> <span class="n">err</span>
<span class="m">27</span>      <span class="p">}</span>
<span class="m">28</span>    <span class="p">}</span>
<span class="m">29</span>    <span class="k">return</span> <span class="no">nil</span><span class="p">,</span> <span class="n">mc</span><span class="o">.</span><span class="n">markBadConn</span><span class="p">(</span><span class="n">err</span><span class="p">)</span>
<span class="m">30</span>  <span class="p">}</span>
</code></pre></div></div>

<p>If <code class="language-plaintext highlighter-rouge">InterpolateParams</code> is <code class="language-plaintext highlighter-rouge">false</code>, the control will be back at line 22 in <a href="Prepared%20Statement%20in%20MySQL%20and%20Go%207a81af3563ee4ad69cfcff80ac65fa49.md">Figure 6</a>, or line 6 in <a href="Prepared%20Statement%20in%20MySQL%20and%20Go%207a81af3563ee4ad69cfcff80ac65fa49.md">Figure 6.1</a>. <code class="language-plaintext highlighter-rouge">ctxDriverPrepare</code> will invoke the method <code class="language-plaintext highlighter-rouge">Prepare</code> of <code class="language-plaintext highlighter-rouge">*mysqlConn</code> as in <a href="Prepared%20Statement%20in%20MySQL%20and%20Go%207a81af3563ee4ad69cfcff80ac65fa49.md">Figure 2</a>, in which the client sends command <a href="https://dev.mysql.com/doc/dev/mysql-server/latest/page_protocol_com_stmt_prepare.html"><code class="language-plaintext highlighter-rouge">COM_STMT_PREPARE</code></a> to the server. Next, <code class="language-plaintext highlighter-rouge">rowsiFromStatement</code> will eventually invokes the method <code class="language-plaintext highlighter-rouge">query</code> of <code class="language-plaintext highlighter-rouge">*mysqlStmt</code> as in <a href="Prepared%20Statement%20in%20MySQL%20and%20Go%207a81af3563ee4ad69cfcff80ac65fa49.md">Figure 3</a>, in which the client sends command <a href="https://dev.mysql.com/doc/dev/mysql-server/latest/page_protocol_com_stmt_execute.html"><code class="language-plaintext highlighter-rouge">COM_STMT_EXECUTE</code></a> to the server.</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="m">1</span>  <span class="k">package</span> <span class="n">sql</span>
 <span class="m">2</span>  
 <span class="m">3</span>  <span class="k">func</span> <span class="p">(</span><span class="n">db</span> <span class="o">*</span><span class="n">DB</span><span class="p">)</span> <span class="n">queryDC</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">txctx</span> <span class="n">context</span><span class="o">.</span><span class="n">Context</span><span class="p">,</span> <span class="n">dc</span> <span class="o">*</span><span class="n">driverConn</span><span class="p">,</span> <span class="n">releaseConn</span> <span class="k">func</span><span class="p">(</span><span class="kt">error</span><span class="p">),</span> <span class="n">query</span> <span class="kt">string</span><span class="p">,</span> <span class="n">args</span> <span class="p">[]</span><span class="n">any</span><span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="n">Rows</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
 <span class="m">4</span>    <span class="o">...</span>
 <span class="m">5</span>    <span class="n">withLock</span><span class="p">(</span><span class="n">dc</span><span class="p">,</span> <span class="k">func</span><span class="p">()</span> <span class="p">{</span>
 <span class="m">6</span>      <span class="n">si</span><span class="p">,</span> <span class="n">err</span> <span class="o">=</span> <span class="n">ctxDriverPrepare</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">dc</span><span class="o">.</span><span class="n">ci</span><span class="p">,</span> <span class="n">query</span><span class="p">)</span>
 <span class="m">7</span>    <span class="p">})</span>
 <span class="m">8</span>    <span class="o">...</span>
 <span class="m">9</span>    <span class="n">ds</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="n">driverStmt</span><span class="p">{</span><span class="n">Locker</span><span class="o">:</span> <span class="n">dc</span><span class="p">,</span> <span class="n">si</span><span class="o">:</span> <span class="n">si</span><span class="p">}</span>
<span class="m">10</span>    <span class="n">rowsi</span><span class="p">,</span> <span class="n">err</span> <span class="o">:=</span> <span class="n">rowsiFromStatement</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">dc</span><span class="o">.</span><span class="n">ci</span><span class="p">,</span> <span class="n">ds</span><span class="p">,</span> <span class="n">args</span><span class="o">...</span><span class="p">)</span>
<span class="m">11</span>    <span class="k">if</span> <span class="n">err</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
<span class="m">12</span>      <span class="n">ds</span><span class="o">.</span><span class="n">Close</span><span class="p">()</span>
<span class="m">13</span>      <span class="n">releaseConn</span><span class="p">(</span><span class="n">err</span><span class="p">)</span>
<span class="m">14</span>      <span class="k">return</span> <span class="no">nil</span><span class="p">,</span> <span class="n">err</span>
<span class="m">15</span>    <span class="p">}</span>
<span class="m">16</span>    <span class="o">...</span>
<span class="m">17</span>    <span class="n">rows</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="n">Rows</span><span class="p">{</span>
<span class="m">18</span>      <span class="n">dc</span><span class="o">:</span>          <span class="n">dc</span><span class="p">,</span>
<span class="m">19</span>      <span class="n">releaseConn</span><span class="o">:</span> <span class="n">releaseConn</span><span class="p">,</span>
<span class="m">20</span>      <span class="n">rowsi</span><span class="o">:</span>       <span class="n">rowsi</span><span class="p">,</span>
<span class="m">21</span>      <span class="n">closeStmt</span><span class="o">:</span>   <span class="n">ds</span><span class="p">,</span>
<span class="m">22</span>    <span class="p">}</span>
<span class="m">23</span>    <span class="n">rows</span><span class="o">.</span><span class="n">initContextClose</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">txctx</span><span class="p">)</span>
<span class="m">24</span>    <span class="k">return</span> <span class="n">rows</span><span class="p">,</span> <span class="no">nil</span>
<span class="m">25</span>  <span class="p">}</span>
</code></pre></div></div>

<p>Afterward, the control is back at line 13 in <a href="Prepared%20Statement%20in%20MySQL%20and%20Go%207a81af3563ee4ad69cfcff80ac65fa49.md">Figure 5</a>, where method <code class="language-plaintext highlighter-rouge">Scan</code> uses the instance of <code class="language-plaintext highlighter-rouge">Rows</code> returned by <code class="language-plaintext highlighter-rouge">queryDC</code> to scan an instance of <code class="language-plaintext highlighter-rouge">Album</code>. At the end of F<a href="Prepared%20Statement%20in%20MySQL%20and%20Go%207a81af3563ee4ad69cfcff80ac65fa49.md">igure 5</a>, <code class="language-plaintext highlighter-rouge">rows.Close()</code> is called, which will invoke the method <code class="language-plaintext highlighter-rouge">Close</code> of <code class="language-plaintext highlighter-rouge">*myStmt</code> as <a href="Prepared%20Statement%20in%20MySQL%20and%20Go%207a81af3563ee4ad69cfcff80ac65fa49.md">Figure 4</a>.</p>

<h2 id="implicit-prepared-statement-in-gorm">Implicit Prepared Statement in GORM</h2>

<p>In GORM, the logic is the same as implicit prepared statement in standard library because every DML (e.g. <code class="language-plaintext highlighter-rouge">Create</code>, <code class="language-plaintext highlighter-rouge">Find</code>, <code class="language-plaintext highlighter-rouge">First</code>, <code class="language-plaintext highlighter-rouge">Take</code>, <code class="language-plaintext highlighter-rouge">Update</code>, <code class="language-plaintext highlighter-rouge">Delete</code>) eventually invokes <code class="language-plaintext highlighter-rouge">queryDC</code> in <a href="Prepared%20Statement%20in%20MySQL%20and%20Go%207a81af3563ee4ad69cfcff80ac65fa49.md">Figure 6</a> or <a href="https://github.com/golang/go/blob/go1.20/src/database/sql/sql.go#L1658-L1695">execDC</a>. If there is no prepared statement arguments (i.e. <code class="language-plaintext highlighter-rouge">db.Statement.Vars</code> is empty), GORM never uses prepared statement. If there is at least one arguments (i.e. <code class="language-plaintext highlighter-rouge">db.Statement.Vars</code> is not empty), whether prepared statement is used or not depends on whether the configuration <code class="language-plaintext highlighter-rouge">InterpolateParams</code> is <code class="language-plaintext highlighter-rouge">true</code> or <code class="language-plaintext highlighter-rouge">false</code>.</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">callbacks</span>

<span class="c">// Create (https://github.com/go-gorm/gorm/blob/master/callbacks/create.go#L97-99)</span>
<span class="n">result</span><span class="p">,</span> <span class="n">err</span> <span class="o">:=</span> <span class="n">db</span><span class="o">.</span><span class="n">Statement</span><span class="o">.</span><span class="n">ConnPool</span><span class="o">.</span><span class="n">ExecContext</span><span class="p">(</span>
	<span class="n">db</span><span class="o">.</span><span class="n">Statement</span><span class="o">.</span><span class="n">Context</span><span class="p">,</span> <span class="n">db</span><span class="o">.</span><span class="n">Statement</span><span class="o">.</span><span class="n">SQL</span><span class="o">.</span><span class="n">String</span><span class="p">(),</span> <span class="n">db</span><span class="o">.</span><span class="n">Statement</span><span class="o">.</span><span class="n">Vars</span><span class="o">...</span><span class="p">,</span>
<span class="p">)</span>

<span class="c">// Find, First, Take (https://github.com/go-gorm/gorm/blob/master/callbacks/query.go#L20)</span>
<span class="n">rows</span><span class="p">,</span> <span class="n">err</span> <span class="o">:=</span> <span class="n">db</span><span class="o">.</span><span class="n">Statement</span><span class="o">.</span><span class="n">ConnPool</span><span class="o">.</span><span class="n">QueryContext</span><span class="p">(</span>
	<span class="n">db</span><span class="o">.</span><span class="n">Statement</span><span class="o">.</span><span class="n">Context</span><span class="p">,</span> <span class="n">db</span><span class="o">.</span><span class="n">Statement</span><span class="o">.</span><span class="n">SQL</span><span class="o">.</span><span class="n">String</span><span class="p">(),</span> <span class="n">db</span><span class="o">.</span><span class="n">Statement</span><span class="o">.</span><span class="n">Vars</span><span class="o">...</span>
<span class="p">)</span>

<span class="c">// Update (https://github.com/go-gorm/gorm/blob/master/callbacks/update.go#L97)</span>
<span class="n">result</span><span class="p">,</span> <span class="n">err</span> <span class="o">:=</span> <span class="n">db</span><span class="o">.</span><span class="n">Statement</span><span class="o">.</span><span class="n">ConnPool</span><span class="o">.</span><span class="n">ExecContext</span><span class="p">(</span>
	<span class="n">db</span><span class="o">.</span><span class="n">Statement</span><span class="o">.</span><span class="n">Context</span><span class="p">,</span> <span class="n">db</span><span class="o">.</span><span class="n">Statement</span><span class="o">.</span><span class="n">SQL</span><span class="o">.</span><span class="n">String</span><span class="p">(),</span> <span class="n">db</span><span class="o">.</span><span class="n">Statement</span><span class="o">.</span><span class="n">Vars</span><span class="o">...</span>
<span class="p">)</span>

<span class="c">// Delete (https://github.com/go-gorm/gorm/blob/master/callbacks/delete.go#L159)</span>
<span class="n">result</span><span class="p">,</span> <span class="n">err</span> <span class="o">:=</span> <span class="n">db</span><span class="o">.</span><span class="n">Statement</span><span class="o">.</span><span class="n">ConnPool</span><span class="o">.</span><span class="n">ExecContext</span><span class="p">(</span>
	<span class="n">db</span><span class="o">.</span><span class="n">Statement</span><span class="o">.</span><span class="n">Context</span><span class="p">,</span> <span class="n">db</span><span class="o">.</span><span class="n">Statement</span><span class="o">.</span><span class="n">SQL</span><span class="o">.</span><span class="n">String</span><span class="p">(),</span> <span class="n">db</span><span class="o">.</span><span class="n">Statement</span><span class="o">.</span><span class="n">Vars</span><span class="o">...</span>
<span class="p">)</span>
</code></pre></div></div>

<h1 id="caution-regarding-prepared-statement">Caution regarding Prepared Statement</h1>

<p>According to the original <a href="http://go-database-sql.org/prepared.html">document</a> of <code class="language-plaintext highlighter-rouge">database/sql</code>:</p>

<blockquote>
  <p>At the database level, a prepared statement is bound to a single database connection. The typical flow is that the client sends a SQL statement with placeholders to the server for preparation, the server responds with a statement ID, and then the client executes the statement by sending its ID and parameters.<br /><br />
In Go, however, connections are not exposed directly to the user of the¬†<code class="language-plaintext highlighter-rouge">database/sql</code>¬†package. You don‚Äôt prepare a statement on a connection. You prepare it on a¬†<code class="language-plaintext highlighter-rouge">DB</code>¬†or a¬†<code class="language-plaintext highlighter-rouge">Tx</code>. And¬†<code class="language-plaintext highlighter-rouge">database/sql</code>¬†has some convenience behaviors such as automatic retries. For these reasons, the underlying association between prepared statements and connections, which exists at the driver level, is hidden from your code.<br /><br />
Here‚Äôs how it works:<br />1. When you prepare a statement, it‚Äôs prepared on a connection in the pool.<br />2. The¬†<code class="language-plaintext highlighter-rouge">Stmt</code>¬†object remembers which connection was used.<br />3. When you execute the¬†<code class="language-plaintext highlighter-rouge">Stmt</code>, it tries to use the connection. If it‚Äôs not available because it‚Äôs closed or busy doing something else, it gets another connection from the pool¬†<em>and re-prepares the statement with the database on another connection.</em><br /><br />
Because statements will be re-prepared as needed when their original connection is busy, it‚Äôs possible for high-concurrency usage of the database, which may keep a lot of connections busy, to create a large number of prepared statements. This can result in apparent leaks of statements, statements being prepared and re-prepared more often than you think, and even running into server-side limits on the number of statements.</p>
</blockquote>

<p>Due to the fact that prepared statements are re-prepared whenever their original connection is busy, the occurrence of the error in the incident, specifically <code class="language-plaintext highlighter-rouge">Error - 1461: Can't create more than max_prepared_stmt_count statements (current value: ...)</code> is more likely. Therefore, it is crucial to handle prepared statements with caution and employ appropriate strategies.</p>

<h1 id="using-prepared-statement-the-right-way">Using Prepared Statement the Right Way</h1>

<p>So what is the root cause of the incident and how to use prepared statement properly?</p>

<h2 id="close-prepared-statement">Close Prepared Statement</h2>

<p>Have you noticed anything abnormal in <a href="Prepared%20Statement%20in%20MySQL%20and%20Go%207a81af3563ee4ad69cfcff80ac65fa49.md">Figure 0</a>? The prepared statement is never closed, meaning that it is never deallocated by the database server. <em>This is the root cause of the incident.</em></p>

<p>When we use explicit prepared statement, it is important to invoke both <code class="language-plaintext highlighter-rouge">stmt.Close</code> to close the prepared statement and invoke <code class="language-plaintext highlighter-rouge">rows.Close</code> to return the connection to the pool. In <a href="Prepared%20Statement%20in%20MySQL%20and%20Go%207a81af3563ee4ad69cfcff80ac65fa49.md">Figure 0</a>, because <code class="language-plaintext highlighter-rouge">stmt.Close</code> is not called, the prepared statement is not closed. This is the place where unfortunate events unfold merely due to neglecting a minor method call. üòÑ</p>

<p>When we use implicit prepared statement of standard library, we should always call <code class="language-plaintext highlighter-rouge">rows.Close</code> as line 10 in <a href="Prepared%20Statement%20in%20MySQL%20and%20Go%207a81af3563ee4ad69cfcff80ac65fa49.md">Figure 5</a>. <code class="language-plaintext highlighter-rouge">rows.Close</code> not only returns the connection to the pool but also closes the prepared statement.</p>

<p>When using GORM, there is no requirement to manually close <code class="language-plaintext highlighter-rouge">SELECT</code> prepared statements since GORM handles this internally (more details can be found <a href="https://github.com/go-gorm/gorm/blob/master/callbacks/query.go#L26">here</a>). For <code class="language-plaintext highlighter-rouge">CREATE</code>, <code class="language-plaintext highlighter-rouge">UPDATE</code>, and <code class="language-plaintext highlighter-rouge">DELETE</code> statements, GORM eventual invokes the standard library method <a href="https://github.com/golang/go/blob/go1.20/src/database/sql/sql.go#L1658-L1695"><code class="language-plaintext highlighter-rouge">execDC</code></a>, which automatically closes the prepared statement at the <a href="https://github.com/golang/go/blob/go1.20/src/database/sql/sql.go#L1693">end</a> of this method‚Äôs execution.</p>

<p>By ensuring that prepared statements are closed after completing their tasks, we can effectively prevent the total number of prepared statements on the server from surpassing the limit set by the system variable <a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_max_prepared_stmt_count">max_prepared_stmt_count</a>. Thus, it eliminates the likelihood of the error in the incident.</p>

<h2 id="set-connection-lifetime">Set Connection Lifetime</h2>

<p>The server maintains caches for prepared statements and stored programs on a per-connection basis. Statements cached for one connection are not accessible to other connections. When a connection ends, the server discards any statements cached for it.</p>

<p>In <a href="Prepared%20Statement%20in%20MySQL%20and%20Go%207a81af3563ee4ad69cfcff80ac65fa49.md">Figure 0</a>, neither <code class="language-plaintext highlighter-rouge">MaxConnLifetime</code> nor <code class="language-plaintext highlighter-rouge">MaxIdleTimeout</code> is set for any connection in the connection pool <code class="language-plaintext highlighter-rouge">db</code>, which means the connections never expire. This could result in an unbounded growth in the number of prepared statements if the connections are not closed.</p>

<p>By setting <strong>not</strong> too long lifetime for a connection, we can reduce the risk that the total number of prepared statements on the server is less likely to surpass the limit set by the system variable <a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_max_prepared_stmt_count">max_prepared_stmt_count</a>.</p>

<h2 id="enable-interpolateparams">Enable <code class="language-plaintext highlighter-rouge">InterpolateParams</code></h2>

<p>If <code class="language-plaintext highlighter-rouge">InterpolateParams</code> is set to true, placeholders are replaced with interpolated arguments to form a complete statement, and the client will request the server to execute this statement. When <code class="language-plaintext highlighter-rouge">InterpolateParams</code> is enabled, <code class="language-plaintext highlighter-rouge">db.Query("SELECT * FROM album WHERE title = ?", "L'Amour, Les Baguettes")</code> will form a complete statement: <code class="language-plaintext highlighter-rouge">SELECT * FROM album WHERE title = 'L\'Amour, Les Baguettes'</code>. By sending and executing the complete statement on the database server, the number of roundtrips mentioned earlier is significantly reduced, resulting in potential performance improvements.</p>

<p>To configure <code class="language-plaintext highlighter-rouge">InterpolateParams</code>, you can add the query parameter <code class="language-plaintext highlighter-rouge">interpolateParams</code> to the DSN like this: <code class="language-plaintext highlighter-rouge">mysql://user:pass@localhost:3306/dbname?interpolateParams=true</code>.</p>

<p>Unfortunately, parameter interpolation is not always feasible. According to the original <a href="https://github.com/go-sql-driver/mysql#interpolateparams">document</a>: ‚ÄúIt cannot be used together with the multibyte encodings BIG5, CP932, GB2312, GBK or SJIS. These are rejected as they may introduce a SQL injection vulnerability.‚Äù</p>

<p>Note that <code class="language-plaintext highlighter-rouge">InterpolateParams</code> doesn‚Äôt affect the explicit prepared statement in the standard library. The statement is still prepared and executed by the database server.</p>

<h2 id="reuse-prepared-statement">Reuse Prepared Statement</h2>

<p>While this point may not directly relate to the incident, it is still an important consideration when aiming to achieve higher performance through the use of prepared statements.</p>

<p>Because prepared statement requires additional round trip, if the network between the client and the server is unstable, this can potentially slow down your application. By default, if you perform the sequence of <code class="language-plaintext highlighter-rouge">Prepare</code> + <code class="language-plaintext highlighter-rouge">Execute</code> + <code class="language-plaintext highlighter-rouge">Close</code> a statement and then repeat the same sequence of <code class="language-plaintext highlighter-rouge">Prepare</code> + <code class="language-plaintext highlighter-rouge">Execute</code> + <code class="language-plaintext highlighter-rouge">Close</code> this statement again, both the client and the server do not retain any memory of the previous statement because it has already been closed. In this case, the database generates a completely new statement for the subsequent <code class="language-plaintext highlighter-rouge">Prepare</code> + <code class="language-plaintext highlighter-rouge">Query</code> + <code class="language-plaintext highlighter-rouge">Close</code> operation.</p>

<p>In terms of efficiency, if a query is executed only once and closed immediately, the prepared statement is worse than a non-prepared statement. The prepared statement is only efficient if it is prepared once, executed many times and is closed at the end. <em>maniwood</em> has a <a href="https://www.manniwood.com/2019_04_28/go_pg_stmt.html">blog post</a> that demonstrates the effectiveness and efficiency of reusing prepared statements.</p>

<p>However, we can leverage GORM to reuse prepared statements as much as possible. In GORM, there is a configuration called <a href="https://github.com/go-gorm/gorm/blob/v1.25.2/gorm.go#L35"><code class="language-plaintext highlighter-rouge">PrepareStmt</code></a> that, when enabled, uses a connection pool called <a href="https://github.com/go-gorm/gorm/blob/v1.25.2/prepare_stmt.go#L17-L22"><code class="language-plaintext highlighter-rouge">PreparedStmtDB</code></a> to cache prepared statements. Unlike the default connection pool, which prepares, executes, and closes a statement, the <a href="https://github.com/go-gorm/gorm/blob/v1.25.2/prepare_stmt.go#L17-L22"><code class="language-plaintext highlighter-rouge">PreparedStmtDB</code></a> connection pool takes a different approach. The implementation of <a href="https://github.com/go-gorm/gorm/blob/v1.25.2/prepare_stmt.go#L17-L22"><code class="language-plaintext highlighter-rouge">PreparedStmtDB</code></a> is described in <a href="Prepared%20Statement%20in%20MySQL%20and%20Go%207a81af3563ee4ad69cfcff80ac65fa49.md">Figure 9</a>.</p>

<p><a href="https://github.com/go-gorm/gorm/blob/v1.25.2/prepare_stmt.go#L17-L22"><code class="language-plaintext highlighter-rouge">PreparedStmtDB</code></a> checks application‚Äôs local in-memory cache to determine if the statement has already been prepared. If it has, the prepared statement is used for execution. If it has not been prepared yet, <a href="https://github.com/go-gorm/gorm/blob/v1.25.2/prepare_stmt.go#L17-L22"><code class="language-plaintext highlighter-rouge">PreparedStmtDB</code></a> asks server to prepare the statement, saves it to the application‚Äôs local in-memory cache, and then requests the server to execute the statement.</p>

<p>When we no longer needs <a href="https://github.com/go-gorm/gorm/blob/v1.25.2/prepare_stmt.go#L17-L22"><code class="language-plaintext highlighter-rouge">PreparedStmtDB</code></a> connection pool, we should close it by <code class="language-plaintext highlighter-rouge">Close</code> method. This method will eventually ask the server to close every cached prepared statement.</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="m">1</span>  <span class="k">package</span> <span class="n">gorm</span>
 <span class="m">2</span>  
 <span class="m">3</span>  <span class="k">func</span> <span class="p">(</span><span class="n">db</span> <span class="o">*</span><span class="n">PreparedStmtDB</span><span class="p">)</span> <span class="n">prepare</span><span class="p">(</span><span class="n">ctx</span> <span class="n">context</span><span class="o">.</span><span class="n">Context</span><span class="p">,</span> <span class="n">conn</span> <span class="n">ConnPool</span><span class="p">,</span> <span class="n">isTransaction</span> <span class="kt">bool</span><span class="p">,</span> <span class="n">query</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="n">Stmt</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
 <span class="m">4</span>    <span class="o">...</span>
 <span class="m">5</span>    <span class="k">if</span> <span class="n">stmt</span><span class="p">,</span> <span class="n">ok</span> <span class="o">:=</span> <span class="n">db</span><span class="o">.</span><span class="n">Stmts</span><span class="p">[</span><span class="n">query</span><span class="p">];</span> <span class="n">ok</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">!</span><span class="n">stmt</span><span class="o">.</span><span class="n">Transaction</span> <span class="o">||</span> <span class="n">isTransaction</span><span class="p">)</span> <span class="p">{</span>
 <span class="m">6</span>      <span class="o">...</span>
 <span class="m">7</span>      <span class="k">return</span> <span class="n">stmt</span><span class="p">,</span> <span class="no">nil</span>
 <span class="m">8</span>    <span class="p">}</span>
 <span class="m">9</span>    <span class="o">...</span>
<span class="m">10</span>    <span class="n">stmt</span><span class="p">,</span> <span class="n">err</span> <span class="o">:=</span> <span class="n">conn</span><span class="o">.</span><span class="n">PrepareContext</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">query</span><span class="p">)</span>
<span class="m">11</span>    <span class="k">if</span> <span class="n">err</span> <span class="o">==</span> <span class="no">nil</span> <span class="p">{</span>
<span class="m">12</span>      <span class="n">db</span><span class="o">.</span><span class="n">Stmts</span><span class="p">[</span><span class="n">query</span><span class="p">]</span> <span class="o">=</span> <span class="n">Stmt</span><span class="p">{</span><span class="n">Stmt</span><span class="o">:</span> <span class="n">stmt</span><span class="p">,</span> <span class="n">Transaction</span><span class="o">:</span> <span class="n">isTransaction</span><span class="p">}</span>
<span class="m">13</span>      <span class="n">db</span><span class="o">.</span><span class="n">PreparedSQL</span> <span class="o">=</span> <span class="nb">append</span><span class="p">(</span><span class="n">db</span><span class="o">.</span><span class="n">PreparedSQL</span><span class="p">,</span> <span class="n">query</span><span class="p">)</span>
<span class="m">14</span>      <span class="o">...</span>
<span class="m">15</span>    <span class="p">}</span>
<span class="m">16</span>  
<span class="m">17</span>    <span class="k">return</span> <span class="n">db</span><span class="o">.</span><span class="n">Stmts</span><span class="p">[</span><span class="n">query</span><span class="p">],</span> <span class="n">err</span>
<span class="m">18</span>  <span class="p">}</span>
<span class="m">19</span>  
<span class="m">20</span>  <span class="k">func</span> <span class="p">(</span><span class="n">db</span> <span class="o">*</span><span class="n">PreparedStmtDB</span><span class="p">)</span> <span class="n">QueryContext</span><span class="p">(</span><span class="n">ctx</span> <span class="n">context</span><span class="o">.</span><span class="n">Context</span><span class="p">,</span> <span class="n">query</span> <span class="kt">string</span><span class="p">,</span> <span class="n">args</span> <span class="o">...</span><span class="k">interface</span><span class="p">{})</span> <span class="p">(</span><span class="n">rows</span> <span class="o">*</span><span class="n">sql</span><span class="o">.</span><span class="n">Rows</span><span class="p">,</span> <span class="n">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
<span class="m">21</span>    <span class="n">stmt</span><span class="p">,</span> <span class="n">err</span> <span class="o">:=</span> <span class="n">db</span><span class="o">.</span><span class="n">prepare</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">db</span><span class="o">.</span><span class="n">ConnPool</span><span class="p">,</span> <span class="no">false</span><span class="p">,</span> <span class="n">query</span><span class="p">)</span>
<span class="m">22</span>    <span class="k">if</span> <span class="n">err</span> <span class="o">==</span> <span class="no">nil</span> <span class="p">{</span>
<span class="m">23</span>      <span class="n">rows</span><span class="p">,</span> <span class="n">err</span> <span class="o">=</span> <span class="n">stmt</span><span class="o">.</span><span class="n">QueryContext</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">args</span><span class="o">...</span><span class="p">)</span>
<span class="m">24</span>      <span class="o">...</span>
<span class="m">25</span>    <span class="p">}</span>
<span class="m">26</span>    <span class="k">return</span> <span class="n">rows</span><span class="p">,</span> <span class="n">err</span>
<span class="m">27</span>  <span class="p">}</span>
<span class="m">28</span>  
<span class="m">29</span>  <span class="k">func</span> <span class="p">(</span><span class="n">db</span> <span class="o">*</span><span class="n">PreparedStmtDB</span><span class="p">)</span> <span class="n">ExecContext</span><span class="p">(</span><span class="n">ctx</span> <span class="n">context</span><span class="o">.</span><span class="n">Context</span><span class="p">,</span> <span class="n">query</span> <span class="kt">string</span><span class="p">,</span> <span class="n">args</span> <span class="o">...</span><span class="k">interface</span><span class="p">{})</span> <span class="p">(</span><span class="n">result</span> <span class="n">sql</span><span class="o">.</span><span class="n">Result</span><span class="p">,</span> <span class="n">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
<span class="m">30</span>    <span class="n">stmt</span><span class="p">,</span> <span class="n">err</span> <span class="o">:=</span> <span class="n">db</span><span class="o">.</span><span class="n">prepare</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">db</span><span class="o">.</span><span class="n">ConnPool</span><span class="p">,</span> <span class="no">false</span><span class="p">,</span> <span class="n">query</span><span class="p">)</span>
<span class="m">31</span>    <span class="k">if</span> <span class="n">err</span> <span class="o">==</span> <span class="no">nil</span> <span class="p">{</span>
<span class="m">32</span>      <span class="n">result</span><span class="p">,</span> <span class="n">err</span> <span class="o">=</span> <span class="n">stmt</span><span class="o">.</span><span class="n">ExecContext</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">args</span><span class="o">...</span><span class="p">)</span>
<span class="m">33</span>      <span class="o">...</span>
<span class="m">34</span>    <span class="p">}</span>
<span class="m">35</span>    <span class="k">return</span> <span class="n">result</span><span class="p">,</span> <span class="n">err</span>
<span class="m">36</span>  <span class="p">}</span>
<span class="m">37</span>  
<span class="m">38</span>  <span class="k">func</span> <span class="p">(</span><span class="n">db</span> <span class="o">*</span><span class="n">PreparedStmtDB</span><span class="p">)</span> <span class="n">Close</span><span class="p">()</span> <span class="p">{</span>
<span class="m">39</span>    <span class="o">...</span>
<span class="m">40</span>    <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">query</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">db</span><span class="o">.</span><span class="n">PreparedSQL</span> <span class="p">{</span>
<span class="m">41</span>      <span class="k">if</span> <span class="n">stmt</span><span class="p">,</span> <span class="n">ok</span> <span class="o">:=</span> <span class="n">db</span><span class="o">.</span><span class="n">Stmts</span><span class="p">[</span><span class="n">query</span><span class="p">];</span> <span class="n">ok</span> <span class="p">{</span>
<span class="m">42</span>        <span class="o">...</span>
<span class="m">43</span>        <span class="k">go</span> <span class="n">stmt</span><span class="o">.</span><span class="n">Close</span><span class="p">()</span>
<span class="m">44</span>      <span class="p">}</span>
<span class="m">45</span>    <span class="p">}</span>
<span class="m">46</span>  <span class="p">}</span>
</code></pre></div></div>

<p>Unfortunately, there is a problem with the current (v1.25.2) implementation of <code class="language-plaintext highlighter-rouge">PreparedStmtDB</code>: a prepared statement never evicts from the application‚Äôs local in-memory cache except for the case where <a href="https://github.com/go-gorm/gorm/blob/v1.25.2/prepare_stmt.go#L141">an error happens while executing the prepared statement</a>. If the statement is rarely used, this approach could potentially lead to a memory leak. For applications that ue a large number of distinct prepared statements, this approach could result in high memory usage.</p>

<h1 id="working-with-prepared-statement-on-server-side">Working with Prepared Statement on Server-side</h1>

<p>Apart from using prepared statement properly, we also need monitoring to detect something abnormal with prepared statements.</p>

<p>Firstly, it is highly advisable to thoroughly review the current value assigned to the system variable <code class="language-plaintext highlighter-rouge">max_prepared_stmt_count</code> and ensure that it is appropriately configured to accommodate the anticipated workload.</p>

<p>Next, it is imperative to closely monitor the frequency of prepared statement execution and carefully assess the lifespan of these statements. If a prepared statement is seldom executed but remains active for an extended period, it may indicate a potential leakage.</p>

<p>Moreover, establishing comprehensive monitoring dashboards and implementing alert systems is of utmost importance to track the number of prepared statements within the database. By deploying such monitoring mechanisms, we can proactively detect any abnormal trends or sudden surges in the count of prepared statements, enabling timely interventions.</p>

<h1 id="summary">Summary</h1>

<p>The concept of prepared statements in Database Management Systems (DBMS) is widely known and embraced, as it brings forth a multitude of advantages encompassing security, convenience, and efficiency, which greatly enhance the overall functionality of database operations.</p>

<p>Despite its benefits, prepared statement could cause error if we don‚Äôt use it properly.It is crucial to close or deallocate prepared statements from the database server once we have finished working with them, especially when using the Go standard database client library. In GORM, however, there is no need to explicitly close prepared statements because GORM internally handles the management of prepared statements.</p>

<p>In case prepared statement must be avoided but parameterized query is unavoidable, we can use flag <code class="language-plaintext highlighter-rouge">InterpolateParams</code> so that parameters are interpolated and the complete query string is used instead or prepared statement.</p>

<h1 id="references">References</h1>

<ul>
  <li><a href="http://go-database-sql.org/prepared.html">http://go-database-sql.org/prepared.html</a></li>
  <li><a href="https://en.wikipedia.org/wiki/Prepared_statement">https://en.wikipedia.org/wiki/Prepared_statement</a></li>
  <li><a href="https://go.dev/doc/database/prepared-statements">https://go.dev/doc/database/prepared-statements</a></li>
  <li><a href="https://github.com/go-sql-driver/mysql#interpolateparams">https://github.com/go-sql-driver/mysql#interpolateparams</a></li>
  <li><a href="https://www.manniwood.com/2019_04_28/go_pg_stmt.html">https://www.manniwood.com/2019_04_28/go_pg_stmt.html</a></li>
  <li><a href="https://dev.mysql.com/doc/dev/mysql-server/latest/page_protocol_command_phase_ps.html">https://dev.mysql.com/doc/dev/mysql-server/latest/page_protocol_command_phase_ps.html</a></li>
</ul>]]></content><author><name>nghiant3223@gmail.com</name></author><summary type="html"><![CDATA[Prepared Statement in MySQL and Go]]></summary></entry></feed>